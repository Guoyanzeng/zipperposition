<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solve (logtk.Logtk.Monome.Int.Solve)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">logtk</a> &#x00BB; <a href="../../../index.html">Logtk</a> &#x00BB; <a href="../../index.html">Monome</a> &#x00BB; <a href="../index.html">Int</a> &#x00BB; Solve</nav><h1>Module <code>Int.Solve</code></h1></header><dl><dt class="spec type" id="type-solution"><a href="#type-solution" class="anchor"></a><code><span class="keyword">type</span> solution</code><code> = <span><span>(<a href="../../index.html#type-term">term</a> * <a href="../index.html#type-t">t</a>)</span> list</span></code></dt><dd><p>List of constraints (term = monome). It means that if all those constraints are satisfied, then a solution to the given problem has been found</p></dd></dl><dl><dt class="spec value" id="val-split_solution"><a href="#val-split_solution" class="anchor"></a><code><span class="keyword">val</span> split_solution : <a href="index.html#type-solution">solution</a> <span>&#45;&gt;</span> <a href="../../../Subst/index.html#type-t">Subst.t</a> * <a href="index.html#type-solution">solution</a></code></dt><dd><p>Split the solution into a variable substitution, and a list of constraints on non-variable terms</p></dd></dl><dl><dt class="spec value" id="val-diophant2"><a href="#val-diophant2" class="anchor"></a><code><span class="keyword">val</span> diophant2 : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t * Z.t * Z.t</code></dt><dd><p>Find the solution vector for this diophantine equation, or fails.</p><dl><dt>returns</dt><dd><p>a triple <code>u, v, gcd</code> such that for all int <code>k</code>, <code>u + b * k, v - a * k</code> is solution of equation <code>a * x + b * y = const</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the equation is unsolvable</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-diophant_l"><a href="#val-diophant_l" class="anchor"></a><code><span class="keyword">val</span> diophant_l : <span>Z.t list</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> <span>Z.t list</span> * Z.t</code></dt><dd><p>generalize diophantine equation solving to a list of at least two coefficients.</p><dl><dt>returns</dt><dd><p>a list of Bezout coefficients, and the GCD of the input list, or fails</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the equation is not solvable</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-coeffs_n"><a href="#val-coeffs_n" class="anchor"></a><code><span class="keyword">val</span> coeffs_n : <span>Z.t list</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> <span><a href="../../index.html#type-term">term</a> list</span> <span>&#45;&gt;</span> <span><a href="../index.html#type-t">t</a> list</span></code></dt><dd><p><code>coeffs_n l gcd</code>, if <code>length l = n</code>, returns a function that takes a list of <code>n-1</code> terms <code>k1, ..., k(n-1)</code> and returns a list of monomes <code>m1, ..., mn</code> that depend on <code>k1, ..., k(n-1)</code> such that the sum <code>l1 * m1 + l2 * m2 + ... + ln * mn = 0</code>.</p><p><b>Note</b> that the input list of the solution must have <code>n-1</code> elements, but that it returns a list of <code>n</code> elements!</p><dl><dt>parameter gcd</dt><dd><p>is the gcd of all members of <code>l</code>.</p></dd></dl><dl><dt>parameter l</dt><dd><p>is a list of at least 2 elements, none of which should be 0</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-eq_zero"><a href="#val-eq_zero" class="anchor"></a><code><span class="keyword">val</span> eq_zero : <span>?&#8288;fresh_var:<span>(<a href="../../../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../../index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-solution">solution</a> list</span></code></dt><dd><p>Returns substitutions that make the monome always equal to zero. Fresh variables may be generated using <code>fresh_var</code>, for diophantine equations. Returns the empty list if no solution is found.</p><p>For instance, on the monome 2X + 3Y - 7, it may generate a new variable Z and return the substitution <code>X -&gt; 3Z - 7, Y -&gt; 2Z + 7</code></p></dd></dl><dl><dt class="spec value" id="val-lower_zero"><a href="#val-lower_zero" class="anchor"></a><code><span class="keyword">val</span> lower_zero : <span>?&#8288;fresh_var:<span>(<a href="../../../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../../index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <span>strict:bool</span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-solution">solution</a> list</span></code></dt><dd><p>Solve for the monome to be always lower than zero (<code>strict</code> determines whether the inequality is strict or not). This may not return all solutions, but a subspace of it</p><dl><dt>parameter fresh_var</dt><dd><p>see <code>solve_eq_zero</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lt_zero"><a href="#val-lt_zero" class="anchor"></a><code><span class="keyword">val</span> lt_zero : <span>?&#8288;fresh_var:<span>(<a href="../../../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../../index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-solution">solution</a> list</span></code></dt><dd><p>Shortcut for <a href="index.html#val-lower_zero"><code>lower_zero</code></a> when <code>strict = true</code></p></dd></dl><dl><dt class="spec value" id="val-leq_zero"><a href="#val-leq_zero" class="anchor"></a><code><span class="keyword">val</span> leq_zero : <span>?&#8288;fresh_var:<span>(<a href="../../../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../../index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-solution">solution</a> list</span></code></dt><dd><p>Shortcut for <a href="index.html#val-lower_zero"><code>lower_zero</code></a> when <code>strict = false</code></p></dd></dl><dl><dt class="spec value" id="val-neq_zero"><a href="#val-neq_zero" class="anchor"></a><code><span class="keyword">val</span> neq_zero : <span>?&#8288;fresh_var:<span>(<a href="../../../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../../index.html#type-term">term</a>)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-solution">solution</a> list</span></code></dt><dd><p>Find some solutions that negate the equation. For now it just takes solutions to <code>m &lt; 0</code>.</p></dd></dl></div></body></html>