<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (libzipperposition.Libzipperposition_calculi__Superposition_intf.S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">libzipperposition</a> &#x00BB; <a href="../index.html">Libzipperposition_calculi__Superposition_intf</a> &#x00BB; S</nav><h1>Module type <code>Libzipperposition_calculi__Superposition_intf.S</code></h1><nav class="toc"><ul><li><a href="#term-indices">Term Indices</a></li><li><a href="#inference-rules">Inference Rules</a></li><li><a href="#extraction-of-clauses-from-the-queue-(ho-feature)">Extraction of clauses from the queue (HO feature)</a></li><li><a href="#simplifications-rules">Simplifications rules</a></li><li><a href="#registration">Registration</a></li></ul></nav></header><div class="spec module" id="module-Env"><a href="#module-Env" class="anchor"></a><code><span class="keyword">module</span> <a href="Env/index.html">Env</a> : <a href="../../Libzipperposition/Env/index.html#module-type-S">Libzipperposition.Env.S</a></code></div><div class="spec module" id="module-C"><a href="#module-C" class="anchor"></a><code><span class="keyword">module</span> C : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Env/index.html#module-C">Env.C</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Env/index.html#module-C">C</a>.t = <a href="Env/C/index.html#type-t">Env.C.t</a></code></div><div class="spec module" id="module-PS"><a href="#module-PS" class="anchor"></a><code><span class="keyword">module</span> PS : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Env/index.html#module-ProofState">Env.ProofState</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Env/index.html#module-ProofState">ProofState</a>.C.t = <a href="Env/C/index.html#type-t">Env.C.t</a></code></div><div class="spec module" id="module-Stm"><a href="#module-Stm" class="anchor"></a><code><span class="keyword">module</span> <a href="Stm/index.html">Stm</a> : <a href="../../Libzipperposition/Stream/index.html#module-type-S">Libzipperposition.Stream.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../Libzipperposition/Stream/module-type-S/C/index.html">C</a> = <a href="Env/index.html#module-C">Env.C</a></code></div><div class="spec module" id="module-StmQ"><a href="#module-StmQ" class="anchor"></a><code><span class="keyword">module</span> <a href="StmQ/index.html">StmQ</a> : <a href="../../Libzipperposition/StreamQueue/index.html#module-type-S">Libzipperposition.StreamQueue.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../Libzipperposition/StreamQueue/module-type-S/Stm/index.html">Stm</a> = <a href="index.html#module-Stm">Stm</a></code></div><section><header><h6 id="term-indices"><a href="#term-indices" class="anchor"></a>Term Indices</h6></header><dl><dt class="spec value" id="val-idx_sup_into"><a href="#val-idx_sup_into" class="anchor"></a><code><span class="keyword">val</span> idx_sup_into : unit <span>&#45;&gt;</span> <a href="Env/ProofState/TermIndex/index.html#type-t">PS.TermIndex.t</a></code></dt><dd><p>index for superposition into the set</p></dd></dl><dl><dt class="spec value" id="val-idx_sup_from"><a href="#val-idx_sup_from" class="anchor"></a><code><span class="keyword">val</span> idx_sup_from : unit <span>&#45;&gt;</span> <a href="Env/ProofState/TermIndex/index.html#type-t">PS.TermIndex.t</a></code></dt><dd><p>index for superposition from the set</p></dd></dl><dl><dt class="spec value" id="val-idx_fv"><a href="#val-idx_fv" class="anchor"></a><code><span class="keyword">val</span> idx_fv : unit <span>&#45;&gt;</span> <a href="Env/ProofState/SubsumptionIndex/index.html#type-t">PS.SubsumptionIndex.t</a></code></dt><dd><p>index for subsumption</p></dd></dl></section><section><header><h6 id="inference-rules"><a href="#inference-rules" class="anchor"></a>Inference Rules</h6></header><dl><dt class="spec value" id="val-infer_active"><a href="#val-infer_active" class="anchor"></a><code><span class="keyword">val</span> infer_active : <a href="Env/index.html#type-binary_inf_rule">Env.binary_inf_rule</a></code></dt><dd><p>superposition where given clause is active</p></dd></dl><dl><dt class="spec value" id="val-infer_passive"><a href="#val-infer_passive" class="anchor"></a><code><span class="keyword">val</span> infer_passive : <a href="Env/index.html#type-binary_inf_rule">Env.binary_inf_rule</a></code></dt><dd><p>superposition where given clause is passive</p></dd></dl><dl><dt class="spec value" id="val-infer_equality_resolution"><a href="#val-infer_equality_resolution" class="anchor"></a><code><span class="keyword">val</span> infer_equality_resolution : <a href="Env/index.html#type-unary_inf_rule">Env.unary_inf_rule</a></code></dt><dt class="spec value" id="val-infer_equality_factoring"><a href="#val-infer_equality_factoring" class="anchor"></a><code><span class="keyword">val</span> infer_equality_factoring : <a href="Env/index.html#type-unary_inf_rule">Env.unary_inf_rule</a></code></dt></dl></section><section><header><h6 id="extraction-of-clauses-from-the-queue-(ho-feature)"><a href="#extraction-of-clauses-from-the-queue-(ho-feature)" class="anchor"></a>Extraction of clauses from the queue (HO feature)</h6></header><dl><dt class="spec value" id="val-extract_from_stream_queue"><a href="#val-extract_from_stream_queue" class="anchor"></a><code><span class="keyword">val</span> extract_from_stream_queue : <a href="Env/index.html#type-generate_rule">Env.generate_rule</a></code></dt><dd><p>Extracts at most as many clauses from the stream queue as there are streams in the queue. If called with <code>~full=true</code> extracts only one clause but may loop forever.</p></dd></dl><dl><dt class="spec value" id="val-extract_from_stream_queue_fix_stm"><a href="#val-extract_from_stream_queue_fix_stm" class="anchor"></a><code><span class="keyword">val</span> extract_from_stream_queue_fix_stm : <a href="Env/index.html#type-generate_rule">Env.generate_rule</a></code></dt><dd><p>Same as <code>extract_from_stream_queue</code> with a different extraction heuristic If possible, all clauses are taken from the first stream</p></dd></dl></section><section><header><h6 id="simplifications-rules"><a href="#simplifications-rules" class="anchor"></a>Simplifications rules</h6></header><dl><dt class="spec value" id="val-is_tautology"><a href="#val-is_tautology" class="anchor"></a><code><span class="keyword">val</span> is_tautology : <a href="Env/C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the clause is a (syntactic) tautology, ie whether it contains true or &quot;A&quot; and &quot;not A&quot;</p></dd></dl><dl><dt class="spec value" id="val-is_semantic_tautology"><a href="#val-is_semantic_tautology" class="anchor"></a><code><span class="keyword">val</span> is_semantic_tautology : <a href="Env/C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>semantic tautology deletion, using a congruence closure algorithm to see if negative literals imply some positive Literal.t</p></dd></dl><dl><dt class="spec value" id="val-handle_distinct_constants"><a href="#val-handle_distinct_constants" class="anchor"></a><code><span class="keyword">val</span> handle_distinct_constants : <a href="Env/index.html#type-lit_rewrite_rule">Env.lit_rewrite_rule</a></code></dt><dd><p>Decide on &quot;quoted&quot; &quot;symbols&quot; (which are all distinct)</p></dd></dl><dl><dt class="spec value" id="val-basic_simplify"><a href="#val-basic_simplify" class="anchor"></a><code><span class="keyword">val</span> basic_simplify : <a href="Env/index.html#type-simplify_rule">Env.simplify_rule</a></code></dt><dd><p>basic simplifications (remove duplicate literals, trivial literals, destructive equality resolution...)</p></dd></dl><dl><dt class="spec value" id="val-subsumes"><a href="#val-subsumes" class="anchor"></a><code><span class="keyword">val</span> subsumes : <span><a href="../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span> <span>&#45;&gt;</span> <span><a href="../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>subsumes c1 c2 iff c1 subsumes c2</p></dd></dl><dl><dt class="spec value" id="val-subsumes_with"><a href="#val-subsumes_with" class="anchor"></a><code><span class="keyword">val</span> subsumes_with : <span><a href="../../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a> <a href="../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <span><a href="../../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a> <a href="../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../../logtk/Logtk/Subst/FO/index.html#type-t">Logtk.Subst.FO.t</a> * <span><a href="../../../logtk/Logtk/Proof/index.html#type-tag">Logtk.Proof.tag</a> list</span>)</span> option</span></code></dt><dd><p>returns subsuming subst if the first clause subsumes the second one</p></dd></dl><dl><dt class="spec value" id="val-eq_subsumes"><a href="#val-eq_subsumes" class="anchor"></a><code><span class="keyword">val</span> eq_subsumes : <span><a href="../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span> <span>&#45;&gt;</span> <span><a href="../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>equality subsumption</p></dd></dl><dl><dt class="spec value" id="val-subsumed_by_active_set"><a href="#val-subsumed_by_active_set" class="anchor"></a><code><span class="keyword">val</span> subsumed_by_active_set : <a href="Env/C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>check whether the clause is subsumed by any clause in the set</p></dd></dl><dl><dt class="spec value" id="val-subsumed_in_active_set"><a href="#val-subsumed_in_active_set" class="anchor"></a><code><span class="keyword">val</span> subsumed_in_active_set : <a href="Env/index.html#type-backward_redundant_rule">Env.backward_redundant_rule</a></code></dt><dd><p>list of clauses in the active set that are subsumed by the clause</p></dd></dl><dl><dt class="spec value" id="val-contextual_literal_cutting"><a href="#val-contextual_literal_cutting" class="anchor"></a><code><span class="keyword">val</span> contextual_literal_cutting : <a href="Env/index.html#type-simplify_rule">Env.simplify_rule</a></code></dt><dd><p>contextual Literal.t cutting of the given clause by the active set</p></dd></dl><dl><dt class="spec value" id="val-condensation"><a href="#val-condensation" class="anchor"></a><code><span class="keyword">val</span> condensation : <a href="Env/index.html#type-simplify_rule">Env.simplify_rule</a></code></dt><dd><p>condensation</p></dd></dl></section><section><header><h6 id="registration"><a href="#registration" class="anchor"></a>Registration</h6></header><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Register rules in the environment</p></dd></dl></section></div></body></html>