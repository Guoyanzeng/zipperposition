<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (libzipperposition.Libzipperposition_calculi__Simplex.S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">libzipperposition</a> &#x00BB; <a href="../index.html">Libzipperposition_calculi__Simplex</a> &#x00BB; S</nav><h1>Module type <code>Libzipperposition_calculi__Simplex.S</code></h1><nav class="toc"><ul><li><a href="#simplex-construction">Simplex construction</a></li><li><a href="#simplex-solving">Simplex solving</a></li><li><a href="#simplex-optimizations">Simplex optimizations</a></li><li><a href="#access-functions">Access functions</a></li><li><a href="#printing-functions">Printing functions</a></li></ul></nav></header><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code></dt><dd><p>The given type of the variables</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a (possibly not solved) linear system</p></dd></dl><dl><dt class="spec type" id="type-res"><a href="#type-res" class="anchor"></a><code><span class="keyword">type</span> <span>'cert res</span></code><code> = </code><table class="variant"><tr id="type-res.Solution" class="anchored"><td class="def constructor"><a href="#type-res.Solution" class="anchor"></a><code>| </code><code><span class="constructor">Solution</span> <span class="keyword">of</span> <span><span>(<a href="index.html#type-var">var</a> * Q.t)</span> list</span></code></td></tr><tr id="type-res.Unsatisfiable" class="anchored"><td class="def constructor"><a href="#type-res.Unsatisfiable" class="anchor"></a><code>| </code><code><span class="constructor">Unsatisfiable</span> <span class="keyword">of</span> <span class="type-var">'cert</span></code></td></tr></table></dt><dd><p>Generic type returned when solving the simplex. A solution is a list of bindings that satisfies all the constraints inside the system. If the system is unsatisfiable, an explanation of type <code>'cert</code> is returned.</p></dd></dl><dl><dt class="spec type" id="type-k_cert"><a href="#type-k_cert" class="anchor"></a><code><span class="keyword">type</span> k_cert</code><code> = <a href="index.html#type-var">var</a> * <span><span>(Q.t * <a href="index.html#type-var">var</a>)</span> list</span></code></dt><dd><p>An unsatisfiability explanation is a couple <code>(x, expr)</code>. If <code>expr</code> is the empty list, then there is a contradiction between two given bounds of <code>x</code>. Else, the explanation is an equality <code>x = expr</code> that is valid (it can be derived from the original equations of the system) from which a bound can be deduced which contradicts an already given bound of the system.</p></dd></dl><dl><dt class="spec type" id="type-n_cert"><a href="#type-n_cert" class="anchor"></a><code><span class="keyword">type</span> n_cert</code><code> = <span><span><a href="index.html#type-cert_tree">cert_tree</a> option</span> Pervasives.ref</span></code></dt><dt class="spec type" id="type-cert_tree"><a href="#type-cert_tree" class="anchor"></a><code><span class="keyword">and</span> cert_tree</code><code> = </code><table class="variant"><tr id="type-cert_tree.Branch" class="anchored"><td class="def constructor"><a href="#type-cert_tree.Branch" class="anchor"></a><code>| </code><code><span class="constructor">Branch</span> <span class="keyword">of</span> <a href="index.html#type-var">var</a> * Z.t * <a href="index.html#type-n_cert">n_cert</a> * <a href="index.html#type-n_cert">n_cert</a></code></td></tr><tr id="type-cert_tree.Explanation" class="anchored"><td class="def constructor"><a href="#type-cert_tree.Explanation" class="anchor"></a><code>| </code><code><span class="constructor">Explanation</span> <span class="keyword">of</span> <a href="index.html#type-k_cert">k_cert</a></code></td><td class="doc"><p>The type of explanation for integer systems. In one case, the system is unsatisfiable when seen as a rational system. In the other case, two cases are considered : for a given variable <code>x</code> and a bound <code>b</code>, either <code>x</code> is lower than <code>b</code>, or it is greater then <code>b + 1</code>.</p></td></tr></table></dt><dt class="spec type" id="type-k_res"><a href="#type-k_res" class="anchor"></a><code><span class="keyword">type</span> k_res</code><code> = <span><a href="index.html#type-k_cert">k_cert</a> <a href="index.html#type-res">res</a></span></code></dt><dt class="spec type" id="type-n_res"><a href="#type-n_res" class="anchor"></a><code><span class="keyword">type</span> n_res</code><code> = <span><a href="index.html#type-n_cert">n_cert</a> <a href="index.html#type-res">res</a></span></code></dt><dd><p>Types returned when solving a system.</p></dd></dl><dl><dt class="spec type" id="type-optim"><a href="#type-optim" class="anchor"></a><code><span class="keyword">type</span> optim</code><code> = </code><table class="variant"><tr id="type-optim.Tight" class="anchored"><td class="def constructor"><a href="#type-optim.Tight" class="anchor"></a><code>| </code><code><span class="constructor">Tight</span> <span class="keyword">of</span> <a href="index.html#type-var">var</a></code></td></tr><tr id="type-optim.Multiply" class="anchored"><td class="def constructor"><a href="#type-optim.Multiply" class="anchor"></a><code>| </code><code><span class="constructor">Multiply</span> <span class="keyword">of</span> <a href="index.html#type-var">var</a> * Q.t</code></td></tr></table></dt><dd><p>The type of traces of the optimizations performed on a simplex.</p></dd></dl><dl><dt class="spec type" id="type-debug_printer"><a href="#type-debug_printer" class="anchor"></a><code><span class="keyword">type</span> debug_printer</code><code> = Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>TODO</p></dd></dl><section><header><h4 id="simplex-construction"><a href="#simplex-construction" class="anchor"></a>Simplex construction</h4></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty system</p></dd></dl><dl><dt class="spec value" id="val-add_eq"><a href="#val-add_eq" class="anchor"></a><code><span class="keyword">val</span> add_eq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-var">var</a> * <span><span>(Q.t * <a href="index.html#type-var">var</a>)</span> list</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_eq s (x, eq)</code> returns a system containing the same constraints as <code>s</code>, plus the equation (x = eq).</p></dd></dl><dl><dt class="spec value" id="val-add_bounds"><a href="#val-add_bounds" class="anchor"></a><code><span class="keyword">val</span> add_bounds : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-var">var</a> * Q.t * Q.t)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_bounds (x, lower, upper)</code> returns a system containing the same constraints as <code>s</code>, plus the bounds <code>lower</code> and <code>upper</code> for the given variable <code>x</code>. If the bound is loose on one side (no upper bounds for instance), the values <code>Zarith.Q.inf</code> and <code>Zarith.Q.minus_inf</code> can be used. By default, in a system, all variables have no bounds, i.e have lower bound <code>Zarith.Q.minus_inf</code> and upper bound <code>Zarith.Q.inf</code>.</p></dd></dl></section><section><header><h4 id="simplex-solving"><a href="#simplex-solving" class="anchor"></a>Simplex solving</h4></header><dl><dt class="spec value" id="val-ksolve"><a href="#val-ksolve" class="anchor"></a><code><span class="keyword">val</span> ksolve : <span>?&#8288;debug:<a href="index.html#type-debug_printer">debug_printer</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-k_res">k_res</a></code></dt><dd><p><code>ksolve s</code> solves the system <code>s</code> and returns a solution, if one exists. This function may change the internal representation of the system to that of an equivalent one (permutation of basic and non basic variables and pivot operation on the tableaux).</p><dl><dt>parameter debug</dt><dd><p>An optional debug option can be given, and will be applied to all systems encountered while solving the system, including the initial and final states of the system. Can be used for printing intermediate states of the system.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nsolve"><a href="#val-nsolve" class="anchor"></a><code><span class="keyword">val</span> nsolve : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-n_res">n_res</a></code></dt><dd><p><code>nsolve s int_vars</code> solve the system <code>s</code> considering the variables in <code>int_vars</code> as integers instead of rationals. There is no guarantee that this function will terminate (for instance, on the system (<code>1 &lt;= 3 * x + 3 * y &lt;= 2</code>, <code>nsolve</code> will NOT terminate), it hence recommended to apply a global bounds to the variables of a system before trying to solve it with this function.</p><dl><dt>parameter debug</dt><dd><p>An optional debug option can be given, and will be applied to all systems encountered at the end of a branch while solving the system. Can be used for printing intermediate states of the system.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-safe_nsolve"><a href="#val-safe_nsolve" class="anchor"></a><code><span class="keyword">val</span> safe_nsolve : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> Q.t * <a href="index.html#type-n_res">n_res</a></code></dt><dd><p><code>safe_nsolve s int_vars</code> solves the system <code>s</code> considering the variables in <code>int_vars</code> as integers. This function always terminate, thanks to a global bound that is applied to all variables of int_vars. The global bound is also returned to allow for verification. Due to the bounds being very high, <code>safe_nsolve</code> may take a lot of time and memory. It is recommended to apply some optimizations before trying to solve system using this function.</p></dd></dl></section><section><header><h4 id="simplex-optimizations"><a href="#simplex-optimizations" class="anchor"></a>Simplex optimizations</h4></header><dl><dt class="spec value" id="val-tighten"><a href="#val-tighten" class="anchor"></a><code><span class="keyword">val</span> tighten : <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optim">optim</a> list</span></code></dt><dd><p><code>tighten int_vars s</code> tightens all the bounds of the variables in <code>int_vars</code> and returns the list of optimizations performed on the system.</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optim">optim</a> list</span></code></dt><dd><p><code>normalize int_vars s</code>, normalizes the system <code>s</code> (in place), and returns the list of optimizations performed on it. <code>int_vars</code> is the list of variable that should be assigned an integer. A normalized system has only integer coefficients in his tableaux. Furthermore, in any line (i.e in the expression of a basic variable <code>x</code>), the gcd of all coefficients is <code>1</code>. This includes the bounds of <code>x</code>, except in the following case. If all pertinent variables (have a non-zero coefficient) in the expression of <code>x</code> are in <code>int_vars</code>, then the bounds are divided by the gcd of the coefficients in the expression, and then rounded (since we can deduce that <code>x</code> must be an integer as well).</p></dd></dl><dl><dt class="spec value" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><code><span class="keyword">val</span> preprocess : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-optim">optim</a> list</span></code></dt><dd><p>Apply all optimizations to a simplex.</p></dd></dl><dl><dt class="spec value" id="val-apply_optims"><a href="#val-apply_optims" class="anchor"></a><code><span class="keyword">val</span> apply_optims : <span><span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optim">optim</a> list</span>)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optim">optim</a> list</span></code></dt><dd><p>Apply the given optimizations to the simplex.</p></dd></dl></section><section><header><h4 id="access-functions"><a href="#access-functions" class="anchor"></a>Access functions</h4></header><dl><dt class="spec value" id="val-get_tab"><a href="#val-get_tab" class="anchor"></a><code><span class="keyword">val</span> get_tab : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var">var</a> list</span> * <span><a href="index.html#type-var">var</a> list</span> * <span><span>Q.t list</span> list</span></code></dt><dd><p><code>get_tab s</code> returns the current tableaux of <code>s</code> as a triple <code>(l, l', tab)</code> where <code>l</code> is the list of the non-basic variables, <code>l'</code> the list of basic variables and <code>tab</code> the list of the rows of the tableaux in the same order as <code>l</code> and <code>l'</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_assign"><a href="#val-get_assign" class="anchor"></a><code><span class="keyword">val</span> get_assign : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * Q.t)</span> list</span></code></dt><dd><p><code>get_assign s</code> returns the current (partial) assignment of the variables in <code>s</code> as a list of bindings. Only non-basic variables (as given by <code>get_tab</code>) should appear in this assignent. As such, and according to simplex invariants, all variables in the assignment returned should satisfy their bounds.</p></dd></dl><dl><dt class="spec value" id="val-get_full_assign"><a href="#val-get_full_assign" class="anchor"></a><code><span class="keyword">val</span> get_full_assign : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * Q.t)</span> list</span></code></dt><dt class="spec value" id="val-get_bounds"><a href="#val-get_bounds" class="anchor"></a><code><span class="keyword">val</span> get_bounds : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> Q.t * Q.t</code></dt><dd><p><code>get_bounds s x</code> returns the pair <code>(low, upp)</code> of the current bounds for the variable <code>x</code>. Notice that it is possible that <code>low</code> is strictly greater than <code>upp</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_all_bounds"><a href="#val-get_all_bounds" class="anchor"></a><code><span class="keyword">val</span> get_all_bounds : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-var">var</a> * <span>(Q.t * Q.t)</span>)</span> list</span></code></dt><dd><p><code>get_all_bounds s</code> returns the list of all the explicit bounds of <code>s</code>. Any variable not present in the return value is assumed to have no bounds (i.e lower bound <code>Zarith.Q.minus_inf</code> and upper bound <code>Zarith.Q.inf</code>).</p></dd></dl></section><section><header><h4 id="printing-functions"><a href="#printing-functions" class="anchor"></a>Printing functions</h4></header><dl><dt class="spec value" id="val-print_debug"><a href="#val-print_debug" class="anchor"></a><code><span class="keyword">val</span> print_debug : <span>(Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>print_debug print_var</code> returns a suitable function for printing debug info on the current state of a system. It can for instance be used as the debug function of <code>solve</code> to see the evolution of the simplex.</p></dd></dl></section></div></body></html>