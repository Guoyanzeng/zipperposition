<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (libzipperposition.Libzipperposition_calculi.Avatar_intf.S)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">libzipperposition</a> &#x00BB; <a href="../../index.html">Libzipperposition_calculi</a> &#x00BB; <a href="../index.html">Avatar_intf</a> &#x00BB; S</nav><h1>Module type <code>Avatar_intf.S</code></h1></header><div class="spec module" id="module-E"><a href="#module-E" class="anchor"></a><code><span class="keyword">module</span> <a href="E/index.html">E</a> : <a href="../../../Libzipperposition/Env/index.html#module-type-S">Libzipperposition.Env.S</a></code></div><div class="spec module" id="module-Solver"><a href="#module-Solver" class="anchor"></a><code><span class="keyword">module</span> <a href="Solver/index.html">Solver</a> : <a href="../../../Libzipperposition/Sat_solver/index.html#module-type-S">Libzipperposition.Sat_solver.S</a></code></div><div class="spec module" id="module-BLit"><a href="#module-BLit" class="anchor"></a><code><span class="keyword">module</span> BLit = <a href="../../../Libzipperposition/BBox/index.html#module-Lit">Libzipperposition.BBox.Lit</a></code></div><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <a href="E/index.html#type-multi_simpl_rule">E.multi_simpl_rule</a></code></dt><dd><p>Split a clause into components</p></dd></dl><dl><dt class="spec value" id="val-check_empty"><a href="#val-check_empty" class="anchor"></a><code><span class="keyword">val</span> check_empty : <a href="E/index.html#type-unary_inf_rule">E.unary_inf_rule</a></code></dt><dd><p>Forbid empty clauses with trails, i.e. adds the negation of their trails to the SAT-solver</p></dd></dl><dl><dt class="spec value" id="val-before_check_sat"><a href="#val-before_check_sat" class="anchor"></a><code><span class="keyword">val</span> before_check_sat : <span>unit <a href="../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dt class="spec value" id="val-after_check_sat"><a href="#val-after_check_sat" class="anchor"></a><code><span class="keyword">val</span> after_check_sat : <span>unit <a href="../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dt class="spec value" id="val-filter_absurd_trails"><a href="#val-filter_absurd_trails" class="anchor"></a><code><span class="keyword">val</span> filter_absurd_trails : <span>(<a href="../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>filter_trails f</code> calls <code>f</code> on every trail associated with the empty clause. If <code>f</code> returns <code>false</code>, the trail is ignored, otherwise it's negated and sent to the SAT solver</p></dd></dl><dl><dt class="spec value" id="val-check_satisfiability"><a href="#val-check_satisfiability" class="anchor"></a><code><span class="keyword">val</span> check_satisfiability : <a href="E/index.html#type-generate_rule">E.generate_rule</a></code></dt><dd><p>Checks that the SAT context is still valid</p></dd></dl><dl><dt class="spec type" id="type-cut_res"><a href="#type-cut_res" class="anchor"></a><code><span class="keyword">type</span> cut_res</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-cut_res.cut_form" class="anchored"><td class="def field"><a href="#type-cut_res.cut_form" class="anchor"></a><code>cut_form : <a href="../../../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a>;</code></td><td class="doc"><p>the lemma itself</p></td></tr><tr id="type-cut_res.cut_pos" class="anchored"><td class="def field"><a href="#type-cut_res.cut_pos" class="anchor"></a><code>cut_pos : <span><a href="E/C/index.html#type-t">E.C.t</a> list</span>;</code></td><td class="doc"><p>clauses true if lemma is true</p></td></tr><tr id="type-cut_res.cut_lit" class="anchored"><td class="def field"><a href="#type-cut_res.cut_lit" class="anchor"></a><code>cut_lit : <a href="../../../Libzipperposition__BBox/Lit/index.html#type-t">BLit.t</a>;</code></td><td class="doc"><p>lit that is true if lemma is true</p></td></tr><tr id="type-cut_res.cut_depth" class="anchored"><td class="def field"><a href="#type-cut_res.cut_depth" class="anchor"></a><code>cut_depth : int;</code></td><td class="doc"><p>if the lemma is used to prove another lemma</p></td></tr><tr id="type-cut_res.cut_proof" class="anchored"><td class="def field"><a href="#type-cut_res.cut_proof" class="anchor"></a><code>cut_proof : <a href="../../../../logtk/Logtk/Proof/Step/index.html#type-t">Logtk.Proof.Step.t</a>;</code></td><td class="doc"><p>where does the lemma come from?</p></td></tr><tr id="type-cut_res.cut_proof_parent" class="anchored"><td class="def field"><a href="#type-cut_res.cut_proof_parent" class="anchor"></a><code>cut_proof_parent : <a href="../../../../logtk/Logtk/Proof/Parent/index.html#type-t">Logtk.Proof.Parent.t</a>;</code></td><td class="doc"><p>how to justify sth from the lemma</p></td></tr><tr id="type-cut_res.cut_reason" class="anchored"><td class="def field"><a href="#type-cut_res.cut_reason" class="anchor"></a><code>cut_reason : <span><span>unit CCFormat.printer</span> option</span>;</code></td><td class="doc"><p>Informal reason why the lemma was added</p></td></tr></table><code>}</code></dt><dd><p>This represents a cut on a formula, where we obtain a list of clauses <code>cut_pos</code> representing the formula itself with the trail <code>lemma</code>, and a boolean literal <code>cut_lit</code> that is true iff the trail is true.</p><p>Other modules, when a cut is introduced, will try to disprove the lemma (e.g. by induction or theory reasoning).</p></dd></dl><dl><dt class="spec value" id="val-cut_form"><a href="#val-cut_form" class="anchor"></a><code><span class="keyword">val</span> cut_form : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <a href="../../../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a></code></dt><dt class="spec value" id="val-cut_pos"><a href="#val-cut_pos" class="anchor"></a><code><span class="keyword">val</span> cut_pos : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <span><a href="E/C/index.html#type-t">E.C.t</a> list</span></code></dt><dt class="spec value" id="val-cut_lit"><a href="#val-cut_lit" class="anchor"></a><code><span class="keyword">val</span> cut_lit : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <a href="../../../Libzipperposition__BBox/Lit/index.html#type-t">BLit.t</a></code></dt><dt class="spec value" id="val-cut_depth"><a href="#val-cut_depth" class="anchor"></a><code><span class="keyword">val</span> cut_depth : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-cut_proof"><a href="#val-cut_proof" class="anchor"></a><code><span class="keyword">val</span> cut_proof : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <a href="../../../../logtk/Logtk/Proof/Step/index.html#type-t">Logtk.Proof.Step.t</a></code></dt><dt class="spec value" id="val-cut_proof_parent"><a href="#val-cut_proof_parent" class="anchor"></a><code><span class="keyword">val</span> cut_proof_parent : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <a href="../../../../logtk/Logtk/Proof/Parent/index.html#type-t">Logtk.Proof.Parent.t</a></code></dt><dt class="spec value" id="val-pp_cut_res"><a href="#val-pp_cut_res" class="anchor"></a><code><span class="keyword">val</span> pp_cut_res : <span><a href="index.html#type-cut_res">cut_res</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-cut_res_clauses"><a href="#val-cut_res_clauses" class="anchor"></a><code><span class="keyword">val</span> cut_res_clauses : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <span><a href="E/C/index.html#type-t">E.C.t</a> Iter.t</span></code></dt><dt class="spec value" id="val-print_lemmas"><a href="#val-print_lemmas" class="anchor"></a><code><span class="keyword">val</span> print_lemmas : <span>unit CCFormat.printer</span></code></dt><dd><p>print the current list of lemmas, and their status</p></dd></dl><dl><dt class="spec value" id="val-introduce_cut"><a href="#val-introduce_cut" class="anchor"></a><code><span class="keyword">val</span> introduce_cut : <span>?&#8288;reason:<span>unit CCFormat.printer</span></span> <span>&#45;&gt;</span> <span>?&#8288;penalty:int</span> <span>&#45;&gt;</span> <span>?&#8288;depth:int</span> <span>&#45;&gt;</span> <a href="../../../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a> <span>&#45;&gt;</span> <a href="../../../../logtk/Logtk/Proof/Step/index.html#type-t">Logtk.Proof.Step.t</a> <span>&#45;&gt;</span> <a href="index.html#type-cut_res">cut_res</a></code></dt><dd><p>Introduce a cut on the given clause(s). Pure.</p><dl><dt>parameter reason</dt><dd><p>some comment on why the lemma was added</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_prove_lemma"><a href="#val-add_prove_lemma" class="anchor"></a><code><span class="keyword">val</span> add_prove_lemma : <span>(<a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <span><span><a href="E/C/index.html#type-t">E.C.t</a> list</span> <a href="E/index.html#type-conversion_result">E.conversion_result</a></span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a mean of proving lemmas</p></dd></dl><dl><dt class="spec value" id="val-add_lemma"><a href="#val-add_lemma" class="anchor"></a><code><span class="keyword">val</span> add_lemma : <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given cut to the list of lemmas. Modifies the global list of lemmas. It will call the functions added by <a href="index.html#val-add_prove_lemma"><code>add_prove_lemma</code></a> to try and prove this one.</p></dd></dl><dl><dt class="spec value" id="val-add_imply"><a href="#val-add_imply" class="anchor"></a><code><span class="keyword">val</span> add_imply : <span><a href="index.html#type-cut_res">cut_res</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-cut_res">cut_res</a> <span>&#45;&gt;</span> <a href="../../../../logtk/Logtk/Proof/Step/index.html#type-t">Logtk.Proof.Step.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_imply l res</code> means that the conjunction of lemmas in <code>l</code> implies that the lemma <code>res</code> is proven</p></dd></dl><dl><dt class="spec value" id="val-on_input_lemma"><a href="#val-on_input_lemma" class="anchor"></a><code><span class="keyword">val</span> on_input_lemma : <span><a href="index.html#type-cut_res">cut_res</a> <a href="../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Triggered every time a cut is introduced for an input lemma (i.e. every time a statement of the form `lemma F` is translated)</p></dd></dl><dl><dt class="spec value" id="val-on_lemma"><a href="#val-on_lemma" class="anchor"></a><code><span class="keyword">val</span> on_lemma : <span><a href="index.html#type-cut_res">cut_res</a> <a href="../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Triggered every time a cut is introduced, by any means. In particular it is triggered at least as often as <a href="index.html#val-on_input_lemma"><code>on_input_lemma</code></a></p></dd></dl><dl><dt class="spec value" id="val-convert_lemma"><a href="#val-convert_lemma" class="anchor"></a><code><span class="keyword">val</span> convert_lemma : <a href="E/index.html#type-clause_conversion_rule">E.clause_conversion_rule</a></code></dt><dd><p>Intercepts input lemmas and converts them into clauses. Triggers <a href="index.html#val-on_input_lemma"><code>on_input_lemma</code></a> with the resulting cut</p></dd></dl><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : <span>split:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Register inference rules to the environment</p><dl><dt>parameter split</dt><dd><p>if true, the clause splitting rule is added. Otherwise Avatar is only used for other things such as induction.</p></dd></dl></dd></dl></div></body></html>