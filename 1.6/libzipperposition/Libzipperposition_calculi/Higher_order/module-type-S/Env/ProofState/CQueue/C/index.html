<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>C (libzipperposition.Libzipperposition_calculi.Higher_order.S.Env.ProofState.CQueue.C)</title><link rel="stylesheet" href="../../../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../../../index.html">libzipperposition</a> &#x00BB; <a href="../../../../../../index.html">Libzipperposition_calculi</a> &#x00BB; <a href="../../../../../index.html">Higher_order</a> &#x00BB; <a href="../../../../index.html">S</a> &#x00BB; <a href="../../../index.html">Env</a> &#x00BB; <a href="../../index.html">ProofState</a> &#x00BB; <a href="../index.html">CQueue</a> &#x00BB; C</nav><h1>Module <code>CQueue.C</code></h1><nav class="toc"><ul><li><a href="#flags">Flags</a></li><li><a href="#basics">Basics</a></li><li><a href="#boolean-abstraction">Boolean Abstraction</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#filter-literals">Filter literals</a></li><li><a href="#set-of-clauses">Set of clauses</a></li><li><a href="#position">Position</a></li><li><a href="#clauses-with-more-data">Clauses with more data</a></li><li><a href="#io">IO</a></li></ul></nav></header><div class="spec module" id="module-Ctx"><a href="#module-Ctx" class="anchor"></a><code><span class="keyword">module</span> Ctx = <a href="../../C/index.html#module-Ctx">C.Ctx</a></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../../C/index.html#type-t">C.t</a></code></dt><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">type</span> clause</code><code> = <a href="index.html#type-t">t</a></code></dt></dl><section><header><h3 id="flags"><a href="#flags" class="anchor"></a>Flags</h3></header><dl><dt class="spec type" id="type-flag"><a href="#type-flag" class="anchor"></a><code><span class="keyword">type</span> flag</code><code> = <a href="../../../../../../../Libzipperposition/SClause/index.html#type-flag">Libzipperposition.SClause.flag</a></code></dt></dl><dl><dt class="spec value" id="val-set_flag"><a href="#val-set_flag" class="anchor"></a><code><span class="keyword">val</span> set_flag : <a href="index.html#type-flag">flag</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p>set boolean flag</p></dd></dl><dl><dt class="spec value" id="val-get_flag"><a href="#val-get_flag" class="anchor"></a><code><span class="keyword">val</span> get_flag : <a href="index.html#type-flag">flag</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>get value of boolean flag</p></dd></dl><dl><dt class="spec value" id="val-mark_redundant"><a href="#val-mark_redundant" class="anchor"></a><code><span class="keyword">val</span> mark_redundant : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-is_redundant"><a href="#val-is_redundant" class="anchor"></a><code><span class="keyword">val</span> is_redundant : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mark_backward_simplified"><a href="#val-mark_backward_simplified" class="anchor"></a><code><span class="keyword">val</span> mark_backward_simplified : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-is_backward_simplified"><a href="#val-is_backward_simplified" class="anchor"></a><code><span class="keyword">val</span> is_backward_simplified : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h3 id="basics"><a href="#basics" class="anchor"></a>Basics</h3></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../../../../../logtk/Logtk/Interfaces/index.html#module-type-EQ">Logtk.Interfaces.EQ</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../../../../../logtk/Logtk/Interfaces/module-type-EQ/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../../../../../logtk/Logtk/Interfaces/index.html#module-type-HASH">Logtk.Interfaces.HASH</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../../../../../logtk/Logtk/Interfaces/module-type-HASH/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../../../../../logtk/Logtk/Interfaces/index.html#module-type-EQ">Logtk.Interfaces.EQ</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-lits"><a href="#val-lits" class="anchor"></a><code><span class="keyword">val</span> lits : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../../../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span></code></dt><dt class="spec value" id="val-is_ground"><a href="#val-is_ground" class="anchor"></a><code><span class="keyword">val</span> is_ground : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-weight"><a href="#val-weight" class="anchor"></a><code><span class="keyword">val</span> weight : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module</span> Tbl = <a href="../../C/index.html#module-Tbl">C.Tbl</a></code></div><dl><dt class="spec value" id="val-is_goal"><a href="#val-is_goal" class="anchor"></a><code><span class="keyword">val</span> is_goal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Looking at the clause's proof, return <code>true</code> iff the clause is an initial (negated) goal from the problem</p></dd></dl><dl><dt class="spec value" id="val-distance_to_goal"><a href="#val-distance_to_goal" class="anchor"></a><code><span class="keyword">val</span> distance_to_goal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Proof.distance_to_goal&quot;"><code>Proof</code>.distance_to_goal</span>, applied to the clause's proof</p></dd></dl><dl><dt class="spec value" id="val-comes_from_goal"><a href="#val-comes_from_goal" class="anchor"></a><code><span class="keyword">val</span> comes_from_goal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>true</code> iff the clause is (indirectly) deduced from a goal or lemma</p></dd></dl></section><section><header><h3 id="boolean-abstraction"><a href="#boolean-abstraction" class="anchor"></a>Boolean Abstraction</h3></header><dl><dt class="spec value" id="val-pp_trail"><a href="#val-pp_trail" class="anchor"></a><code><span class="keyword">val</span> pp_trail : <span><a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a> CCFormat.printer</span></code></dt><dd><p>Printer for boolean trails, that uses <a href="Ctx/index.html"><code>Ctx</code></a> to display boxes</p></dd></dl><dl><dt class="spec value" id="val-has_trail"><a href="#val-has_trail" class="anchor"></a><code><span class="keyword">val</span> has_trail : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Has a non-empty trail?</p></dd></dl><dl><dt class="spec value" id="val-trail"><a href="#val-trail" class="anchor"></a><code><span class="keyword">val</span> trail : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a></code></dt><dd><p>Get the clause's trail</p></dd></dl><dl><dt class="spec value" id="val-trail_l"><a href="#val-trail_l" class="anchor"></a><code><span class="keyword">val</span> trail_l : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a></code></dt><dd><p>Merge the trails of several clauses</p></dd></dl><dl><dt class="spec value" id="val-update_trail"><a href="#val-update_trail" class="anchor"></a><code><span class="keyword">val</span> update_trail : <span>(<a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Change the trail. The resulting clause has same parents, proof and literals as the input one</p></dd></dl><dl><dt class="spec value" id="val-trail_subsumes"><a href="#val-trail_subsumes" class="anchor"></a><code><span class="keyword">val</span> trail_subsumes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>trail_subsumes c1 c2 = Trail.subsumes (get_trail c1) (get_trail c2)</code></p></dd></dl><dl><dt class="spec value" id="val-is_active"><a href="#val-is_active" class="anchor"></a><code><span class="keyword">val</span> is_active : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>v:<a href="../../../../../../../Libzipperposition/Trail/index.html#type-valuation">Libzipperposition.Trail.valuation</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>True if the clause's trail is active in this valuation</p></dd></dl><dl><dt class="spec value" id="val-is_inj_axiom"><a href="#val-is_inj_axiom" class="anchor"></a><code><span class="keyword">val</span> is_inj_axiom : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../../../../../../../logtk/Logtk/ID/index.html#type-t">Logtk.ID.t</a> * int)</span> option</span></code></dt><dd><p>Returns Some (sym,i) if clause is injectivity axiom for ith argument of symbol sym.</p></dd></dl></section><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>penalty:int</span> <span>&#45;&gt;</span> <span>trail:<a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a></span> <span>&#45;&gt;</span> <span><a href="../../../../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> list</span> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a new clause from the given literals.</p><dl><dt>parameter trail</dt><dd><p>boolean trail</p></dd></dl><dl><dt>parameter penalty</dt><dd><p>heuristic penalty due to history of the clause (the higher, the less likely the clause is to be picked soon) also takes a list of literals and a proof builder</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_a"><a href="#val-create_a" class="anchor"></a><code><span class="keyword">val</span> create_a : <span>penalty:int</span> <span>&#45;&gt;</span> <span>trail:<a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a></span> <span>&#45;&gt;</span> <span><a href="../../../../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> array</span> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a new clause from the given literals.</p></dd></dl><dl><dt class="spec value" id="val-of_sclause"><a href="#val-of_sclause" class="anchor"></a><code><span class="keyword">val</span> of_sclause : <span>?&#8288;penalty:int</span> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/SClause/index.html#type-t">Libzipperposition.SClause.t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_forms"><a href="#val-of_forms" class="anchor"></a><code><span class="keyword">val</span> of_forms : <span>?&#8288;penalty:int</span> <span>&#45;&gt;</span> <span>trail:<a href="../../../../../../../Libzipperposition/Trail/index.html#type-t">Libzipperposition.Trail.t</a></span> <span>&#45;&gt;</span> <span><span><a href="../../../../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> <a href="../../../../../../../../logtk/Logtk/SLiteral/index.html#type-t">Logtk.SLiteral.t</a></span> list</span> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Directly from list of formulas</p></dd></dl><dl><dt class="spec value" id="val-of_forms_axiom"><a href="#val-of_forms_axiom" class="anchor"></a><code><span class="keyword">val</span> of_forms_axiom : <span>?&#8288;penalty:int</span> <span>&#45;&gt;</span> <span>file:string</span> <span>&#45;&gt;</span> <span>name:string</span> <span>&#45;&gt;</span> <span><span><a href="../../../../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> <a href="../../../../../../../../logtk/Logtk/SLiteral/index.html#type-t">Logtk.SLiteral.t</a></span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Construction from formulas as axiom (initial clause)</p></dd></dl><dl><dt class="spec value" id="val-of_statement"><a href="#val-of_statement" class="anchor"></a><code><span class="keyword">val</span> of_statement : <span>?&#8288;convert_defs:bool</span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Statement/index.html#type-clause_t">Logtk.Statement.clause_t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p>Extract a clause from a statement, if any</p></dd></dl><dl><dt class="spec value" id="val-proof_step"><a href="#val-proof_step" class="anchor"></a><code><span class="keyword">val</span> proof_step : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a></code></dt><dd><p>Extract its proof from the clause</p></dd></dl><dl><dt class="spec value" id="val-proof"><a href="#val-proof" class="anchor"></a><code><span class="keyword">val</span> proof : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof">Libzipperposition.Clause_intf.proof</a></code></dt><dd><p>Obtain the pair <code>conclusion, step</code></p></dd></dl><dl><dt class="spec value" id="val-proof_parent"><a href="#val-proof_parent" class="anchor"></a><code><span class="keyword">val</span> proof_parent : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Proof/Parent/index.html#type-t">Logtk.Proof.Parent.t</a></code></dt><dt class="spec value" id="val-proof_parent_subst"><a href="#val-proof_parent_subst" class="anchor"></a><code><span class="keyword">val</span> proof_parent_subst : <a href="../../../../../../../../logtk/Logtk/Subst/Renaming/index.html#type-t">Logtk.Subst.Renaming.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Proof/Parent/index.html#type-t">Logtk.Proof.Parent.t</a></code></dt><dt class="spec value" id="val-update_proof"><a href="#val-update_proof" class="anchor"></a><code><span class="keyword">val</span> update_proof : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/Clause_intf/index.html#type-proof_step">Libzipperposition.Clause_intf.proof_step</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>update_proof c f</code> creates a new clause that is similar to <code>c</code> in all aspects, but with the proof <code>f (proof_step c)</code></p></dd></dl><dl><dt class="spec value" id="val-proof_depth"><a href="#val-proof_depth" class="anchor"></a><code><span class="keyword">val</span> proof_depth : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the clause an empty clause?</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Number of literals</p></dd></dl><dl><dt class="spec value" id="val-maxlits"><a href="#val-maxlits" class="anchor"></a><code><span class="keyword">val</span> maxlits : <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> CCBV.t</code></dt><dd><p>List of maximal literals</p></dd></dl><dl><dt class="spec value" id="val-is_maxlit"><a href="#val-is_maxlit" class="anchor"></a><code><span class="keyword">val</span> is_maxlit : <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> <span>idx:int</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the i-th literal maximal in subst(clause)? Equivalent to Bitvector.get (maxlits ~ord c subst) i</p></dd></dl><dl><dt class="spec value" id="val-eligible_res"><a href="#val-eligible_res" class="anchor"></a><code><span class="keyword">val</span> eligible_res : <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> CCBV.t</code></dt><dd><p>Bitvector that indicates which of the literals of <code>subst(clause)</code> are eligible for resolution. THe literal has to be either maximal among selected literals of the same sign, if some literal is selected, or maximal if none is selected.</p></dd></dl><dl><dt class="spec value" id="val-eligible_res_no_subst"><a href="#val-eligible_res_no_subst" class="anchor"></a><code><span class="keyword">val</span> eligible_res_no_subst : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> CCBV.t</code></dt><dd><p>More efficient version of <a href="index.html#val-eligible_res"><code>eligible_res</code></a> with <code>Subst.empty</code></p></dd></dl><dl><dt class="spec value" id="val-eligible_param"><a href="#val-eligible_param" class="anchor"></a><code><span class="keyword">val</span> eligible_param : <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> CCBV.t</code></dt><dd><p>Bitvector that indicates which of the literals of <code>subst(clause)</code> are eligible for paramodulation. That means the literal is positive, no literal is selecteed, and the literal is maximal among literals of <code>subst(clause)</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_eligible_param"><a href="#val-is_eligible_param" class="anchor"></a><code><span class="keyword">val</span> is_eligible_param : <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/index.html#type-t">Logtk.Subst.t</a> <span>&#45;&gt;</span> <span>idx:int</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the <code>idx</code>-th literal is eligible for paramodulation</p></dd></dl><dl><dt class="spec value" id="val-has_selected_lits"><a href="#val-has_selected_lits" class="anchor"></a><code><span class="keyword">val</span> has_selected_lits : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>does the clause have some selected literals?</p></dd></dl><dl><dt class="spec value" id="val-is_selected"><a href="#val-is_selected" class="anchor"></a><code><span class="keyword">val</span> is_selected : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p>check whether a literal is selected</p></dd></dl><dl><dt class="spec value" id="val-selected_lits"><a href="#val-selected_lits" class="anchor"></a><code><span class="keyword">val</span> selected_lits : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../../../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> * int)</span> list</span></code></dt><dd><p>get the list of selected literals</p></dd></dl><dl><dt class="spec value" id="val-penalty"><a href="#val-penalty" class="anchor"></a><code><span class="keyword">val</span> penalty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_unit_clause"><a href="#val-is_unit_clause" class="anchor"></a><code><span class="keyword">val</span> is_unit_clause : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the clause a unit clause?</p></dd></dl><dl><dt class="spec value" id="val-is_oriented_rule"><a href="#val-is_oriented_rule" class="anchor"></a><code><span class="keyword">val</span> is_oriented_rule : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the clause a positive oriented clause?</p></dd></dl><dl><dt class="spec value" id="val-symbols"><a href="#val-symbols" class="anchor"></a><code><span class="keyword">val</span> symbols : <span>?&#8288;init:<a href="../../../../../../../../logtk/Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t</span> <span>&#45;&gt;</span> <span>?&#8288;include_types:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Iter.t</span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t</code></dt><dd><p>symbols that occur in the clause</p></dd></dl><dl><dt class="spec value" id="val-to_sclause"><a href="#val-to_sclause" class="anchor"></a><code><span class="keyword">val</span> to_sclause : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../Libzipperposition/SClause/index.html#type-t">Libzipperposition.SClause.t</a></code></dt><dt class="spec value" id="val-to_forms"><a href="#val-to_forms" class="anchor"></a><code><span class="keyword">val</span> to_forms : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="../../../../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> <a href="../../../../../../../../logtk/Logtk/SLiteral/index.html#type-t">Logtk.SLiteral.t</a></span> list</span></code></dt><dd><p>Easy iteration on an abstract view of literals</p></dd></dl><dl><dt class="spec value" id="val-to_s_form"><a href="#val-to_s_form" class="anchor"></a><code><span class="keyword">val</span> to_s_form : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/TypedSTerm/Form/index.html#type-t">Logtk.TypedSTerm.Form.t</a></code></dt><dt class="spec value" id="val-ground_clause"><a href="#val-ground_clause" class="anchor"></a><code><span class="keyword">val</span> ground_clause : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-eta_reduce"><a href="#val-eta_reduce" class="anchor"></a><code><span class="keyword">val</span> eta_reduce : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt></dl></section><section><header><h3 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h3></header><div class="spec module" id="module-Seq"><a href="#module-Seq" class="anchor"></a><code><span class="keyword">module</span> Seq = <a href="../../C/index.html#module-Seq">C.Seq</a></code></div><dl><dt class="spec value" id="val-apply_subst"><a href="#val-apply_subst" class="anchor"></a><code><span class="keyword">val</span> apply_subst : <span>?&#8288;proof:<span><a href="../../../../../../../../logtk/Logtk/Proof/Step/index.html#type-t">Logtk.Proof.Step.t</a> option</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../../../../../../../../logtk/Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a></span> <span>&#45;&gt;</span> <a href="../../../../../../../../logtk/Logtk/Subst/FO/index.html#type-t">Logtk.Subst.FO.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h3 id="filter-literals"><a href="#filter-literals" class="anchor"></a>Filter literals</h3></header><div class="spec module" id="module-Eligible"><a href="#module-Eligible" class="anchor"></a><code><span class="keyword">module</span> Eligible = <a href="../../C/index.html#module-Eligible">C.Eligible</a></code></div></section><section><header><h3 id="set-of-clauses"><a href="#set-of-clauses" class="anchor"></a>Set of clauses</h3></header><dl><dt class="spec module" id="module-ClauseSet"><a href="#module-ClauseSet" class="anchor"></a><code><span class="keyword">module</span> ClauseSet = <a href="../../C/index.html#module-ClauseSet">C.ClauseSet</a></code></dt><dd><p>Simple set</p></dd></dl></section><section><header><h3 id="position"><a href="#position" class="anchor"></a>Position</h3></header><div class="spec module" id="module-Pos"><a href="#module-Pos" class="anchor"></a><code><span class="keyword">module</span> Pos = <a href="../../C/index.html#module-Pos">C.Pos</a></code></div></section><section><header><h3 id="clauses-with-more-data"><a href="#clauses-with-more-data" class="anchor"></a>Clauses with more data</h3></header><dl><dt class="spec module" id="module-WithPos"><a href="#module-WithPos" class="anchor"></a><code><span class="keyword">module</span> WithPos = <a href="../../C/index.html#module-WithPos">C.WithPos</a></code></dt><dd><p>Clause within which a subterm (and its position) are highlighted</p></dd></dl></section><section><header><h3 id="io"><a href="#io" class="anchor"></a>IO</h3></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_tstp"><a href="#val-pp_tstp" class="anchor"></a><code><span class="keyword">val</span> pp_tstp : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_tstp_full"><a href="#val-pp_tstp_full" class="anchor"></a><code><span class="keyword">val</span> pp_tstp_full : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dd><p>Print in a cnf() statement</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Debug printing to a string</p></dd></dl><dl><dt class="spec value" id="val-pp_set"><a href="#val-pp_set" class="anchor"></a><code><span class="keyword">val</span> pp_set : <span><a href="index.html#module-ClauseSet">ClauseSet</a>.t CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_set_tstp"><a href="#val-pp_set_tstp" class="anchor"></a><code><span class="keyword">val</span> pp_set_tstp : <span><a href="index.html#module-ClauseSet">ClauseSet</a>.t CCFormat.printer</span></code></dt></dl></section></div></body></html>