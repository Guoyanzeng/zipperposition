<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Libzipperposition__BBox (libzipperposition.Libzipperposition__BBox)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">libzipperposition</a> &#x00BB; Libzipperposition__BBox</nav><h1>Module <code>Libzipperposition__BBox</code></h1><h2 id="bbox-(boolean-box)"><a href="#bbox-(boolean-box)" class="anchor"></a>BBox (Boolean Box)</h2><p>This module defines a way to encapsulate clauses and some meta-level properties into boolean literals, and maintains a bijection between encapsulated values and boolean literals</p><nav class="toc"><ul><li><a href="#printers">Printers</a></li></ul></nav></header><dl><dt class="spec value" id="val-section"><a href="#val-section" class="anchor"></a><code><span class="keyword">val </span>section : <a href="../../logtk/Logtk/Util/Section/index.html#type-t">Logtk.Util.Section.t</a></code></dt></dl><dl><dt class="spec type" id="type-inductive_case"><a href="#type-inductive_case" class="anchor"></a><code><span class="keyword">type </span>inductive_case</code><code><span class="keyword"> = </span><a href="../Libzipperposition/Cover_set/index.html#type-case">Libzipperposition.Cover_set.case</a></code></dt><dt class="spec type" id="type-payload"><a href="#type-payload" class="anchor"></a><code><span class="keyword">type </span>payload</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-payload.Fresh" class="anchored"><td class="def constructor"><a href="#type-payload.Fresh" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fresh</span></code></td></tr><tr id="type-payload.Clause_component" class="anchored"><td class="def constructor"><a href="#type-payload.Clause_component" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Clause_component</span><span class="keyword"> of </span><a href="../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a></code></td></tr><tr id="type-payload.Lemma" class="anchored"><td class="def constructor"><a href="#type-payload.Lemma" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma</span><span class="keyword"> of </span><a href="../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a></code></td></tr><tr id="type-payload.Case" class="anchored"><td class="def constructor"><a href="#type-payload.Case" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Case</span><span class="keyword"> of </span><a href="index.html#type-inductive_case">inductive_case</a> list</code></td></tr></table></dt></dl><div class="spec module" id="module-Lit"><a href="#module-Lit" class="anchor"></a><code><span class="keyword">module </span><a href="Lit/index.html">Lit</a> : <a href="../Libzipperposition/Bool_lit_intf/index.html#module-type-S">Libzipperposition.Bool_lit_intf.S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Libzipperposition/Bool_lit_intf/module-type-S/index.html#type-payload">payload</a><span class="keyword"> = </span><a href="index.html#type-payload">payload</a></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="Lit/index.html#type-t">Lit.t</a></code></dt></dl><dl><dt class="spec value" id="val-dummy"><a href="#val-dummy" class="anchor"></a><code><span class="keyword">val </span>dummy : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-pp_payload"><a href="#val-pp_payload" class="anchor"></a><code><span class="keyword">val </span>pp_payload : <a href="index.html#type-payload">payload</a> CCFormat.printer</code></dt><dt class="spec value" id="val-inject_lits"><a href="#val-inject_lits" class="anchor"></a><code><span class="keyword">val </span>inject_lits : <a href="../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inject a clause into a boolean literal. No other clause will map to the same literal unless it is alpha-equivalent to this one. The boolean literal can be negative is the argument is a unary negative clause</p></dd></dl><dl><dt class="spec value" id="val-inject_lemma"><a href="#val-inject_lemma" class="anchor"></a><code><span class="keyword">val </span>inject_lemma : <a href="../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a new literal from this formula that we are going to cut on. This is generative, meaning that calling it twice with the same arguments will produce distinct literals.</p></dd></dl><dl><dt class="spec value" id="val-inject_case"><a href="#val-inject_case" class="anchor"></a><code><span class="keyword">val </span>inject_case : <a href="index.html#type-inductive_case">inductive_case</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inject <code>cst = case</code></p></dd></dl><dl><dt class="spec value" id="val-payload"><a href="#val-payload" class="anchor"></a><code><span class="keyword">val </span>payload : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-payload">payload</a></code></dt><dd><p>Obtain the payload of this boolean literal, that is, what the literal represents</p></dd></dl><dl><dt class="spec value" id="val-is_case"><a href="#val-is_case" class="anchor"></a><code><span class="keyword">val </span>is_case : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-as_case"><a href="#val-as_case" class="anchor"></a><code><span class="keyword">val </span>as_case : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-inductive_case">inductive_case</a> list option</code></dt><dd><p>If <code>payload t = Case p</code>, then return <code>Some p</code>, else return <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-as_lemma"><a href="#val-as_lemma" class="anchor"></a><code><span class="keyword">val </span>as_lemma : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Libzipperposition/Cut_form/index.html#type-t">Libzipperposition.Cut_form.t</a> option</code></dt><dt class="spec value" id="val-must_be_kept"><a href="#val-must_be_kept" class="anchor"></a><code><span class="keyword">val </span>must_be_kept : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>must_be_kept lit</code> means that <code>lit</code> should survive in boolean splitting, that is, that if <code>C &lt;- lit, Gamma</code> then any clause derived from <code>C</code> recursively will have <code>lit</code> in its trail.</p></dd></dl><dl><dt class="spec value" id="val-is_lemma"><a href="#val-is_lemma" class="anchor"></a><code><span class="keyword">val </span>is_lemma : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>returns <code>true</code> if the bool literal represents a lemma</p></dd></dl><dl><dt class="spec value" id="val-to_s_form"><a href="#val-to_s_form" class="anchor"></a><code><span class="keyword">val </span>to_s_form : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../logtk/Logtk/TypedSTerm/Form/index.html#type-t">Logtk.TypedSTerm.Form.t</a></code></dt></dl><section><header><h3 id="printers"><a href="#printers" class="anchor"></a>Printers</h3><p>Those printers print the content (injection) of a boolean literal, if any</p></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> CCFormat.printer</code></dt><dt class="spec value" id="val-pp_tstp"><a href="#val-pp_tstp" class="anchor"></a><code><span class="keyword">val </span>pp_tstp : <a href="index.html#type-t">t</a> CCFormat.printer</code></dt><dt class="spec value" id="val-pp_zf"><a href="#val-pp_zf" class="anchor"></a><code><span class="keyword">val </span>pp_zf : <a href="index.html#type-t">t</a> CCFormat.printer</code></dt><dt class="spec value" id="val-pp_bclause"><a href="#val-pp_bclause" class="anchor"></a><code><span class="keyword">val </span>pp_bclause : <a href="index.html#type-t">t</a> list CCFormat.printer</code></dt></dl></section></div></body></html>