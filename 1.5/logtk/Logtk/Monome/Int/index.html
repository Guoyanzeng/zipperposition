<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Int (logtk.Logtk.Monome.Int)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">logtk</a> &#x00BB; <a href="../../index.html">Logtk</a> &#x00BB; <a href="../index.html">Monome</a> &#x00BB; Int</nav><h1>Module <code>Monome.Int</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span>Z.t <a href="../index.html#type-monome">monome</a></code></dt></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val </span>const : Z.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty monomial, from constant (decides type)</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : Z.t <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty monomial, from constant (decides type)</p><p>One term.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : Z.t <span>&#45;&gt;</span> (Z.t<span class="keyword"> * </span><a href="../index.html#type-term">term</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>One term.</p></dd></dl><dl><dt class="spec value" id="val-of_term"><a href="#val-of_term" class="anchor"></a><code><span class="keyword">val </span>of_term : <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dt class="spec value" id="val-of_term_exn"><a href="#val-of_term_exn" class="anchor"></a><code><span class="keyword">val </span>of_term_exn : <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>try to get a monome from a term.</p><dl><dt>raises NotLinear</dt><dd><p>if the term is not a proper monome.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_term"><a href="#val-to_term" class="anchor"></a><code><span class="keyword">val </span>to_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a></code></dt><dd><p>convert back to a term</p></dd></dl><dl><dt class="spec value" id="val-has_instances"><a href="#val-has_instances" class="anchor"></a><code><span class="keyword">val </span>has_instances : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>For real or rational, always true. For integers, returns true iff g divides <code>m.constant</code>, where g is the GCD of <code>c</code> for <code>c</code> in <code>m.coeffs</code>.</p><p>The intuition is that this returns <code>true</code> iff the monome actually has some instances in its type. Trivially true in reals or rationals, this is only the case for integers if <code>m.coeffs + m.constant = 0</code> is a satisfiable diophantine equation.</p></dd></dl><dl><dt class="spec value" id="val-quotient"><a href="#val-quotient" class="anchor"></a><code><span class="keyword">val </span>quotient : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>quotient e c</code> tries to divide <code>e</code> by <code>c</code>, returning <code>e/c</code> if it is still an integer expression. For instance, <code>quotient (2x + 4y) 2</code> will return <code>Some (x + 2y)</code></p></dd></dl><dl><dt class="spec value" id="val-divisible"><a href="#val-divisible" class="anchor"></a><code><span class="keyword">val </span>divisible : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> bool</code></dt><dd><p><code>divisible e n</code> returns true if all coefficients of <code>e</code> are divisible by <code>n</code> and n is an int &gt;= 2</p></dd></dl><dl><dt class="spec value" id="val-factorize"><a href="#val-factorize" class="anchor"></a><code><span class="keyword">val </span>factorize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a><span class="keyword"> * </span>Z.t) option</code></dt><dd><p>Factorize <code>e</code> into <code>Some (e',s)</code> if <code>e = e' x s</code>, None otherwise (ie if s=1). In case it returns <code>Some (e', s)</code>, <code>s &gt; 1</code> holds</p></dd></dl><dl><dt class="spec value" id="val-normalize_wrt_zero"><a href="#val-normalize_wrt_zero" class="anchor"></a><code><span class="keyword">val </span>normalize_wrt_zero : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Allows to multiply or divide by any positive number since we consider that the monome is equal to (or compared with) zero. For integer monomes, the result will have co-prime coefficients.</p></dd></dl><dl><dt class="spec value" id="val-reduce_same_factor"><a href="#val-reduce_same_factor" class="anchor"></a><code><span class="keyword">val </span>reduce_same_factor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p><code>reduce_same_factor m1 m2 t</code> multiplies <code>m1</code> and <code>m2</code> by some constants, so that their coefficient for <code>t</code> is the same.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>t</code> does not belong to <code>m1</code> or <code>m2</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : (<a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="../index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="../../Comparison/index.html#type-t">Comparison.t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Comparison/index.html#type-t">Comparison.t</a></code></dt><dd><p>Compare monomes as if they were multisets of terms, the coefficient in front of a term being its multiplicity.</p></dd></dl><dl><dt class="spec value" id="val-to_multiset"><a href="#val-to_multiset" class="anchor"></a><code><span class="keyword">val </span>to_multiset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Multisets/MT/index.html#type-t">Multisets.MT.t</a></code></dt><dd><p>Multiset of terms with multiplicity</p></dd></dl><section><header><h3 id="modular-computations"><a href="#modular-computations" class="anchor"></a>Modular Computations</h3></header><div class="spec module" id="module-Modulo"><a href="#module-Modulo" class="anchor"></a><code><span class="keyword">module </span><a href="Modulo/index.html">Modulo</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="find-solutions"><a href="#find-solutions" class="anchor"></a>Find Solutions</h3></header><div class="spec module" id="module-Solve"><a href="#module-Solve" class="anchor"></a><code><span class="keyword">module </span><a href="Solve/index.html">Solve</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>