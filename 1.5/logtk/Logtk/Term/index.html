<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Term (logtk.Logtk.Term)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; Term</nav><h1>Module <code>Logtk.Term</code></h1></header><section><header><h2 id="lambda-free-terms"><a href="#lambda-free-terms" class="anchor"></a>Lambda-free Terms</h2></header><aside><p>Those terms provide a first-order presentation of higher-order terms (without functions), in the sense that they make currying possible (as well as applying functions to other terms).</p><p>This is as if terms had an `apply` symbol everywhere, but more lightweight.</p><p>Types and terms are mixed because it makes application much easier (applying to a type and to a term are the same thing). It might also make dependent typing possible some day.</p></aside><section><header><h3 id="term"><a href="#term" class="anchor"></a>Term</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><span class="keyword">private </span><a href="../InnerTerm/index.html#type-t">InnerTerm.t</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type </span>term</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type </span>var</code><code><span class="keyword"> = </span><a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a></code></dt><dd><p>Variables are typed with <a href="../Type/index.html#type-t"><code>Type.t</code></a></p></dd></dl><dl><dt class="spec type" id="type-view"><a href="#type-view" class="anchor"></a><code><span class="keyword">type </span>view</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-view.AppBuiltin" class="anchored"><td class="def constructor"><a href="#type-view.AppBuiltin" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AppBuiltin</span><span class="keyword"> of </span><a href="../Builtin/index.html#type-t">Builtin.t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a> list</code></td></tr><tr id="type-view.DB" class="anchored"><td class="def constructor"><a href="#type-view.DB" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">DB</span><span class="keyword"> of </span>int</code></td><td class="doc"><p>Bound variable (De Bruijn index)</p></td></tr><tr id="type-view.Var" class="anchored"><td class="def constructor"><a href="#type-view.Var" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Var</span><span class="keyword"> of </span><a href="index.html#type-var">var</a></code></td><td class="doc"><p>Term variable</p></td></tr><tr id="type-view.Const" class="anchored"><td class="def constructor"><a href="#type-view.Const" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Const</span><span class="keyword"> of </span><a href="../ID/index.html#type-t">ID.t</a></code></td><td class="doc"><p>Typed constant</p></td></tr><tr id="type-view.App" class="anchored"><td class="def constructor"><a href="#type-view.App" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">App</span><span class="keyword"> of </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a> list</code></td><td class="doc"><p>Application to a list of terms (cannot be left-nested)</p></td></tr><tr id="type-view.Fun" class="anchored"><td class="def constructor"><a href="#type-view.Fun" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fun</span><span class="keyword"> of </span><a href="../Type/index.html#type-t">Type.t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>Lambda abstraction</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val </span>view : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-view">view</a></code></dt></dl><dl><dt class="spec module" id="module-Classic"><a href="#module-Classic" class="anchor"></a><code><span class="keyword">module </span><a href="Classic/index.html">Classic</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec value" id="val-subterm"><a href="#val-subterm" class="anchor"></a><code><span class="keyword">val </span>subterm : sub:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>checks whether <code>sub</code> is a (non-strict) subterm of <code>t</code></p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Interfaces/index.html#module-type-HASH">Interfaces.HASH</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Interfaces/module-type-HASH/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Interfaces/index.html#module-type-EQ">Interfaces.EQ</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val </span>hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Interfaces/index.html#module-type-ORD">Interfaces.ORD</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Interfaces/module-type-ORD/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-ty"><a href="#val-ty" class="anchor"></a><code><span class="keyword">val </span>ty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a></code></dt><dd><p>Obtain the type of a term..</p></dd></dl><div class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module </span>Set : CCSet.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Set">Set</a>.elt<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module </span>Map : CCMap.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Map">Map</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module </span>Tbl : CCHashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Tbl">Tbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-hash_mod_alpha"><a href="#val-hash_mod_alpha" class="anchor"></a><code><span class="keyword">val </span>hash_mod_alpha : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Hash invariant w.r.t variable renaming</p></dd></dl><dl><dt class="spec value" id="val-same_l"><a href="#val-same_l" class="anchor"></a><code><span class="keyword">val </span>same_l : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>same_l l1 l2</code> returns <code>true</code> if terms of <code>l1</code> and <code>l2</code> are pairwise equal, <code>false</code> otherwise. Precondition: both lists have the same length</p><dl><dt>raises Assert_failure</dt><dd><p>if lists have not the same length</p></dd></dl></dd></dl></section><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val </span>var : <a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-var_of_int"><a href="#val-var_of_int" class="anchor"></a><code><span class="keyword">val </span>var_of_int : ty:<a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bvar"><a href="#val-bvar" class="anchor"></a><code><span class="keyword">val </span>bvar : ty:<a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a bound variable. Providing a type is mandatory. <b>Warning</b>: be careful and try not to use this function directly.</p><dl><dt>raises InnerTerm.IllFormedTerm</dt><dd><p>if the index is &lt; 0</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-builtin"><a href="#val-builtin" class="anchor"></a><code><span class="keyword">val </span>builtin : ty:<a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../Builtin/index.html#type-t">Builtin.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-app_builtin"><a href="#val-app_builtin" class="anchor"></a><code><span class="keyword">val </span>app_builtin : ty:<a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../Builtin/index.html#type-t">Builtin.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val </span>const : ty:<a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a typed constant</p></dd></dl><dl><dt class="spec value" id="val-tyapp"><a href="#val-tyapp" class="anchor"></a><code><span class="keyword">val </span>tyapp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a term to types</p><dl><dt>raises Type.Error</dt><dd><p>if types do not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val </span>app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a term to a list of terms</p><dl><dt>raises Type.ApplyError</dt><dd><p>if types do not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-app_full"><a href="#val-app_full" class="anchor"></a><code><span class="keyword">val </span>app_full : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply the term to types, then to terms</p></dd></dl><dl><dt class="spec value" id="val-true_"><a href="#val-true_" class="anchor"></a><code><span class="keyword">val </span>true_ : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-false_"><a href="#val-false_" class="anchor"></a><code><span class="keyword">val </span>false_ : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_"><a href="#val-fun_" class="anchor"></a><code><span class="keyword">val </span>fun_ : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_l"><a href="#val-fun_l" class="anchor"></a><code><span class="keyword">val </span>fun_l : <a href="../Type/index.html#type-t">Type.t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fun_of_fvars"><a href="#val-fun_of_fvars" class="anchor"></a><code><span class="keyword">val </span>fun_of_fvars : <a href="index.html#type-var">var</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a function from a list of free vars + the body. This performs the De Bruijn transformation, and shifts the body.</p></dd></dl><dl><dt class="spec value" id="val-open_fun"><a href="#val-open_fun" class="anchor"></a><code><span class="keyword">val </span>open_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-open_fun_offset"><a href="#val-open_fun_offset" class="anchor"></a><code><span class="keyword">val </span>open_fun_offset : offset:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a><span class="keyword"> * </span>int</code></dt><dd><p><code>open_fun ~offset (Î»xy. F)</code> returns <code>[v1,v2], F[v1/x,v2/y], offset+2</code> where <code>v1</code> and <code>v2</code> are fresh variables starting from offset</p></dd></dl><dl><dt class="spec value" id="val-grounding"><a href="#val-grounding" class="anchor"></a><code><span class="keyword">val </span>grounding : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>grounding ty</code> is a unique constant of type <code>ty</code></p></dd></dl><dl><dt class="spec value" id="val-is_var"><a href="#val-is_var" class="anchor"></a><code><span class="keyword">val </span>is_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_bvar"><a href="#val-is_bvar" class="anchor"></a><code><span class="keyword">val </span>is_bvar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_app"><a href="#val-is_app" class="anchor"></a><code><span class="keyword">val </span>is_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_const"><a href="#val-is_const" class="anchor"></a><code><span class="keyword">val </span>is_const : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fun"><a href="#val-is_fun" class="anchor"></a><code><span class="keyword">val </span>is_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_type"><a href="#val-is_type" class="anchor"></a><code><span class="keyword">val </span>is_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Does it have type <code>tType</code>?</p></dd></dl><dl><dt class="spec value" id="val-as_const"><a href="#val-as_const" class="anchor"></a><code><span class="keyword">val </span>as_const : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a> option</code></dt><dt class="spec value" id="val-as_const_exn"><a href="#val-as_const_exn" class="anchor"></a><code><span class="keyword">val </span>as_const_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></dt><dt class="spec value" id="val-as_var"><a href="#val-as_var" class="anchor"></a><code><span class="keyword">val </span>as_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> option</code></dt><dt class="spec value" id="val-as_var_exn"><a href="#val-as_var_exn" class="anchor"></a><code><span class="keyword">val </span>as_var_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a></code></dt><dt class="spec value" id="val-as_app"><a href="#val-as_app" class="anchor"></a><code><span class="keyword">val </span>as_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a> list</code></dt><dd><p><code>as_app t</code> decomposes <code>t</code> into a head (non-application) and arguments, such as <code>(let f,l = as_app t in app f l) = t</code></p></dd></dl><dl><dt class="spec value" id="val-as_fun"><a href="#val-as_fun" class="anchor"></a><code><span class="keyword">val </span>as_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Type/index.html#type-t">Type.t</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p>Open functions</p></dd></dl><dl><dt class="spec value" id="val-head_term"><a href="#val-head_term" class="anchor"></a><code><span class="keyword">val </span>head_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>head_term t = fst (as_app t)</code></p></dd></dl><dl><dt class="spec value" id="val-head_term_mono"><a href="#val-head_term_mono" class="anchor"></a><code><span class="keyword">val </span>head_term_mono : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>head term, but still with type arguments</p></dd></dl><dl><dt class="spec value" id="val-args"><a href="#val-args" class="anchor"></a><code><span class="keyword">val </span>args : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p><code>args t = snd (as_app t)</code></p></dd></dl><dl><dt class="spec value" id="val-of_term_unsafe"><a href="#val-of_term_unsafe" class="anchor"></a><code><span class="keyword">val </span>of_term_unsafe : <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><b>NOTE</b>: this can break the invariants and make <a href="index.html#type-view"><code>view</code></a> fail. Only apply with caution.</p></dd></dl><dl><dt class="spec value" id="val-of_term_unsafe_l"><a href="#val-of_term_unsafe_l" class="anchor"></a><code><span class="keyword">val </span>of_term_unsafe_l : <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dt class="spec value" id="val-of_ty"><a href="#val-of_ty" class="anchor"></a><code><span class="keyword">val </span>of_ty : <a href="../Type/index.html#type-t">Type.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Upcast from type</p></dd></dl><div class="spec module" id="module-VarSet"><a href="#module-VarSet" class="anchor"></a><code><span class="keyword">module </span>VarSet : CCSet.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-VarSet">VarSet</a>.elt<span class="keyword"> = </span><a href="index.html#type-var">var</a></code></div><div class="spec module" id="module-VarMap"><a href="#module-VarMap" class="anchor"></a><code><span class="keyword">module </span>VarMap : CCMap.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-VarMap">VarMap</a>.key<span class="keyword"> = </span><a href="index.html#type-var">var</a></code></div><div class="spec module" id="module-VarTbl"><a href="#module-VarTbl" class="anchor"></a><code><span class="keyword">module </span>VarTbl : CCHashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-VarTbl">VarTbl</a>.key<span class="keyword"> = </span><a href="index.html#type-var">var</a></code></div></section><section><header><h3 id="sequences"><a href="#sequences" class="anchor"></a>Sequences</h3></header><div class="spec module" id="module-Seq"><a href="#module-Seq" class="anchor"></a><code><span class="keyword">module </span><a href="Seq/index.html">Seq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-var_occurs"><a href="#val-var_occurs" class="anchor"></a><code><span class="keyword">val </span>var_occurs : var:<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>var_occurs ~var t</code> true iff <code>var</code> in t</p></dd></dl><dl><dt class="spec value" id="val-is_ground"><a href="#val-is_ground" class="anchor"></a><code><span class="keyword">val </span>is_ground : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>var_occurs ~var t</code> true iff <code>var</code> in t</p><p>is the term ground? (no free vars)</p></dd></dl><dl><dt class="spec value" id="val-monomorphic"><a href="#val-monomorphic" class="anchor"></a><code><span class="keyword">val </span>monomorphic : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the term ground? (no free vars)</p><p>true if the term contains no type var</p></dd></dl><dl><dt class="spec value" id="val-max_var"><a href="#val-max_var" class="anchor"></a><code><span class="keyword">val </span>max_var : <a href="index.html#module-VarSet">VarSet</a>.t <span>&#45;&gt;</span> int</code></dt><dd><p>true if the term contains no type var</p><p>find the maximum variable</p></dd></dl><dl><dt class="spec value" id="val-min_var"><a href="#val-min_var" class="anchor"></a><code><span class="keyword">val </span>min_var : <a href="index.html#module-VarSet">VarSet</a>.t <span>&#45;&gt;</span> int</code></dt><dd><p>find the maximum variable</p><p>minimum variable</p></dd></dl><dl><dt class="spec value" id="val-add_vars"><a href="#val-add_vars" class="anchor"></a><code><span class="keyword">val </span>add_vars : unit <a href="index.html#module-VarTbl">VarTbl</a>.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>minimum variable</p><p>add variables of the term to the set</p></dd></dl><dl><dt class="spec value" id="val-vars"><a href="#val-vars" class="anchor"></a><code><span class="keyword">val </span>vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#module-VarSet">VarSet</a>.t</code></dt><dd><p>add variables of the term to the set</p><p>compute variables of the terms</p></dd></dl><dl><dt class="spec value" id="val-vars_prefix_order"><a href="#val-vars_prefix_order" class="anchor"></a><code><span class="keyword">val </span>vars_prefix_order : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a> list</code></dt><dd><p>compute variables of the terms</p><p>variables in prefix traversal order</p></dd></dl><dl><dt class="spec value" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span class="keyword">val </span>depth : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>variables in prefix traversal order</p><p>depth of the term</p></dd></dl><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val </span>head : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a> option</code></dt><dd><p>depth of the term</p><p>head ID.t</p></dd></dl><dl><dt class="spec value" id="val-head_exn"><a href="#val-head_exn" class="anchor"></a><code><span class="keyword">val </span>head_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></dt><dd><p>head ID.t</p><p>head ID.t (or Invalid_argument)</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val </span>size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>head ID.t (or Invalid_argument)</p><p>Size (number of nodes)</p></dd></dl><dl><dt class="spec value" id="val-weight"><a href="#val-weight" class="anchor"></a><code><span class="keyword">val </span>weight : ?&#8288;var:int <span>&#45;&gt;</span> ?&#8288;sym:(<a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compute the weight of a term, given a weight for variables and one for ID.ts.</p><dl><dt>parameter var</dt><dd><p>unique weight for every variable (default 1)</p></dd></dl><dl><dt>parameter sym</dt><dd><p>function from ID.ts to their weight (default <code>const 1</code>)</p></dd></dl><dl><dt>since</dt><dd>0.5.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-ty_vars"><a href="#val-ty_vars" class="anchor"></a><code><span class="keyword">val </span>ty_vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk__Type/index.html#module-VarSet">Logtk.Type.VarSet</a>.t</code></dt><dd><p>Set of free type variables</p></dd></dl><dl><dt class="spec value" id="val-is_ho_var"><a href="#val-is_ho_var" class="anchor"></a><code><span class="keyword">val </span>is_ho_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_ho_app"><a href="#val-is_ho_app" class="anchor"></a><code><span class="keyword">val </span>is_ho_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_app (F t1â€¦tn)</code> is true, when <code>F</code> is a variable (of any function type)</p></dd></dl><dl><dt class="spec value" id="val-as_ho_app"><a href="#val-as_ho_app" class="anchor"></a><code><span class="keyword">val </span>as_ho_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a> list) option</code></dt><dd><p><code>as_ho_app (F t1â€¦tn) = Some (F, [t1â€¦tn])</code></p></dd></dl><dl><dt class="spec value" id="val-is_ho_pred"><a href="#val-is_ho_pred" class="anchor"></a><code><span class="keyword">val </span>is_ho_pred : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_pred (F t1â€¦tn)</code> is true, when <code>F</code> is a predicate variable</p></dd></dl><dl><dt class="spec value" id="val-is_ho_at_root"><a href="#val-is_ho_at_root" class="anchor"></a><code><span class="keyword">val </span>is_ho_at_root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ho_at_root t</code> returns <code>true</code> if the term <code>t</code> is a higher-order variable, possibly applied (i.e. <code>is_ho_var t || is_ho_app t</code>)</p></dd></dl></section><section><header><h3 id="subterms-and-positions"><a href="#subterms-and-positions" class="anchor"></a>Subterms and Positions</h3></header><div class="spec module" id="module-Pos"><a href="#module-Pos" class="anchor"></a><code><span class="keyword">module </span><a href="Pos/index.html">Pos</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val </span>replace : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> old:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> by:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace t ~old ~by</code> syntactically replaces all occurrences of <code>old</code> in <code>t</code> by the term <code>by</code>.</p></dd></dl><dl><dt class="spec value" id="val-replace_m"><a href="#val-replace_m" class="anchor"></a><code><span class="keyword">val </span>replace_m : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="index.html#module-Map">Map</a>.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replace t m</code> syntactically replaces all occurrences of bindings of the map in <code>t</code>, starting from the root</p></dd></dl></section><section><header><h3 id="high-level-operations"><a href="#high-level-operations" class="anchor"></a>High-level operations</h3></header><dl><dt class="spec value" id="val-symbols"><a href="#val-symbols" class="anchor"></a><code><span class="keyword">val </span>symbols : ?&#8288;init:<a href="../../Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Logtk__ID/index.html#module-Set">Logtk.ID.Set</a>.t</code></dt><dd><p>Symbols of the term (keys of signature)</p></dd></dl><dl><dt class="spec value" id="val-contains_symbol"><a href="#val-contains_symbol" class="anchor"></a><code><span class="keyword">val </span>contains_symbol : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Does the term contain this given ID.t?</p></dd></dl></section><section><header><h3 id="fold"><a href="#fold" class="anchor"></a>Fold</h3></header><aside><p>High level fold-like combinators</p></aside><dl><dt class="spec value" id="val-all_positions"><a href="#val-all_positions" class="anchor"></a><code><span class="keyword">val </span>all_positions : ?&#8288;vars:bool <span>&#45;&gt;</span> ?&#8288;ty_args:bool <span>&#45;&gt;</span> ?&#8288;pos:<a href="../Position/index.html#type-t">Position.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../Position/With/index.html#type-t">Position.With.t</a> Sequence.t</code></dt><dd><p>Iterate on all sub-terms with their position.</p><dl><dt>parameter vars</dt><dd><p>specifies whether variables are folded on (default false).</p></dd></dl><dl><dt>parameter ty_args</dt><dd><p>specifies whether type arguments are folded on (default true).</p></dd></dl><dl><dt>parameter pos</dt><dd><p>the initial position (default empty)</p></dd></dl></dd></dl></section><section><header><h3 id="some-ac-utils"><a href="#some-ac-utils" class="anchor"></a>Some AC-utils</h3></header><div class="spec module-type" id="module-type-AC_SPEC"><a href="#module-type-AC_SPEC" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-AC_SPEC/index.html">AC_SPEC</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-AC"><a href="#module-AC" class="anchor"></a><code><span class="keyword">module </span><a href="AC/index.html">AC</a> : <span class="keyword">functor</span> (<a href="AC/argument-1-A/index.html">A</a> : <a href="index.html#module-type-AC_SPEC">AC_SPEC</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="printing/parsing"><a href="#printing/parsing" class="anchor"></a>Printing/parsing</h3></header><dl><dt class="spec value" id="val-print_all_types"><a href="#val-print_all_types" class="anchor"></a><code><span class="keyword">val </span>print_all_types : bool Pervasives.ref</code></dt><dd><p>If true, <a href="index.html#val-pp"><code>pp</code></a> will print the types of all annotated terms</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Interfaces/index.html#module-type-PRINT">Interfaces.PRINT</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Interfaces/module-type-PRINT/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> CCFormat.printer</code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Interfaces/index.html#module-type-PRINT_DE_BRUIJN">Interfaces.PRINT_DE_BRUIJN</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-t">t</a> := <a href="index.html#type-t">t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-term">term</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type </span>term</code></dt><dt class="spec type" id="type-print_hook"><a href="#type-print_hook" class="anchor"></a><code><span class="keyword">type </span>print_hook</code><code><span class="keyword"> = </span>int <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> CCFormat.printer <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>User-provided hook that can be used to print terms (for composite cases) before the default printing occurs. The int argument is the De Bruijn depth in the term. A hook takes as arguments the depth and the recursive printing function that it can use to print subterms. A hook should return <code>true</code> if it fired, <code>false</code> to fall back on the default printing.</p></dd></dl><dl><dt class="spec value" id="val-pp_depth"><a href="#val-pp_depth" class="anchor"></a><code><span class="keyword">val </span>pp_depth : ?&#8288;hooks:<a href="index.html#type-print_hook">print_hook</a> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> CCFormat.printer</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pp_var"><a href="#val-pp_var" class="anchor"></a><code><span class="keyword">val </span>pp_var : <a href="../Type/index.html#type-t">Type.t</a> <a href="../HVar/index.html#type-t">HVar.t</a> CCFormat.printer</code></dt><dt class="spec value" id="val-add_hook"><a href="#val-add_hook" class="anchor"></a><code><span class="keyword">val </span>add_hook : <a href="index.html#type-print_hook">print_hook</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Hook used by default for printing</p></dd></dl><dl><dt class="spec value" id="val-default_hooks"><a href="#val-default_hooks" class="anchor"></a><code><span class="keyword">val </span>default_hooks : unit <span>&#45;&gt;</span> <a href="index.html#type-print_hook">print_hook</a> list</code></dt><dd><p>List of default hooks</p></dd></dl><dl><dt class="spec value" id="val-debugf"><a href="#val-debugf" class="anchor"></a><code><span class="keyword">val </span>debugf : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>debugf printing, with sorts</p></dd></dl></section><section><header><h3 id="formulas"><a href="#formulas" class="anchor"></a>Formulas</h3></header><div class="spec module" id="module-Form"><a href="#module-Form" class="anchor"></a><code><span class="keyword">module </span><a href="Form/index.html">Form</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="arith"><a href="#arith" class="anchor"></a>Arith</h3></header><div class="spec module" id="module-Arith"><a href="#module-Arith" class="anchor"></a><code><span class="keyword">module </span><a href="Arith/index.html">Arith</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-DB"><a href="#module-DB" class="anchor"></a><code><span class="keyword">module </span><a href="DB/index.html">DB</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h3 id="tptp"><a href="#tptp" class="anchor"></a>TPTP</h3></header><div class="spec module" id="module-TPTP"><a href="#module-TPTP" class="anchor"></a><code><span class="keyword">module </span><a href="TPTP/index.html">TPTP</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-ZF"><a href="#module-ZF" class="anchor"></a><code><span class="keyword">module </span><a href="ZF/index.html">ZF</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_in"><a href="#val-pp_in" class="anchor"></a><code><span class="keyword">val </span>pp_in : <a href="../Output_format/index.html#type-t">Output_format.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> CCFormat.printer</code></dt></dl><div class="spec module" id="module-Conv"><a href="#module-Conv" class="anchor"></a><code><span class="keyword">module </span><a href="Conv/index.html">Conv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></div></body></html>