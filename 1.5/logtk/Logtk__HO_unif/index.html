<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logtk__HO_unif (logtk.Logtk__HO_unif)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">logtk</a> &#x00BB; Logtk__HO_unif</nav><h1>Module <code>Logtk__HO_unif</code></h1><h2 id="higher-order-unification"><a href="#higher-order-unification" class="anchor"></a>Higher-Order Unification</h2></header><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type </span>term</code><code><span class="keyword"> = </span><a href="../Logtk/Term/index.html#type-t">Logtk.Term.t</a></code></dt><dt class="spec type" id="type-penalty"><a href="#type-penalty" class="anchor"></a><code><span class="keyword">type </span>penalty</code><code><span class="keyword"> = </span>int</code></dt><dd><p>penalty on the search space</p></dd></dl><dl><dt class="spec value" id="val-enum_prop"><a href="#val-enum_prop" class="anchor"></a><code><span class="keyword">val </span>enum_prop : ?&#8288;mode:[ `Full<span class="keyword"> | </span>`Neg<span class="keyword"> | </span>`None ] <span>&#45;&gt;</span> <a href="../Logtk/Term/index.html#type-var">Logtk.Term.var</a> <a href="../Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a> <span>&#45;&gt;</span> offset:int <span>&#45;&gt;</span> (<a href="../Logtk/Subst/index.html#type-t">Logtk.Subst.t</a><span class="keyword"> * </span><a href="index.html#type-penalty">penalty</a>) list</code></dt><dd><p>Given a variable of type <code>τ1…τn -&gt; prop</code>, enumerate possible shapes for it</p><dl><dt>parameter v</dt><dd><p>the variable to refine + its scope. Must return <code>prop</code>.</p></dd></dl><dl><dt>parameter offset</dt><dd><p>to create fresh variables (should be unused elsewhere)</p></dd></dl><dl><dt>parameter mode</dt><dd><p>if <code>`Neg</code>, only tries negation; <code>`None</code>, do nothing; otherwise do all connectives</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-pair"><a href="#type-pair" class="anchor"></a><code><span class="keyword">type </span>pair</code><code><span class="keyword"> = </span><a href="../Logtk/Type/index.html#type-t">Logtk.Type.t</a> list<span class="keyword"> * </span><a href="index.html#type-term">term</a><span class="keyword"> * </span><a href="index.html#type-term">term</a></code></dt><dd><p>unification pair</p></dd></dl><dl><dt class="spec value" id="val-pp_pair"><a href="#val-pp_pair" class="anchor"></a><code><span class="keyword">val </span>pp_pair : <a href="index.html#type-pair">pair</a> CCFormat.printer</code></dt><dt class="spec value" id="val-unif_pairs"><a href="#val-unif_pairs" class="anchor"></a><code><span class="keyword">val </span>unif_pairs : ?&#8288;fuel:int <span>&#45;&gt;</span> <a href="index.html#type-pair">pair</a> list <a href="../Logtk/Scoped/index.html#type-t">Logtk.Scoped.t</a> <span>&#45;&gt;</span> offset:int <span>&#45;&gt;</span> (<a href="index.html#type-pair">pair</a> list<span class="keyword"> * </span><a href="../Logtk/Unif_subst/index.html#type-t">Logtk.Unif_subst.t</a><span class="keyword"> * </span><a href="index.html#type-penalty">penalty</a><span class="keyword"> * </span><a href="../Logtk/Subst/Renaming/index.html#type-t">Logtk.Subst.Renaming.t</a>) list</code></dt><dd><p><code>unif_pairs pairs ~scope_new_vars</code> returns a list of (partial) solutions to the HO unification problem <code>pairs</code>. Each solution is a list of remaining constraints (with the substitution already applied), a substitution, some penalty to influence the search space, and a renaming used for the substitution</p></dd></dl><dl><dt class="spec value" id="val-default_fuel"><a href="#val-default_fuel" class="anchor"></a><code><span class="keyword">val </span>default_fuel : int Pervasives.ref</code></dt><dd><p>Default amount of fuel for <a href="index.html#val-unif_pairs"><code>unif_pairs</code></a></p></dd></dl><dl><dt class="spec value" id="val-enable_norm_subst"><a href="#val-enable_norm_subst" class="anchor"></a><code><span class="keyword">val </span>enable_norm_subst : bool Pervasives.ref</code></dt><dd><p>If true, substitutions obtained with <a href="index.html#val-unif_pairs"><code>unif_pairs</code></a> are normalized and β-reduced</p></dd></dl></div></body></html>