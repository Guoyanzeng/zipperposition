<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logtk__TypeInference (logtk.Logtk__TypeInference)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">logtk</a> &#x00BB; Logtk__TypeInference</nav><h1>Module <code>Logtk__TypeInference</code></h1><h2 id="type-inference"><a href="#type-inference" class="anchor"></a>Type Inference</h2><p>This module is used for two things that overlap:</p><ul><li>inferring the types of symbols that have not been declared (e.g. in &quot;fof&quot; or &quot;cnf&quot; TPTP statements) so as to enrich a <code>Signature</code></li><li>converting <i>untyped</i> terms or formulas into <i>typed</i> formulas, by inferring the exact type of each subterm (and possibly inferring type parameters).</li></ul><p>In this context, <b>generalizing</b> type variables means that if some ID.t whose type was unknown and its type still contains variables after the type inference, those variables are quantified instead of being bound to a default type (typically <code>.Type.i</code>).</p><p>For instance: say <code>f</code> is not declared and occurs in the term <code>f(f(nil))</code> with the declared constructor <code>nil : list(A)</code>. The inferred type for <code>f</code> should be something like <code>list(B) -&gt; list(B)</code>.</p><ul><li>If we generalize, we declare that <code>f : list(A) -&gt; list(A)</code> (for all <code>A</code>).</li><li>If we don't, we declare that <code>f : list($i) -&gt; list($i)</code>.</li></ul><p>Here we use a single scope when we unify and substitute type variables, the scope 0.</p><p>Many functions will use an Error monad to make errors explicit. The error type is <a href="index.html#type-or_error"><code>or_error</code></a>. The module <code>CCError</code> in containers can be used to deal with errors (including monadic operators).</p><nav class="toc"><ul><li><a href="#types-for-builtins">Types for Builtins</a></li><li><a href="#typing-context">Typing context</a></li><li><a href="#hindley-milner-type-inference">Hindley-Milner Type Inference</a><ul><li><a href="#constraining-types">Constraining types</a></li></ul></li><li><a href="#statements">Statements</a></li></ul></nav></header><dl><dt class="spec type" id="type-or_error"><a href="#type-or_error" class="anchor"></a><code><span class="keyword">type </span>'a or_error</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, string) CCResult.t</code></dt><dt class="spec type" id="type-type_"><a href="#type-type_" class="anchor"></a><code><span class="keyword">type </span>type_</code><code><span class="keyword"> = </span><a href="../Logtk/TypedSTerm/index.html#type-t">Logtk.TypedSTerm.t</a></code></dt><dt class="spec type" id="type-untyped"><a href="#type-untyped" class="anchor"></a><code><span class="keyword">type </span>untyped</code><code><span class="keyword"> = </span><a href="../Logtk/STerm/index.html#type-t">Logtk.STerm.t</a></code></dt><dd><p>untyped term</p></dd></dl><dl><dt class="spec type" id="type-typed"><a href="#type-typed" class="anchor"></a><code><span class="keyword">type </span>typed</code><code><span class="keyword"> = </span><a href="../Logtk/TypedSTerm/index.html#type-t">Logtk.TypedSTerm.t</a></code></dt><dd><p>untyped term</p><p>typed term</p></dd></dl><dl><dt class="spec type" id="type-loc"><a href="#type-loc" class="anchor"></a><code><span class="keyword">type </span>loc</code><code><span class="keyword"> = </span><a href="../Logtk/ParseLocation/index.html#type-t">Logtk.ParseLocation.t</a></code></dt><dd><p>typed term</p></dd></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Error</span><span class="keyword"> of </span>string</code></dt></dl><dl><dt class="spec value" id="val-section"><a href="#val-section" class="anchor"></a><code><span class="keyword">val </span>section : <a href="../Logtk/Util/Section/index.html#type-t">Logtk.Util.Section.t</a></code></dt></dl><section><header><h3 id="types-for-builtins"><a href="#types-for-builtins" class="anchor"></a>Types for Builtins</h3></header><div class="spec module" id="module-TyBuiltin"><a href="#module-TyBuiltin" class="anchor"></a><code><span class="keyword">module </span><a href="TyBuiltin/index.html">TyBuiltin</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="typing-context"><a href="#typing-context" class="anchor"></a>Typing context</h3><p>This module provides a typing context, with an applicative interface. The context is used to map terms to types locally during type inference. It also keeps and updates a signature when symbols' types are inferred.</p><p>This module is quite low-level, and shouldn't be used in simple cases (see the following modules)</p></header><div class="spec module" id="module-Ctx"><a href="#module-Ctx" class="anchor"></a><code><span class="keyword">module </span><a href="Ctx/index.html">Ctx</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val </span>unify : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h3 id="hindley-milner-type-inference"><a href="#hindley-milner-type-inference" class="anchor"></a>Hindley-Milner Type Inference</h3><p>This module, abstract in the exact kind of term it types, takes as input a signature and an <b>untyped term</b>, and updates the typing context so that the <b>untyped term</b> can be converted into a <b>typed term</b>.</p></header><dl><dt class="spec value" id="val-infer_ty_exn"><a href="#val-infer_ty_exn" class="anchor"></a><code><span class="keyword">val </span>infer_ty_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a></code></dt><dd><p>Type conversion from <a href="index.html#type-untyped"><code>untyped</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-infer_ty"><a href="#val-infer_ty" class="anchor"></a><code><span class="keyword">val </span>infer_ty : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Type conversion from <a href="index.html#type-untyped"><code>untyped</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-infer_exn"><a href="#val-infer_exn" class="anchor"></a><code><span class="keyword">val </span>infer_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a></code></dt><dd><p>Infer the type of this term under the given signature. This updates the context's typing environment!</p><dl><dt>parameter ctx</dt><dd><p>the context</p></dd></dl><dl><dt>parameter untyped</dt><dd><p>the untyped term whose type must be inferred</p></dd></dl><dl><dt>raises Error</dt><dd><p>if the types are inconsistent</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-infer"><a href="#val-infer" class="anchor"></a><code><span class="keyword">val </span>infer : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a> <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Safe version of <a href="index.html#val-infer_exn"><code>infer_exn</code></a>. It returns <code>`Error s</code> rather than raising <a href="index.html#exception-Error"><code>Error</code></a> if the typechecking fails.</p></dd></dl><dl><dt class="spec value" id="val-infer_prop_exn"><a href="#val-infer_prop_exn" class="anchor"></a><code><span class="keyword">val </span>infer_prop_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a></code></dt><dd><p>Same as <a href="index.html#val-infer_exn"><code>infer_exn</code></a> but forces the type of its result to be <span class="xref-unresolved" title="unresolved reference to &quot;TypedSTerm.prop&quot;"><code>TypedSTerm</code>.prop</span></p></dd></dl><dl><dt class="spec value" id="val-infer_clause_exn"><a href="#val-infer_clause_exn" class="anchor"></a><code><span class="keyword">val </span>infer_clause_exn : <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> list <span>&#45;&gt;</span> <a href="index.html#type-typed">typed</a> list</code></dt><dd><p>Convert a clause. Free variables in each of the list's elements are shared</p></dd></dl><section><header><h4 id="constraining-types"><a href="#constraining-types" class="anchor"></a>Constraining types</h4><p>This section is mostly useful for inferring a signature without converting untyped_terms into typed_terms.</p></header><dl><dt class="spec value" id="val-constrain_term_term_exn"><a href="#val-constrain_term_term_exn" class="anchor"></a><code><span class="keyword">val </span>constrain_term_term_exn : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Force the two terms to have the same type in this context</p><dl><dt>raises Error</dt><dd><p>if an inconsistency is detected</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-constrain_term_type_exn"><a href="#val-constrain_term_type_exn" class="anchor"></a><code><span class="keyword">val </span>constrain_term_type_exn : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Force the term's type and the given type to be the same.</p><dl><dt>raises Error</dt><dd><p>if an inconsistency is detected</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-constrain_term_term"><a href="#val-constrain_term_term" class="anchor"></a><code><span class="keyword">val </span>constrain_term_term : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> unit <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Safe version of <a href="index.html#val-constrain_term_term_exn"><code>constrain_term_term_exn</code></a></p></dd></dl><dl><dt class="spec value" id="val-constrain_term_type"><a href="#val-constrain_term_type" class="anchor"></a><code><span class="keyword">val </span>constrain_term_type : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-untyped">untyped</a> <span>&#45;&gt;</span> <a href="index.html#type-type_">type_</a> <span>&#45;&gt;</span> unit <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Safe version of <a href="index.html#val-constrain_term_type_exn"><code>constrain_term_type_exn</code></a></p></dd></dl></section></section><section><header><h3 id="statements"><a href="#statements" class="anchor"></a>Statements</h3></header><dl><dt class="spec type" id="type-typed_statement"><a href="#type-typed_statement" class="anchor"></a><code><span class="keyword">type </span>typed_statement</code><code><span class="keyword"> = </span>(<a href="index.html#type-typed">typed</a>, <a href="index.html#type-typed">typed</a>, <a href="index.html#type-type_">type_</a>) <a href="../Logtk/Statement/index.html#type-t">Logtk.Statement.t</a></code></dt></dl><dl><dt class="spec value" id="val-infer_statement_exn"><a href="#val-infer_statement_exn" class="anchor"></a><code><span class="keyword">val </span>infer_statement_exn : ?&#8288;file:string <span>&#45;&gt;</span> <a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> <a href="../Logtk/UntypedAST/index.html#type-statement">Logtk.UntypedAST.statement</a> <span>&#45;&gt;</span> <a href="index.html#type-typed_statement">typed_statement</a><span class="keyword"> * </span><a href="index.html#type-typed_statement">typed_statement</a> list</code></dt><dd><p><code>infer_statement ctx ~f st</code> checks and convert <code>st</code> into a typed statements, and a list of auxiliary type declarations for symbols that were inferred implicitely.</p></dd></dl><dl><dt class="spec value" id="val-infer_statements_exn"><a href="#val-infer_statements_exn" class="anchor"></a><code><span class="keyword">val </span>infer_statements_exn : ?&#8288;def_as_rewrite:bool <span>&#45;&gt;</span> ?&#8288;on_var:[ `Infer<span class="keyword"> | </span>`Default ] <span>&#45;&gt;</span> ?&#8288;on_undef:[ `Warn<span class="keyword"> | </span>`Fail<span class="keyword"> | </span>`Guess ] <span>&#45;&gt;</span> ?&#8288;on_shadow:[ `Warn<span class="keyword"> | </span>`Ignore ] <span>&#45;&gt;</span> ?&#8288;ctx:<a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> ?&#8288;file:string <span>&#45;&gt;</span> implicit_ty_args:bool <span>&#45;&gt;</span> <a href="../Logtk/UntypedAST/index.html#type-statement">Logtk.UntypedAST.statement</a> Sequence.t <span>&#45;&gt;</span> <a href="index.html#type-typed_statement">typed_statement</a> CCVector.ro_vector</code></dt><dd><p>Infer all statements</p><dl><dt>parameter def_as_rewrite</dt><dd><p>if true, definitions becomes rewrite rules</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-infer_statements"><a href="#val-infer_statements" class="anchor"></a><code><span class="keyword">val </span>infer_statements : ?&#8288;def_as_rewrite:bool <span>&#45;&gt;</span> ?&#8288;on_var:[ `Infer<span class="keyword"> | </span>`Default ] <span>&#45;&gt;</span> ?&#8288;on_undef:[ `Warn<span class="keyword"> | </span>`Fail<span class="keyword"> | </span>`Guess ] <span>&#45;&gt;</span> ?&#8288;on_shadow:[ `Warn<span class="keyword"> | </span>`Ignore ] <span>&#45;&gt;</span> ?&#8288;ctx:<a href="Ctx/index.html#type-t">Ctx.t</a> <span>&#45;&gt;</span> ?&#8288;file:string <span>&#45;&gt;</span> implicit_ty_args:bool <span>&#45;&gt;</span> <a href="../Logtk/UntypedAST/index.html#type-statement">Logtk.UntypedAST.statement</a> Sequence.t <span>&#45;&gt;</span> <a href="index.html#type-typed_statement">typed_statement</a> CCVector.ro_vector <a href="index.html#type-or_error">or_error</a></code></dt></dl></section></div></body></html>