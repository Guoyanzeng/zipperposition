val term : type.
data tree := empty | node tree term tree.
val rev : tree -> tree.
data nat := z | s nat.
val size : tree -> nat.
val subtree : tree -> tree -> prop.
val mem : term -> tree -> prop.
assert (rev empty) = empty.
assert
  forall (L:tree).
    (forall (R:tree).
       (forall (X:term). ((rev (node L X R)) = (node (rev R) X (rev L))))).
assert (size empty) = z.
val plus : nat -> nat -> nat.
assert
  forall (L:tree).
    (forall (R:tree).
       (forall (X:term).
          ((size (node L X R)) = (plus (s z) (plus (size L) (size R)))))).
assert forall (T:tree). (subtree T T).
assert
  forall (T:tree).
    (forall (X:term).
       (forall (L:tree).
          (forall (R:tree). ((subtree T L) => (subtree T (node L X R)))))).
assert
  forall (T:tree).
    (forall (X:term).
       (forall (L:tree).
          (forall (R:tree). ((subtree T R) => (subtree T (node L X R)))))).
assert forall (X:term). (~ (mem X empty)).
assert
  forall (X:term).
    (forall (Y:term).
       (forall (L:tree).
          (forall (R:tree).
             (((mem X R) || (mem X L)) => (mem X (node L Y R)))))).
assert
  forall (X:term). (forall (L:tree). (forall (R:tree). (mem X (node L X R)))).
val q : term -> prop.
assert forall (X:term). (q X).
val p : tree -> prop.
assert
  forall (X:tree).
    (forall (Y:tree).
       (forall (Z:term). (((q Z) && (p X) && (p Y)) => (p (node X Z Y))))).
assert p empty.
goal forall (X:tree). (p X).
