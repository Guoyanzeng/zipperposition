<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>1-E (libzipperposition.Libzipperposition.Saturate.Make.1-E)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">libzipperposition</a> &#x00BB; <a href="../../../index.html">Libzipperposition</a> &#x00BB; <a href="../../index.html">Saturate</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; 1-E</nav><h1>Parameter <code>Make.1-E</code></h1><nav class="toc"><ul><li><a href="#modify-the-env">Modify the Env</a></li><li><a href="#use-the-env">Use the Env</a></li><li><a href="#high-level-operations">High level operations</a></li><li><a href="#misc">Misc</a></li></ul></nav></header><div class="spec module" id="module-Ctx"><a href="#module-Ctx" class="anchor"></a><code><span class="keyword">module</span> <a href="Ctx/index.html">Ctx</a> : <a href="../../../Ctx/index.html#module-type-S">Ctx.S</a></code></div><div class="spec module" id="module-C"><a href="#module-C" class="anchor"></a><code><span class="keyword">module</span> <a href="C/index.html">C</a> : <a href="../../../Clause/index.html#module-type-S">Clause.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../Clause/module-type-S/Ctx/index.html">Ctx</a> = <a href="index.html#module-Ctx">Ctx</a></code></div><div class="spec module" id="module-ProofState"><a href="#module-ProofState" class="anchor"></a><code><span class="keyword">module</span> <a href="ProofState/index.html">ProofState</a> : <a href="../../../ProofState/index.html#module-type-S">ProofState.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../ProofState/module-type-S/C/index.html">C</a> = <a href="index.html#module-C">C</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="../../../ProofState/module-type-S/Ctx/index.html">Ctx</a> = <a href="index.html#module-Ctx">Ctx</a></code></div><dl><dt class="spec type" id="type-inf_rule"><a href="#type-inf_rule" class="anchor"></a><code><span class="keyword">type</span> inf_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> list</span></code></dt><dd><p>An inference returns a list of conclusions</p></dd></dl><dl><dt class="spec type" id="type-generate_rule"><a href="#type-generate_rule" class="anchor"></a><code><span class="keyword">type</span> generate_rule</code><code> = <span>full:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> list</span></code></dt><dd><p>Generation of clauses regardless of current clause.</p><dl><dt>parameter full</dt><dd><p>if true, perform more thorough checks</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-clause_elim_rule"><a href="#type-clause_elim_rule" class="anchor"></a><code><span class="keyword">type</span> clause_elim_rule</code><code> = unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Eliminates clauses from the proof state using algorithms like blocked clause elimination and similar</p></dd></dl><dl><dt class="spec type" id="type-binary_inf_rule"><a href="#type-binary_inf_rule" class="anchor"></a><code><span class="keyword">type</span> binary_inf_rule</code><code> = <a href="index.html#type-inf_rule">inf_rule</a></code></dt><dt class="spec type" id="type-unary_inf_rule"><a href="#type-unary_inf_rule" class="anchor"></a><code><span class="keyword">type</span> unary_inf_rule</code><code> = <a href="index.html#type-inf_rule">inf_rule</a></code></dt><dt class="spec type" id="type-simplify_rule"><a href="#type-simplify_rule" class="anchor"></a><code><span class="keyword">type</span> simplify_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> <a href="../../../SimplM/index.html#type-t">SimplM.t</a></span></code></dt><dd><p>Simplify the clause structurally (basic simplifications), in the simplification monad. <code>(c, `Same)</code> means the clause has not been simplified; <code>(c, `New)</code> means the clause has been simplified at least once</p></dd></dl><dl><dt class="spec type" id="type-active_simplify_rule"><a href="#type-active_simplify_rule" class="anchor"></a><code><span class="keyword">type</span> active_simplify_rule</code><code> = <a href="index.html#type-simplify_rule">simplify_rule</a></code></dt><dt class="spec type" id="type-rw_simplify_rule"><a href="#type-rw_simplify_rule" class="anchor"></a><code><span class="keyword">type</span> rw_simplify_rule</code><code> = <a href="index.html#type-simplify_rule">simplify_rule</a></code></dt><dt class="spec type" id="type-backward_simplify_rule"><a href="#type-backward_simplify_rule" class="anchor"></a><code><span class="keyword">type</span> backward_simplify_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t</code></dt><dd><p>backward simplification by a unit clause. It returns a set of active clauses that can potentially be simplified by the given clause. <code>backward_simplify c</code> therefore returns a subset of <code>ProofState.ActiveSet.clauses ()</code></p></dd></dl><dl><dt class="spec type" id="type-redundant_rule"><a href="#type-redundant_rule" class="anchor"></a><code><span class="keyword">type</span> redundant_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>check whether the clause is redundant w.r.t the set</p></dd></dl><dl><dt class="spec type" id="type-backward_redundant_rule"><a href="#type-backward_redundant_rule" class="anchor"></a><code><span class="keyword">type</span> backward_redundant_rule</code><code> = <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t <span>&#45;&gt;</span> <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t</code></dt><dd><p>find redundant clauses in <code>ProofState.ActiveSet</code> w.r.t the clause. first param is the set of already known redundant clause, the rule should add clauses to it</p></dd></dl><dl><dt class="spec type" id="type-immediate_simplification_rule"><a href="#type-immediate_simplification_rule" class="anchor"></a><code><span class="keyword">type</span> immediate_simplification_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> Iter.t</span> option</span></code></dt><dd><p>Following Kotelnikov's iProver superposition implementation, try to simplify given clause (first argument) using a set of clauses (second argument). If simplification suceeded, then a set of clauses to be injected into passive set is returned.</p></dd></dl><dl><dt class="spec type" id="type-is_trivial_trail_rule"><a href="#type-is_trivial_trail_rule" class="anchor"></a><code><span class="keyword">type</span> is_trivial_trail_rule</code><code> = <a href="../../../Trail/index.html#type-t">Trail.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Rule that checks whether the trail is trivial (a tautology)</p></dd></dl><dl><dt class="spec type" id="type-is_trivial_rule"><a href="#type-is_trivial_rule" class="anchor"></a><code><span class="keyword">type</span> is_trivial_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Rule that checks whether the clause is trivial (a tautology)</p></dd></dl><dl><dt class="spec type" id="type-term_rewrite_rule"><a href="#type-term_rewrite_rule" class="anchor"></a><code><span class="keyword">type</span> term_rewrite_rule</code><code> = <a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> * <span><a href="../../../../../logtk/Logtk/Proof/index.html#type-parent">Logtk.Proof.parent</a> list</span>)</span> option</span></code></dt><dd><p>Rewrite rule on terms</p></dd></dl><dl><dt class="spec type" id="type-term_norm_rule"><a href="#type-term_norm_rule" class="anchor"></a><code><span class="keyword">type</span> term_norm_rule</code><code> = <a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> <span>&#45;&gt;</span> <span><a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a> option</span></code></dt><dd><p>Normalization rule on terms</p></dd></dl><dl><dt class="spec type" id="type-lit_rewrite_rule"><a href="#type-lit_rewrite_rule" class="anchor"></a><code><span class="keyword">type</span> lit_rewrite_rule</code><code> = <a href="../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../../../../logtk/Logtk/Literal/index.html#type-t">Logtk.Literal.t</a> * <span><a href="../../../../../logtk/Logtk/Proof/index.html#type-parent">Logtk.Proof.parent</a> list</span> * <span><a href="../../../../../logtk/Logtk/Proof/index.html#type-tag">Logtk.Proof.tag</a> list</span>)</span> option</span></code></dt><dd><p>Rewrite rule on literals</p></dd></dl><dl><dt class="spec type" id="type-multi_simpl_rule"><a href="#type-multi_simpl_rule" class="anchor"></a><code><span class="keyword">type</span> multi_simpl_rule</code><code> = <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> option</span></code></dt><dd><p>(maybe) rewrite a clause to a set of clauses. Must return <code>None</code> if the clause is unmodified</p></dd></dl><dl><dt class="spec type" id="type-conversion_result"><a href="#type-conversion_result" class="anchor"></a><code><span class="keyword">type</span> <span>'a conversion_result</span></code><code> = </code><table class="variant"><tr id="type-conversion_result.CR_skip" class="anchored"><td class="def constructor"><a href="#type-conversion_result.CR_skip" class="anchor"></a><code>| </code><code><span class="constructor">CR_skip</span></code></td><td class="doc"><p>rule didn't fire</p></td></tr><tr id="type-conversion_result.CR_drop" class="anchored"><td class="def constructor"><a href="#type-conversion_result.CR_drop" class="anchor"></a><code>| </code><code><span class="constructor">CR_drop</span></code></td><td class="doc"><p>drop the clause from the proof state</p></td></tr><tr id="type-conversion_result.CR_add" class="anchored"><td class="def constructor"><a href="#type-conversion_result.CR_add" class="anchor"></a><code>| </code><code><span class="constructor">CR_add</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td><td class="doc"><p>add this to the result</p></td></tr><tr id="type-conversion_result.CR_return" class="anchored"><td class="def constructor"><a href="#type-conversion_result.CR_return" class="anchor"></a><code>| </code><code><span class="constructor">CR_return</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td><td class="doc"><p>shortcut the remaining rules, return this</p></td></tr></table></dt><dt class="spec type" id="type-clause_conversion_rule"><a href="#type-clause_conversion_rule" class="anchor"></a><code><span class="keyword">type</span> clause_conversion_rule</code><code> = <a href="../../../../../logtk/Logtk/Statement/index.html#type-clause_t">Logtk.Statement.clause_t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> <a href="index.html#type-conversion_result">conversion_result</a></span></code></dt><dd><p>A hook to convert a particular statement into a list of clauses</p></dd></dl><section><header><h3 id="modify-the-env"><a href="#modify-the-env" class="anchor"></a>Modify the Env</h3></header><dl><dt class="spec value" id="val-add_passive"><a href="#val-add_passive" class="anchor"></a><code><span class="keyword">val</span> add_passive : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add passive clauses</p></dd></dl><dl><dt class="spec value" id="val-add_active"><a href="#val-add_active" class="anchor"></a><code><span class="keyword">val</span> add_active : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add active clauses</p></dd></dl><dl><dt class="spec value" id="val-add_simpl"><a href="#val-add_simpl" class="anchor"></a><code><span class="keyword">val</span> add_simpl : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add simplification clauses</p></dd></dl><dl><dt class="spec value" id="val-remove_passive"><a href="#val-remove_passive" class="anchor"></a><code><span class="keyword">val</span> remove_passive : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove passive clauses</p></dd></dl><dl><dt class="spec value" id="val-remove_active"><a href="#val-remove_active" class="anchor"></a><code><span class="keyword">val</span> remove_active : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove active clauses</p></dd></dl><dl><dt class="spec value" id="val-remove_simpl"><a href="#val-remove_simpl" class="anchor"></a><code><span class="keyword">val</span> remove_simpl : <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove simplification clauses</p></dd></dl><dl><dt class="spec value" id="val-get_passive"><a href="#val-get_passive" class="anchor"></a><code><span class="keyword">val</span> get_passive : unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>Passive clauses</p></dd></dl><dl><dt class="spec value" id="val-get_active"><a href="#val-get_active" class="anchor"></a><code><span class="keyword">val</span> get_active : unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>Active clauses</p></dd></dl><dl><dt class="spec value" id="val-add_binary_inf"><a href="#val-add_binary_inf" class="anchor"></a><code><span class="keyword">val</span> add_binary_inf : string <span>&#45;&gt;</span> <a href="index.html#type-binary_inf_rule">binary_inf_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a binary inference rule</p></dd></dl><dl><dt class="spec value" id="val-add_unary_inf"><a href="#val-add_unary_inf" class="anchor"></a><code><span class="keyword">val</span> add_unary_inf : string <span>&#45;&gt;</span> <a href="index.html#type-unary_inf_rule">unary_inf_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a unary inference rule</p></dd></dl><dl><dt class="spec value" id="val-add_rw_simplify"><a href="#val-add_rw_simplify" class="anchor"></a><code><span class="keyword">val</span> add_rw_simplify : <a href="index.html#type-rw_simplify_rule">rw_simplify_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add forward rewriting rule</p></dd></dl><dl><dt class="spec value" id="val-add_active_simplify"><a href="#val-add_active_simplify" class="anchor"></a><code><span class="keyword">val</span> add_active_simplify : <a href="index.html#type-active_simplify_rule">active_simplify_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add simplification w.r.t active set</p></dd></dl><dl><dt class="spec value" id="val-add_backward_simplify"><a href="#val-add_backward_simplify" class="anchor"></a><code><span class="keyword">val</span> add_backward_simplify : <a href="index.html#type-backward_simplify_rule">backward_simplify_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add simplification of the active set</p></dd></dl><dl><dt class="spec value" id="val-add_redundant"><a href="#val-add_redundant" class="anchor"></a><code><span class="keyword">val</span> add_redundant : <a href="index.html#type-redundant_rule">redundant_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add redundancy criterion w.r.t. the active set</p></dd></dl><dl><dt class="spec value" id="val-add_backward_redundant"><a href="#val-add_backward_redundant" class="anchor"></a><code><span class="keyword">val</span> add_backward_redundant : <a href="index.html#type-backward_redundant_rule">backward_redundant_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add rule that finds redundant clauses within active set</p></dd></dl><dl><dt class="spec value" id="val-add_basic_simplify"><a href="#val-add_basic_simplify" class="anchor"></a><code><span class="keyword">val</span> add_basic_simplify : <a href="index.html#type-simplify_rule">simplify_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add basic simplification rule</p></dd></dl><dl><dt class="spec value" id="val-add_unary_simplify"><a href="#val-add_unary_simplify" class="anchor"></a><code><span class="keyword">val</span> add_unary_simplify : <a href="index.html#type-simplify_rule">simplify_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add unary simplification rule (not dependent on proof state)</p></dd></dl><dl><dt class="spec value" id="val-add_multi_simpl_rule"><a href="#val-add_multi_simpl_rule" class="anchor"></a><code><span class="keyword">val</span> add_multi_simpl_rule : <span>priority:int</span> <span>&#45;&gt;</span> <a href="index.html#type-multi_simpl_rule">multi_simpl_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a multi-clause simplification rule</p></dd></dl><dl><dt class="spec value" id="val-add_single_step_multi_simpl_rule"><a href="#val-add_single_step_multi_simpl_rule" class="anchor"></a><code><span class="keyword">val</span> add_single_step_multi_simpl_rule : <a href="index.html#type-multi_simpl_rule">multi_simpl_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a multi-clause simplification rule, that is going to be applied only once, not in a fixed-point manner</p></dd></dl><dl><dt class="spec value" id="val-add_cheap_multi_simpl_rule"><a href="#val-add_cheap_multi_simpl_rule" class="anchor"></a><code><span class="keyword">val</span> add_cheap_multi_simpl_rule : <a href="index.html#type-multi_simpl_rule">multi_simpl_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add an efficient multi-clause simplification rule, that will be used to simplify newly generated clauses when they are moved from unprocessed to passive set.</p></dd></dl><dl><dt class="spec value" id="val-add_is_trivial_trail"><a href="#val-add_is_trivial_trail" class="anchor"></a><code><span class="keyword">val</span> add_is_trivial_trail : <a href="index.html#type-is_trivial_trail_rule">is_trivial_trail_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add tautology detection rule</p></dd></dl><dl><dt class="spec value" id="val-add_is_trivial"><a href="#val-add_is_trivial" class="anchor"></a><code><span class="keyword">val</span> add_is_trivial : <a href="index.html#type-is_trivial_rule">is_trivial_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add tautology detection rule</p></dd></dl><dl><dt class="spec value" id="val-add_rewrite_rule"><a href="#val-add_rewrite_rule" class="anchor"></a><code><span class="keyword">val</span> add_rewrite_rule : string <span>&#45;&gt;</span> <a href="index.html#type-term_rewrite_rule">term_rewrite_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a term rewrite rule</p></dd></dl><dl><dt class="spec value" id="val-set_ho_normalization_rule"><a href="#val-set_ho_normalization_rule" class="anchor"></a><code><span class="keyword">val</span> set_ho_normalization_rule : string <span>&#45;&gt;</span> <a href="index.html#type-term_norm_rule">term_norm_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a ho norm rule</p></dd></dl><dl><dt class="spec value" id="val-get_ho_normalization_rule"><a href="#val-get_ho_normalization_rule" class="anchor"></a><code><span class="keyword">val</span> get_ho_normalization_rule : unit <span>&#45;&gt;</span> <a href="index.html#type-term_norm_rule">term_norm_rule</a></code></dt><dt class="spec value" id="val-add_immediate_simpl_rule"><a href="#val-add_immediate_simpl_rule" class="anchor"></a><code><span class="keyword">val</span> add_immediate_simpl_rule : <a href="index.html#type-immediate_simplification_rule">immediate_simplification_rule</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_lit_rule"><a href="#val-add_lit_rule" class="anchor"></a><code><span class="keyword">val</span> add_lit_rule : string <span>&#45;&gt;</span> <a href="index.html#type-lit_rewrite_rule">lit_rewrite_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a literal rewrite rule</p></dd></dl><dl><dt class="spec value" id="val-add_generate"><a href="#val-add_generate" class="anchor"></a><code><span class="keyword">val</span> add_generate : <span>priority:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-generate_rule">generate_rule</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a generation rule with assigned priority. Rules with higher priority will be tried first.</p></dd></dl><dl><dt class="spec value" id="val-add_clause_elimination_rule"><a href="#val-add_clause_elimination_rule" class="anchor"></a><code><span class="keyword">val</span> add_clause_elimination_rule : <span>priority:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-clause_elim_rule">clause_elim_rule</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-cr_skip"><a href="#val-cr_skip" class="anchor"></a><code><span class="keyword">val</span> cr_skip : <span><span class="type-var">_</span> <a href="index.html#type-conversion_result">conversion_result</a></span></code></dt><dt class="spec value" id="val-cr_return"><a href="#val-cr_return" class="anchor"></a><code><span class="keyword">val</span> cr_return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-conversion_result">conversion_result</a></span></code></dt><dt class="spec value" id="val-cr_add"><a href="#val-cr_add" class="anchor"></a><code><span class="keyword">val</span> cr_add : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-conversion_result">conversion_result</a></span></code></dt><dt class="spec value" id="val-add_clause_conversion"><a href="#val-add_clause_conversion" class="anchor"></a><code><span class="keyword">val</span> add_clause_conversion : <a href="index.html#type-clause_conversion_rule">clause_conversion_rule</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_step_init"><a href="#val-add_step_init" class="anchor"></a><code><span class="keyword">val</span> add_step_init : <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>add a function to call before each saturation step</p></dd></dl><dl><dt class="spec value" id="val-add_fragment_check"><a href="#val-add_fragment_check" class="anchor"></a><code><span class="keyword">val</span> add_fragment_check : <span>(<a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-check_fragment"><a href="#val-check_fragment" class="anchor"></a><code><span class="keyword">val</span> check_fragment : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h3 id="use-the-env"><a href="#use-the-env" class="anchor"></a>Use the Env</h3></header><dl><dt class="spec value" id="val-multi_simplify"><a href="#val-multi_simplify" class="anchor"></a><code><span class="keyword">val</span> multi_simplify : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> option</span></code></dt><dd><p>Can we simplify the clause into a List of simplified clauses?</p></dd></dl><dl><dt class="spec value" id="val-params"><a href="#val-params" class="anchor"></a><code><span class="keyword">val</span> params : <a href="../../../Params/index.html#type-t">Params.t</a></code></dt><dt class="spec value" id="val-get_empty_clauses"><a href="#val-get_empty_clauses" class="anchor"></a><code><span class="keyword">val</span> get_empty_clauses : unit <span>&#45;&gt;</span> <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t</code></dt><dd><p>Set of known empty clauses</p></dd></dl><dl><dt class="spec value" id="val-get_some_empty_clause"><a href="#val-get_some_empty_clause" class="anchor"></a><code><span class="keyword">val</span> get_some_empty_clause : unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> option</span></code></dt><dd><p>Some empty clause, if present, otherwise None</p></dd></dl><dl><dt class="spec value" id="val-has_empty_clause"><a href="#val-has_empty_clause" class="anchor"></a><code><span class="keyword">val</span> has_empty_clause : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Is there an empty clause?</p></dd></dl><dl><dt class="spec value" id="val-on_start"><a href="#val-on_start" class="anchor"></a><code><span class="keyword">val</span> on_start : <span>unit <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Triggered before starting saturation</p></dd></dl><dl><dt class="spec value" id="val-on_input_statement"><a href="#val-on_input_statement" class="anchor"></a><code><span class="keyword">val</span> on_input_statement : <span><a href="../../../../../logtk/Logtk/Statement/index.html#type-clause_t">Logtk.Statement.clause_t</a> <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Triggered on every input statement</p></dd></dl><dl><dt class="spec value" id="val-on_forward_simplified"><a href="#val-on_forward_simplified" class="anchor"></a><code><span class="keyword">val</span> on_forward_simplified : <span><span>(<a href="C/index.html#type-t">C.t</a> * <span><a href="C/index.html#type-t">C.t</a> option</span>)</span> <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Triggered when after the clause set is fully forward-simplified. First argument is the original clause c and the second one is Some c' if c simplifies into c' or None if c is deemed redundant</p></dd></dl><dl><dt class="spec value" id="val-convert_input_statements"><a href="#val-convert_input_statements" class="anchor"></a><code><span class="keyword">val</span> convert_input_statements : <span><a href="../../../../../logtk/Logtk/Statement/index.html#type-clause_t">Logtk.Statement.clause_t</a> CCVector.ro_vector</span> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> <a href="../../../Clause/index.html#type-sets">Clause.sets</a></span></code></dt><dd><p>Convert raw input statements into clauses, triggering <a href="index.html#val-on_input_statement"><code>on_input_statement</code></a></p></dd></dl><dl><dt class="spec value" id="val-on_empty_clause"><a href="#val-on_empty_clause" class="anchor"></a><code><span class="keyword">val</span> on_empty_clause : <span><a href="C/index.html#type-t">C.t</a> <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>Signal triggered when an empty clause is found</p></dd></dl><dl><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val</span> ord : unit <span>&#45;&gt;</span> <a href="../../../../../logtk/Logtk/Ordering/index.html#type-t">Logtk.Ordering.t</a></code></dt><dt class="spec value" id="val-precedence"><a href="#val-precedence" class="anchor"></a><code><span class="keyword">val</span> precedence : unit <span>&#45;&gt;</span> <a href="../../../../../logtk/Logtk/Precedence/index.html#type-t">Logtk.Precedence.t</a></code></dt><dt class="spec value" id="val-signature"><a href="#val-signature" class="anchor"></a><code><span class="keyword">val</span> signature : unit <span>&#45;&gt;</span> <a href="../../../../../logtk/Logtk/Signature/index.html#type-t">Logtk.Signature.t</a></code></dt><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span>unit CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_full"><a href="#val-pp_full" class="anchor"></a><code><span class="keyword">val</span> pp_full : <span>unit CCFormat.printer</span></code></dt></dl></section><section><header><h3 id="high-level-operations"><a href="#high-level-operations" class="anchor"></a>High level operations</h3></header><dl><dt class="spec type" id="type-stats"><a href="#type-stats" class="anchor"></a><code><span class="keyword">type</span> stats</code><code> = int * int * int</code></dt><dd><p>statistics on clauses : num active, num passive, num simplification</p></dd></dl><dl><dt class="spec value" id="val-stats"><a href="#val-stats" class="anchor"></a><code><span class="keyword">val</span> stats : unit <span>&#45;&gt;</span> <a href="index.html#type-stats">stats</a></code></dt><dd><p>Compute stats</p></dd></dl><dl><dt class="spec value" id="val-next_passive"><a href="#val-next_passive" class="anchor"></a><code><span class="keyword">val</span> next_passive : unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> option</span></code></dt><dd><p>Extract next passive clause</p></dd></dl><dl><dt class="spec value" id="val-do_binary_inferences"><a href="#val-do_binary_inferences" class="anchor"></a><code><span class="keyword">val</span> do_binary_inferences : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>do binary inferences that involve the given clause</p></dd></dl><dl><dt class="spec value" id="val-do_unary_inferences"><a href="#val-do_unary_inferences" class="anchor"></a><code><span class="keyword">val</span> do_unary_inferences : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>do unary inferences for the given clause</p></dd></dl><dl><dt class="spec value" id="val-do_generate"><a href="#val-do_generate" class="anchor"></a><code><span class="keyword">val</span> do_generate : <span>full:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>do generating inferences</p></dd></dl><dl><dt class="spec value" id="val-do_clause_eliminate"><a href="#val-do_clause_eliminate" class="anchor"></a><code><span class="keyword">val</span> do_clause_eliminate : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>changes the proof state by running registered clause elimination procedures and removing all the eliminated clauses from the proof state</p></dd></dl><dl><dt class="spec value" id="val-is_trivial_trail"><a href="#val-is_trivial_trail" class="anchor"></a><code><span class="keyword">val</span> is_trivial_trail : <a href="../../../Trail/index.html#type-t">Trail.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the trail is trivial</p></dd></dl><dl><dt class="spec value" id="val-is_trivial"><a href="#val-is_trivial" class="anchor"></a><code><span class="keyword">val</span> is_trivial : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the clause is trivial</p></dd></dl><dl><dt class="spec value" id="val-is_active"><a href="#val-is_active" class="anchor"></a><code><span class="keyword">val</span> is_active : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the clause in the active set</p></dd></dl><dl><dt class="spec value" id="val-is_passive"><a href="#val-is_passive" class="anchor"></a><code><span class="keyword">val</span> is_passive : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the clause a passive clause?</p></dd></dl><dl><dt class="spec value" id="val-basic_simplify"><a href="#val-basic_simplify" class="anchor"></a><code><span class="keyword">val</span> basic_simplify : <a href="index.html#type-simplify_rule">simplify_rule</a></code></dt><dd><p>Basic (and fast) simplifications</p></dd></dl><dl><dt class="spec value" id="val-unary_simplify"><a href="#val-unary_simplify" class="anchor"></a><code><span class="keyword">val</span> unary_simplify : <a href="index.html#type-simplify_rule">simplify_rule</a></code></dt><dd><p>Simplify the clause.</p></dd></dl><dl><dt class="spec value" id="val-backward_simplify"><a href="#val-backward_simplify" class="anchor"></a><code><span class="keyword">val</span> backward_simplify : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t * <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>Perform backward simplification with the given clause. It returns the CSet of clauses that become redundant, and the sequence of those very same clauses after simplification.</p></dd></dl><dl><dt class="spec value" id="val-simplify_active_with"><a href="#val-simplify_active_with" class="anchor"></a><code><span class="keyword">val</span> simplify_active_with : <span>(<a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> option</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Can be called when a simplification relation becomes stronger, with the strengthened relation. (e.g. new axioms should be declared because a theory was detected). This will go through the whole active set, trying to simplify clauses with the given function. Simplified clauses will be put back in the passive set.</p></dd></dl><dl><dt class="spec value" id="val-forward_simplify"><a href="#val-forward_simplify" class="anchor"></a><code><span class="keyword">val</span> forward_simplify : <a href="index.html#type-simplify_rule">simplify_rule</a></code></dt><dd><p>Simplify the clause w.r.t to the active set and experts</p></dd></dl><dl><dt class="spec value" id="val-cheap_multi_simplify"><a href="#val-cheap_multi_simplify" class="anchor"></a><code><span class="keyword">val</span> cheap_multi_simplify : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> option</span></code></dt><dd><p>Cheap simplifications that can result in multiple clauses (e.g. AVATAR splitting)</p></dd></dl><dl><dt class="spec value" id="val-immediate_simplify"><a href="#val-immediate_simplify" class="anchor"></a><code><span class="keyword">val</span> immediate_simplify : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>Simplify given clause using its children. Given clause is removed from active set and result of this rule is added to passive set, if any of the registered rules suceeded</p></dd></dl><dl><dt class="spec value" id="val-generate"><a href="#val-generate" class="anchor"></a><code><span class="keyword">val</span> generate : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><a href="C/index.html#type-t">C.t</a> Iter.t</span></code></dt><dd><p>Perform all generating inferences</p></dd></dl><dl><dt class="spec value" id="val-is_redundant"><a href="#val-is_redundant" class="anchor"></a><code><span class="keyword">val</span> is_redundant : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the given clause redundant w.r.t the active set?</p></dd></dl><dl><dt class="spec value" id="val-subsumed_by"><a href="#val-subsumed_by" class="anchor"></a><code><span class="keyword">val</span> subsumed_by : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <a href="C/index.html#module-ClauseSet">C.ClauseSet</a>.t</code></dt><dd><p>List of active clauses subsumed by the given clause</p></dd></dl><dl><dt class="spec value" id="val-all_simplify"><a href="#val-all_simplify" class="anchor"></a><code><span class="keyword">val</span> all_simplify : <a href="C/index.html#type-t">C.t</a> <span>&#45;&gt;</span> <span><span><a href="C/index.html#type-t">C.t</a> list</span> <a href="../../../SimplM/index.html#type-t">SimplM.t</a></span></code></dt><dd><p>Use all simplification rules to convert a clause into a set of maximally simplified clause (or <code>[]</code> if they are all trivial).</p></dd></dl><dl><dt class="spec value" id="val-step_init"><a href="#val-step_init" class="anchor"></a><code><span class="keyword">val</span> step_init : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>call all functions registered with <a href="index.html#val-add_step_init"><code>add_step_init</code></a></p></dd></dl></section><section><header><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3></header><dl><dt class="spec value" id="val-flex_state"><a href="#val-flex_state" class="anchor"></a><code><span class="keyword">val</span> flex_state : unit <span>&#45;&gt;</span> <a href="../../../../../logtk/Logtk/Flex_state/index.html#type-t">Logtk.Flex_state.t</a></code></dt><dd><p>State inherited from configuration</p></dd></dl><dl><dt class="spec value" id="val-update_flex_state"><a href="#val-update_flex_state" class="anchor"></a><code><span class="keyword">val</span> update_flex_state : <span>(<a href="../../../../../logtk/Logtk/Flex_state/index.html#type-t">Logtk.Flex_state.t</a> <span>&#45;&gt;</span> <a href="../../../../../logtk/Logtk/Flex_state/index.html#type-t">Logtk.Flex_state.t</a>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>update_flex_state f</code> changes <code>flex_state ()</code> using <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-flex_add"><a href="#val-flex_add" class="anchor"></a><code><span class="keyword">val</span> flex_add : <span><span class="type-var">'a</span> <a href="../../../../../logtk/Logtk/Flex_state/index.html#type-key">Logtk.Flex_state.key</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>add <code>k -&gt; v</code> to the flex state</p></dd></dl><dl><dt class="spec value" id="val-flex_get"><a href="#val-flex_get" class="anchor"></a><code><span class="keyword">val</span> flex_get : <span><span class="type-var">'a</span> <a href="../../../../../logtk/Logtk/Flex_state/index.html#type-key">Logtk.Flex_state.key</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>flex_get k</code> is the same as <code>Flex_state.get_exn k (flex_state ())</code>.</p><dl><dt>raises Not_found</dt><dd><p>if the key is not present</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-on_pred_var_elimination"><a href="#val-on_pred_var_elimination" class="anchor"></a><code><span class="keyword">val</span> on_pred_var_elimination : <span><span>(<a href="C/index.html#type-t">C.t</a> * <a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a>)</span> <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>this signal is raised if a formula that universally quantifies a predicate removes that predicate and rules that want to instantiate it early should listen to this</p></dd></dl><dl><dt class="spec value" id="val-on_pred_skolem_introduction"><a href="#val-on_pred_skolem_introduction" class="anchor"></a><code><span class="keyword">val</span> on_pred_skolem_introduction : <span><span>(<a href="C/index.html#type-t">C.t</a> * <a href="../../../../../logtk/Logtk/Term/index.html#type-t">Logtk.Term.t</a>)</span> <a href="../../../../../logtk/Logtk/Signal/index.html#type-t">Logtk.Signal.t</a></span></code></dt><dd><p>this signal is raised when a predicate Skolem is introduced</p></dd></dl></section></div></body></html>