<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type (logtk.Logtk.Type)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; Type</nav><h1>Module <code>Logtk.Type</code></h1><nav class="toc"><ul><li><a href="#types">Types</a><ul><li><a href="#main-type-representation">Main Type representation</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#definition">Definition</a></li><li><a href="#containers">Containers</a></li><li><a href="#utils">Utils</a></li><li><a href="#io">IO</a></li><li><a href="#tptp">TPTP</a></li><li><a href="#conversions">Conversions</a></li></ul></li></ul></nav></header><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><section><header><h3 id="main-type-representation"><a href="#main-type-representation" class="anchor"></a>Main Type representation</h3><p>Types are represented using InnerTerm, with kind Type. Therefore, they are hashconsed and scoped.</p><p>Common representation of types, including higher-order and polymorphic types. All type variables are assumed to be universally quantified in the outermost possible scope (outside any other quantifier).</p><p>See <a href="../TypeInference/index.html"><code>TypeInference</code></a> for inferring types from terms and formulas, and <a href="../Signature/index.html"><code>Signature</code></a> to associate types with symbols.</p><p>TODO: think of a good way of representing AC operators (+, ...)</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a></code></dt><dd><p>Type is a subtype of the term structure (itself a subtype of InnerTerm.t), with explicit conversion</p></dd></dl><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code><code> = <a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-builtin"><a href="#type-builtin" class="anchor"></a><code><span class="keyword">type</span> builtin</code><code> = </code><table class="variant"><tr id="type-builtin.TType" class="anchored"><td class="def constructor"><a href="#type-builtin.TType" class="anchor"></a><code>| </code><code><span class="constructor">TType</span></code></td></tr><tr id="type-builtin.Prop" class="anchored"><td class="def constructor"><a href="#type-builtin.Prop" class="anchor"></a><code>| </code><code><span class="constructor">Prop</span></code></td></tr><tr id="type-builtin.Term" class="anchored"><td class="def constructor"><a href="#type-builtin.Term" class="anchor"></a><code>| </code><code><span class="constructor">Term</span></code></td></tr><tr id="type-builtin.Rat" class="anchored"><td class="def constructor"><a href="#type-builtin.Rat" class="anchor"></a><code>| </code><code><span class="constructor">Rat</span></code></td></tr><tr id="type-builtin.Int" class="anchored"><td class="def constructor"><a href="#type-builtin.Int" class="anchor"></a><code>| </code><code><span class="constructor">Int</span></code></td></tr><tr id="type-builtin.Real" class="anchored"><td class="def constructor"><a href="#type-builtin.Real" class="anchor"></a><code>| </code><code><span class="constructor">Real</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-pp_builtin"><a href="#val-pp_builtin" class="anchor"></a><code><span class="keyword">val</span> pp_builtin : <span><a href="index.html#type-builtin">builtin</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-builtin_conv"><a href="#val-builtin_conv" class="anchor"></a><code><span class="keyword">val</span> builtin_conv : <a href="index.html#type-builtin">builtin</a> <span>&#45;&gt;</span> <a href="../Builtin/index.html#type-t">Builtin.t</a></code></dt></dl><dl><dt class="spec type" id="type-view"><a href="#type-view" class="anchor"></a><code><span class="keyword">type</span> view</code><code> = <span class="keyword">private</span> </code><table class="variant"><tr id="type-view.Builtin" class="anchored"><td class="def constructor"><a href="#type-view.Builtin" class="anchor"></a><code>| </code><code><span class="constructor">Builtin</span> <span class="keyword">of</span> <a href="index.html#type-builtin">builtin</a></code></td></tr><tr id="type-view.Var" class="anchored"><td class="def constructor"><a href="#type-view.Var" class="anchor"></a><code>| </code><code><span class="constructor">Var</span> <span class="keyword">of</span> <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></td></tr><tr id="type-view.DB" class="anchored"><td class="def constructor"><a href="#type-view.DB" class="anchor"></a><code>| </code><code><span class="constructor">DB</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-view.App" class="anchored"><td class="def constructor"><a href="#type-view.App" class="anchor"></a><code>| </code><code><span class="constructor">App</span> <span class="keyword">of</span> <a href="../ID/index.html#type-t">ID.t</a> * <span><a href="index.html#type-t">t</a> list</span></code></td><td class="doc"><p>parametrized type</p></td></tr><tr id="type-view.Fun" class="anchored"><td class="def constructor"><a href="#type-view.Fun" class="anchor"></a><code>| </code><code><span class="constructor">Fun</span> <span class="keyword">of</span> <span><a href="index.html#type-t">t</a> list</span> * <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Function type (left to right, no left-nesting)</p></td></tr><tr id="type-view.Forall" class="anchored"><td class="def constructor"><a href="#type-view.Forall" class="anchor"></a><code>| </code><code><span class="constructor">Forall</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td><td class="doc"><p>explicit quantification using De Bruijn index</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val</span> view : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-view">view</a></code></dt><dd><p>Type-centric view of the head of this type.</p><dl><dt>raises Assert_failure</dt><dd><p>if the argument is not a type</p></dd></dl></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-HASH">Interfaces.HASH</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-HASH/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-EQ">Interfaces.EQ</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-ORD">Interfaces.ORD</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-ORD/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-is_tType"><a href="#val-is_tType" class="anchor"></a><code><span class="keyword">val</span> is_tType : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_var"><a href="#val-is_var" class="anchor"></a><code><span class="keyword">val</span> is_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_bvar"><a href="#val-is_bvar" class="anchor"></a><code><span class="keyword">val</span> is_bvar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_app"><a href="#val-is_app" class="anchor"></a><code><span class="keyword">val</span> is_app : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_const"><a href="#val-is_const" class="anchor"></a><code><span class="keyword">val</span> is_const : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_fun"><a href="#val-is_fun" class="anchor"></a><code><span class="keyword">val</span> is_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_forall"><a href="#val-is_forall" class="anchor"></a><code><span class="keyword">val</span> is_forall : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_prop"><a href="#val-is_prop" class="anchor"></a><code><span class="keyword">val</span> is_prop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-as_var_exn"><a href="#val-as_var_exn" class="anchor"></a><code><span class="keyword">val</span> as_var_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></dt><dt class="spec value" id="val-hash_mod_alpha"><a href="#val-hash_mod_alpha" class="anchor"></a><code><span class="keyword">val</span> hash_mod_alpha : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Hash invariant w.r.t variable renaming</p></dd></dl></section><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-tType"><a href="#val-tType" class="anchor"></a><code><span class="keyword">val</span> tType : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-prop"><a href="#val-prop" class="anchor"></a><code><span class="keyword">val</span> prop : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-term"><a href="#val-term" class="anchor"></a><code><span class="keyword">val</span> term : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-rat"><a href="#val-rat" class="anchor"></a><code><span class="keyword">val</span> rat : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-real"><a href="#val-real" class="anchor"></a><code><span class="keyword">val</span> real : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-var_of_int"><a href="#val-var_of_int" class="anchor"></a><code><span class="keyword">val</span> var_of_int : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a type variable.</p></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Parametrized type</p></dd></dl><dl><dt class="spec value" id="val-builtin"><a href="#val-builtin" class="anchor"></a><code><span class="keyword">val</span> builtin : <a href="index.html#type-builtin">builtin</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Constant sort</p></dd></dl><dl><dt class="spec value" id="val-arrow"><a href="#val-arrow" class="anchor"></a><code><span class="keyword">val</span> arrow : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>arrow l r</code> is the type <code>l -&gt; r</code>.</p></dd></dl><dl><dt class="spec value" id="val-forall"><a href="#val-forall" class="anchor"></a><code><span class="keyword">val</span> forall : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Quantify over one type variable. Careful with the De Bruijn indices!</p></dd></dl><dl><dt class="spec value" id="val-forall_n"><a href="#val-forall_n" class="anchor"></a><code><span class="keyword">val</span> forall_n : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Quantify over <code>n</code> type variable. Careful with the De Bruijn indices!</p></dd></dl><dl><dt class="spec value" id="val-forall_fvars"><a href="#val-forall_fvars" class="anchor"></a><code><span class="keyword">val</span> forall_fvars : <span><span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>forall_fvars vars body</code> makes the De Bruijn conversion before quantifying on <code>vars</code></p></dd></dl><dl><dt class="spec value" id="val-bvar"><a href="#val-bvar" class="anchor"></a><code><span class="keyword">val</span> bvar : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bound variable</p></dd></dl><dl><dt class="spec value" id="val-(==&gt;)"><a href="#val-(==&gt;)" class="anchor"></a><code><span class="keyword">val</span> (==&gt;) : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>General function type. <code>l ==&gt; x</code> is the same as <code>x</code> if <code>l</code> is empty. Invariant: the return type is never a function type.</p></dd></dl><dl><dt class="spec value" id="val-of_term_unsafe"><a href="#val-of_term_unsafe" class="anchor"></a><code><span class="keyword">val</span> of_term_unsafe : <a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><b>NOTE</b>: this can break the invariants and make <a href="index.html#type-view"><code>view</code></a> fail. Only use with caution.</p></dd></dl><dl><dt class="spec value" id="val-of_terms_unsafe"><a href="#val-of_terms_unsafe" class="anchor"></a><code><span class="keyword">val</span> of_terms_unsafe : <span><a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dt class="spec value" id="val-cast_var_unsafe"><a href="#val-cast_var_unsafe" class="anchor"></a><code><span class="keyword">val</span> cast_var_unsafe : <span><a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></dt></dl></section><section><header><h3 id="definition"><a href="#definition" class="anchor"></a>Definition</h3></header><dl><dt class="spec type" id="type-def"><a href="#type-def" class="anchor"></a><code><span class="keyword">type</span> def</code><code> = </code><table class="variant"><tr id="type-def.Def_unin" class="anchored"><td class="def constructor"><a href="#type-def.Def_unin" class="anchor"></a><code>| </code><code><span class="constructor">Def_unin</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-def.Def_data" class="anchored"><td class="def constructor"><a href="#type-def.Def_data" class="anchor"></a><code>| </code><code><span class="constructor">Def_data</span> <span class="keyword">of</span> int * <span><a href="index.html#type-ty">ty</a> list</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-def"><a href="#val-def" class="anchor"></a><code><span class="keyword">val</span> def : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-def">def</a> option</span></code></dt><dd><p>Access the definition of a type</p></dd></dl><dl><dt class="spec value" id="val-def_exn"><a href="#val-def_exn" class="anchor"></a><code><span class="keyword">val</span> def_exn : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt><dd><p>Unsafe version of <a href="index.html#type-def"><code>def</code></a></p><dl><dt>raises Not_found</dt><dd><p>if not a proper constant</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_def"><a href="#val-set_def" class="anchor"></a><code><span class="keyword">val</span> set_def : <a href="../ID/index.html#type-t">ID.t</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set definition of an ID</p></dd></dl></section><section><header><h3 id="containers"><a href="#containers" class="anchor"></a>Containers</h3></header><div class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> Set : CCSet.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Set">Set</a>.elt = <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> Map : CCMap.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Map">Map</a>.key = <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module</span> Tbl : CCHashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Tbl">Tbl</a>.key = <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Seq"><a href="#module-Seq" class="anchor"></a><code><span class="keyword">module</span> <a href="Seq/index.html">Seq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="utils"><a href="#utils" class="anchor"></a>Utils</h3></header><div class="spec module" id="module-VarSet"><a href="#module-VarSet" class="anchor"></a><code><span class="keyword">module</span> VarSet : CCSet.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarSet">VarSet</a>.elt = <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></div><div class="spec module" id="module-VarMap"><a href="#module-VarMap" class="anchor"></a><code><span class="keyword">module</span> VarMap : CCMap.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarMap">VarMap</a>.key = <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></div><div class="spec module" id="module-VarTbl"><a href="#module-VarTbl" class="anchor"></a><code><span class="keyword">module</span> VarTbl : CCHashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-VarTbl">VarTbl</a>.key = <span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span></code></div><dl><dt class="spec value" id="val-vars_set"><a href="#val-vars_set" class="anchor"></a><code><span class="keyword">val</span> vars_set : <a href="index.html#module-VarSet">VarSet</a>.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#module-VarSet">VarSet</a>.t</code></dt><dd><p>Add the free variables to the given set</p></dd></dl><dl><dt class="spec value" id="val-vars"><a href="#val-vars" class="anchor"></a><code><span class="keyword">val</span> vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> list</span></code></dt><dd><p>List of free variables</p></dd></dl><dl><dt class="spec value" id="val-close_forall"><a href="#val-close_forall" class="anchor"></a><code><span class="keyword">val</span> close_forall : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bind free variables</p></dd></dl><dl><dt class="spec type" id="type-arity_result"><a href="#type-arity_result" class="anchor"></a><code><span class="keyword">type</span> arity_result</code><code> = </code><table class="variant"><tr id="type-arity_result.Arity" class="anchored"><td class="def constructor"><a href="#type-arity_result.Arity" class="anchor"></a><code>| </code><code><span class="constructor">Arity</span> <span class="keyword">of</span> int * int</code></td></tr><tr id="type-arity_result.NoArity" class="anchored"><td class="def constructor"><a href="#type-arity_result.NoArity" class="anchor"></a><code>| </code><code><span class="constructor">NoArity</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-arity"><a href="#val-arity" class="anchor"></a><code><span class="keyword">val</span> arity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-arity_result">arity_result</a></code></dt><dd><p>Number of arguments the type expects. If <code>arity ty</code> returns <code>Arity (a, b)</code> that means that it expects <code>a</code> arguments to be used as arguments of Forall, and <code>b</code> arguments to be used for function application. If it returns <code>NoArity</code> then the arity is unknown (variable)</p></dd></dl><dl><dt class="spec value" id="val-expected_args"><a href="#val-expected_args" class="anchor"></a><code><span class="keyword">val</span> expected_args : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p>Types expected as function argument by <code>ty</code>. The length of the list <code>expected_args ty</code> is the same as <code>snd (arity ty)</code>.</p></dd></dl><dl><dt class="spec value" id="val-expected_ty_vars"><a href="#val-expected_ty_vars" class="anchor"></a><code><span class="keyword">val</span> expected_ty_vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Number of type parameters expected. 0 for monomorphic types.</p></dd></dl><dl><dt class="spec value" id="val-needs_args"><a href="#val-needs_args" class="anchor"></a><code><span class="keyword">val</span> needs_args : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>needs_args ty</code> iff <code>expected_ty_vars ty&gt;0 || expected_args ty&lt;&gt;[]</code></p></dd></dl><dl><dt class="spec value" id="val-order"><a href="#val-order" class="anchor"></a><code><span class="keyword">val</span> order : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Number of left-nested function types (1 for constant and variables). <code>order (a-&gt;b) = 1</code> <code>order ((a-&gt;b)-&gt;c) = 2</code> <code>order (((a-&gt;b)-&gt;c)-&gt;d) = 2</code></p></dd></dl><dl><dt class="spec value" id="val-contains_prop"><a href="#val-contains_prop" class="anchor"></a><code><span class="keyword">val</span> contains_prop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_ground"><a href="#val-is_ground" class="anchor"></a><code><span class="keyword">val</span> is_ground : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the type ground? (means that no <a href="index.html#type-view.Var"><code>Var</code></a> not <code>BVar</code> occurs in it)</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Size of type, in number of &quot;nodes&quot;</p></dd></dl><dl><dt class="spec value" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span class="keyword">val</span> depth : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Depth of the type (length of the longest path to some leaf)</p><dl><dt>since</dt><dd>0.5.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-open_poly_fun"><a href="#val-open_poly_fun" class="anchor"></a><code><span class="keyword">val</span> open_poly_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int * <span><a href="index.html#type-t">t</a> list</span> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>open_poly_fun ty</code> &quot;unrolls&quot; polymorphic function arrows from the left, so that <code>open_poly_fun (forall a b. f a -&gt; (g b -&gt; (c -&gt; d)))</code> returns <code>2; [f a;g b;c], d</code>.</p><dl><dt>returns</dt><dd><p>the return type, the number of type variables, and the list of all its arguments</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-open_fun"><a href="#val-open_fun" class="anchor"></a><code><span class="keyword">val</span> open_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>open_fun ty</code> &quot;unrolls&quot; function arrows from the left, so that <code>open_fun (a -&gt; (b -&gt; (c -&gt; d)))</code> returns <code>[a;b;c], d</code>.</p><dl><dt>returns</dt><dd><p>the return type and the list of all its arguments</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-returns"><a href="#val-returns" class="anchor"></a><code><span class="keyword">val</span> returns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>returned type (going through foralls and arrows). <code>returns a</code> is like <code>let _, _, ret = open_poly_fun a in ret</code> <b>NOTE</b> caution, not always closed</p></dd></dl><dl><dt class="spec value" id="val-returns_prop"><a href="#val-returns_prop" class="anchor"></a><code><span class="keyword">val</span> returns_prop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-returns_tType"><a href="#val-returns_tType" class="anchor"></a><code><span class="keyword">val</span> returns_tType : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec exception" id="exception-ApplyError"><a href="#exception-ApplyError" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">ApplyError</span> <span class="keyword">of</span> string</code></dt><dd><p>Error raised when <a href="index.html#val-apply"><code>apply</code></a> fails</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Given a function/forall type, and arguments, return the type that results from applying the function/forall to the arguments. No unification is done, types must check exactly.</p><dl><dt>raises ApplyError</dt><dd><p>if the types do not match</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-apply1"><a href="#val-apply1" class="anchor"></a><code><span class="keyword">val</span> apply1 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>apply1 a b</code> is short for <code>apply a [b]</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply_unsafe"><a href="#val-apply_unsafe" class="anchor"></a><code><span class="keyword">val</span> apply_unsafe : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../InnerTerm/index.html#type-t">InnerTerm.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <a href="index.html#val-apply"><code>apply</code></a>, but assumes its arguments are well-formed types without more ado.</p><dl><dt>raises ApplyError</dt><dd><p>if types do not match</p></dd></dl><dl><dt>raises Assert_failure</dt><dd><p>if the arguments are not proper types</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_unifiable"><a href="#val-is_unifiable" class="anchor"></a><code><span class="keyword">val</span> is_unifiable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Are terms of this type syntactically unifiable? See <a href="../InnerTerm/index.html#val-type_is_unifiable"><code>InnerTerm.type_is_unifiable</code></a></p></dd></dl></section><section><header><h3 id="io"><a href="#io" class="anchor"></a>IO</h3></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-PRINT_DE_BRUIJN">Interfaces.PRINT_DE_BRUIJN</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-term">term</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT_DE_BRUIJN/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code></dt><dt class="spec type" id="type-print_hook"><a href="#type-print_hook" class="anchor"></a><code><span class="keyword">type</span> print_hook</code><code> = int <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> CCFormat.printer</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>User-provided hook that can be used to print terms (for composite cases) before the default printing occurs. The int argument is the De Bruijn depth in the term. A hook takes as arguments the depth and the recursive printing function that it can use to print subterms. A hook should return <code>true</code> if it fired, <code>false</code> to fall back on the default printing.</p></dd></dl><dl><dt class="spec value" id="val-pp_depth"><a href="#val-pp_depth" class="anchor"></a><code><span class="keyword">val</span> pp_depth : <span>?&#8288;hooks:<span><a href="index.html#type-print_hook">print_hook</a> list</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interfaces/index.html#module-type-PRINT">Interfaces.PRINT</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Interfaces/module-type-PRINT/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pp_surrounded"><a href="#val-pp_surrounded" class="anchor"></a><code><span class="keyword">val</span> pp_surrounded : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-pp_typed_var"><a href="#val-pp_typed_var" class="anchor"></a><code><span class="keyword">val</span> pp_typed_var : <span><span><a href="index.html#type-t">t</a> <a href="../HVar/index.html#type-t">HVar.t</a></span> CCFormat.printer</span></code></dt><dt class="spec value" id="val-mangle"><a href="#val-mangle" class="anchor"></a><code><span class="keyword">val</span> mangle : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-pp_mangle"><a href="#val-pp_mangle" class="anchor"></a><code><span class="keyword">val</span> pp_mangle : <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt></dl></section><section><header><h3 id="tptp"><a href="#tptp" class="anchor"></a>TPTP</h3><p>specific printer and types</p></header><div class="spec module" id="module-TPTP"><a href="#module-TPTP" class="anchor"></a><code><span class="keyword">module</span> <a href="TPTP/index.html">TPTP</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-ZF"><a href="#module-ZF" class="anchor"></a><code><span class="keyword">module</span> <a href="ZF/index.html">ZF</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_in"><a href="#val-pp_in" class="anchor"></a><code><span class="keyword">val</span> pp_in : <a href="../Output_format/index.html#type-t">Output_format.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> CCFormat.printer</span></code></dt></dl></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><div class="spec module" id="module-Conv"><a href="#module-Conv" class="anchor"></a><code><span class="keyword">module</span> <a href="Conv/index.html">Conv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></div></body></html>