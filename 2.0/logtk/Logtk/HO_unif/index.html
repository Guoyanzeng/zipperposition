<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HO_unif (logtk.Logtk.HO_unif)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">logtk</a> &#x00BB; <a href="../index.html">Logtk</a> &#x00BB; HO_unif</nav><h1>Module <code>Logtk.HO_unif</code></h1><nav class="toc"><ul><li><a href="#higher-order-unification">Higher-Order Unification</a></li></ul></nav></header><section><header><h2 id="higher-order-unification"><a href="#higher-order-unification" class="anchor"></a>Higher-Order Unification</h2></header><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="../Term/index.html#type-t">Term.t</a></code></dt><dt class="spec type" id="type-penalty"><a href="#type-penalty" class="anchor"></a><code><span class="keyword">type</span> penalty</code><code> = int</code></dt><dd><p>penalty on the search space</p></dd></dl><dl><dt class="spec value" id="val-enum_prop"><a href="#val-enum_prop" class="anchor"></a><code><span class="keyword">val</span> enum_prop : <span>?&#8288;mode:<span>[ `And <span>| `Or</span> <span>| `Neg</span> <span>| `Quants</span> <span>| `TF</span> <span>| `Eq</span> <span>| `Combinators</span> <span>| `Full</span> <span>| `Pragmatic</span> <span>| `Simple</span> <span>| `None</span> ]</span></span> <span>&#45;&gt;</span> <span><a href="../Term/index.html#type-var">Term.var</a> <a href="../Scoped/index.html#type-t">Scoped.t</a></span> <span>&#45;&gt;</span> <span>enum_cache:<span><a href="../../Logtk__Term/index.html#module-Set">Logtk.Term.Set</a>.t Stdlib.ref</span></span> <span>&#45;&gt;</span> <span>signature:<a href="../Signature/index.html#type-t">Signature.t</a></span> <span>&#45;&gt;</span> <span>offset:int</span> <span>&#45;&gt;</span> <span><span>(<a href="../Subst/index.html#type-t">Subst.t</a> * <a href="index.html#type-penalty">penalty</a>)</span> list</span></code></dt><dd><p>Given a variable of type <code>τ1…τn -&gt; prop</code>, enumerate possible shapes for it</p><dl><dt>parameter v</dt><dd><p>the variable to refine + its scope. Must return <code>prop</code>.</p></dd></dl><dl><dt>parameter offset</dt><dd><p>to create fresh variables (should be unused elsewhere)</p></dd></dl><dl><dt>parameter mode</dt><dd><p>if <code>`Neg</code>, only tries negation; <code>`None</code>, do nothing; otherwise do all connectives</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-pair"><a href="#type-pair" class="anchor"></a><code><span class="keyword">type</span> pair</code><code> = <span><a href="../Type/index.html#type-t">Type.t</a> list</span> * <a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a></code></dt><dd><p>unification pair</p></dd></dl><dl><dt class="spec value" id="val-pp_pair"><a href="#val-pp_pair" class="anchor"></a><code><span class="keyword">val</span> pp_pair : <span><a href="index.html#type-pair">pair</a> CCFormat.printer</span></code></dt><dt class="spec value" id="val-unif_pairs"><a href="#val-unif_pairs" class="anchor"></a><code><span class="keyword">val</span> unif_pairs : <span>?&#8288;fuel:int</span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-pair">pair</a> list</span> <a href="../Scoped/index.html#type-t">Scoped.t</a></span> <span>&#45;&gt;</span> <span>offset:int</span> <span>&#45;&gt;</span> <span><span>(<span><a href="index.html#type-pair">pair</a> list</span> * <a href="../Unif_subst/index.html#type-t">Unif_subst.t</a> * <a href="index.html#type-penalty">penalty</a> * <a href="../Subst/Renaming/index.html#type-t">Subst.Renaming.t</a>)</span> list</span></code></dt><dd><p><code>unif_pairs pairs ~scope_new_vars</code> returns a list of (partial) solutions to the HO unification problem <code>pairs</code>. Each solution is a list of remaining constraints (with the substitution already applied), a substitution, some penalty to influence the search space, and a renaming used for the substitution</p></dd></dl><dl><dt class="spec value" id="val-default_fuel"><a href="#val-default_fuel" class="anchor"></a><code><span class="keyword">val</span> default_fuel : <span>int Stdlib.ref</span></code></dt><dd><p>Default amount of fuel for <a href="index.html#val-unif_pairs"><code>unif_pairs</code></a></p></dd></dl><dl><dt class="spec value" id="val-enable_norm_subst"><a href="#val-enable_norm_subst" class="anchor"></a><code><span class="keyword">val</span> enable_norm_subst : <span>bool Stdlib.ref</span></code></dt><dd><p>If true, substitutions obtained with <a href="index.html#val-unif_pairs"><code>unif_pairs</code></a> are normalized and β-reduced</p></dd></dl></section></div></body></html>