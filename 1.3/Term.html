<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="InnerTerm.html">
<link rel="next" href="Type.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="InnerTerm" rel="Chapter" href="InnerTerm.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="Util" rel="Chapter" href="Util.html">
<link title="STerm" rel="Chapter" href="STerm.html">
<link title="Interfaces" rel="Chapter" href="Interfaces.html">
<link title="DBEnv" rel="Chapter" href="DBEnv.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="HVar" rel="Chapter" href="HVar.html">
<link title="Defined_pos" rel="Chapter" href="Defined_pos.html">
<link title="Subst" rel="Chapter" href="Subst.html">
<link title="Signature" rel="Chapter" href="Signature.html">
<link title="Scoped" rel="Chapter" href="Scoped.html">
<link title="Unif" rel="Chapter" href="Unif.html">
<link title="Unif_intf" rel="Chapter" href="Unif_intf.html">
<link title="Unif_constr" rel="Chapter" href="Unif_constr.html">
<link title="Unif_subst" rel="Chapter" href="Unif_subst.html">
<link title="HO_unif" rel="Chapter" href="HO_unif.html">
<link title="TypeInference" rel="Chapter" href="TypeInference.html">
<link title="Options" rel="Chapter" href="Options.html">
<link title="Comparison" rel="Chapter" href="Comparison.html">
<link title="Precedence" rel="Chapter" href="Precedence.html">
<link title="Builtin" rel="Chapter" href="Builtin.html">
<link title="Ordering" rel="Chapter" href="Ordering.html">
<link title="Skolem" rel="Chapter" href="Skolem.html">
<link title="Cnf" rel="Chapter" href="Cnf.html">
<link title="ID" rel="Chapter" href="ID.html">
<link title="Head" rel="Chapter" href="Head.html">
<link title="SLiteral" rel="Chapter" href="SLiteral.html">
<link title="Index" rel="Chapter" href="Index.html">
<link title="Index_intf" rel="Chapter" href="Index_intf.html">
<link title="Dtree" rel="Chapter" href="Dtree.html">
<link title="Fingerprint" rel="Chapter" href="Fingerprint.html">
<link title="NPDtree" rel="Chapter" href="NPDtree.html">
<link title="Binder" rel="Chapter" href="Binder.html">
<link title="Congruence" rel="Chapter" href="Congruence.html">
<link title="Congruence_intf" rel="Chapter" href="Congruence_intf.html">
<link title="Lambda" rel="Chapter" href="Lambda.html">
<link title="FeatureVector" rel="Chapter" href="FeatureVector.html">
<link title="FV_tree" rel="Chapter" href="FV_tree.html">
<link title="UntypedAST" rel="Chapter" href="UntypedAST.html">
<link title="Ind_ty" rel="Chapter" href="Ind_ty.html">
<link title="TypedSTerm" rel="Chapter" href="TypedSTerm.html">
<link title="Statement" rel="Chapter" href="Statement.html">
<link title="Flex_state" rel="Chapter" href="Flex_state.html">
<link title="Compute_prec" rel="Chapter" href="Compute_prec.html">
<link title="Ordinal" rel="Chapter" href="Ordinal.html">
<link title="Polynomial" rel="Chapter" href="Polynomial.html">
<link title="Rewrite" rel="Chapter" href="Rewrite.html">
<link title="Test_prop" rel="Chapter" href="Test_prop.html">
<link title="Input_format" rel="Chapter" href="Input_format.html">
<link title="Output_format" rel="Chapter" href="Output_format.html">
<link title="Proof" rel="Chapter" href="Proof.html">
<link title="Multisets" rel="Chapter" href="Multisets.html">
<link title="Literal" rel="Chapter" href="Literal.html">
<link title="Literals" rel="Chapter" href="Literals.html">
<link title="Int_lit" rel="Chapter" href="Int_lit.html">
<link title="Rat_lit" rel="Chapter" href="Rat_lit.html">
<link title="Monome" rel="Chapter" href="Monome.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="ParseLocation" rel="Chapter" href="ParseLocation.html">
<link title="Multiset" rel="Chapter" href="Multiset.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="Hash" rel="Chapter" href="Hash.html">
<link title="IArray" rel="Chapter" href="IArray.html">
<link title="AllocCache" rel="Chapter" href="AllocCache.html">
<link title="Multiset_intf" rel="Chapter" href="Multiset_intf.html">
<link title="Signal" rel="Chapter" href="Signal.html">
<link title="UnionFind" rel="Chapter" href="UnionFind.html"><link title="Term" rel="Section" href="#2_Term">
<link title="Constructors" rel="Section" href="#2_Constructors">
<link title="Sequences" rel="Section" href="#2_Sequences">
<link title="Subterms and Positions" rel="Section" href="#2_SubtermsandPositions">
<link title="High-level operations" rel="Section" href="#2_Highleveloperations">
<link title="Fold" rel="Section" href="#2_Fold">
<link title="Some AC-utils" rel="Section" href="#2_SomeACutils">
<link title="Printing/parsing" rel="Section" href="#2_Printingparsing">
<link title="Formulas" rel="Section" href="#2_Formulas">
<link title="Arith" rel="Section" href="#2_Arith">
<link title="TPTP" rel="Section" href="#2_TPTP">
<title>Term</title>
</head>
<body>
<div class="navbar"><a class="pre" href="InnerTerm.html" title="InnerTerm">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Type.html" title="Type">Next</a>
</div>
<h1>Module <a href="type_Term.html">Term</a></h1>

<pre><span class="keyword">module</span> Term: <code class="code"><span class="keyword">sig</span></code> <a href="Term.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<h1 id="1_LambdafreeTerms">Lambda-free Terms</h1><br>
</div>
<hr width="100%">
<br>
Those terms provide a first-order presentation of higher-order terms (without
    functions), in the sense that they make currying possible (as well as applying
    functions to other terms).
<p>

    This is as if terms had an `apply` symbol everywhere, but more lightweight.
<p>

    Types and terms are mixed because it makes application much easier
    (applying to a type and to a term are the same thing).
    It might also make dependent typing possible some day.<br>
<br>
<h2 id="2_Term">Term</h2><br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = private <code class="type"><a href="InnerTerm.html#TYPEt">InnerTerm.t</a></code> </pre>


<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type"></code>term</span> = <code class="type"><a href="Term.html#TYPEt">t</a></code> </pre>


<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> = <code class="type"><a href="Type.html#TYPEt">Type.t</a> <a href="HVar.html#TYPEt">HVar.t</a></code> </pre>
<div class="info ">
Variables are typed with <a href="Type.html#TYPEt"><code class="code"><span class="constructor">Type</span>.t</code></a><br>
</div>


<pre><code><span id="TYPEview"><span class="keyword">type</span> <code class="type"></code>view</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.AppBuiltin"><span class="constructor">AppBuiltin</span></span> <span class="keyword">of</span> <code class="type"><a href="Builtin.html#TYPEt">Builtin.t</a> * <a href="Term.html#TYPEt">t</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.DB"><span class="constructor">DB</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Bound variable (De Bruijn index)<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.Var"><span class="constructor">Var</span></span> <span class="keyword">of</span> <code class="type"><a href="Term.html#TYPEvar">var</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Term variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.Const"><span class="constructor">Const</span></span> <span class="keyword">of</span> <code class="type"><a href="ID.html#TYPEt">ID.t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Typed constant<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.App"><span class="constructor">App</span></span> <span class="keyword">of</span> <code class="type"><a href="Term.html#TYPEt">t</a> * <a href="Term.html#TYPEt">t</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Application to a list of terms (cannot be left-nested)<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.Fun"><span class="constructor">Fun</span></span> <span class="keyword">of</span> <code class="type"><a href="Type.html#TYPEt">Type.t</a> * <a href="Term.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Lambda abstraction<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="VALview"><span class="keyword">val</span> view</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEview">view</a></code></pre>
<pre><span class="keyword">module</span> <a href="Term.Classic.html">Classic</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Classic.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Classic view
</div>

<pre><span id="VALsubterm"><span class="keyword">val</span> subterm</span> : <code class="type">sub:<a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
checks whether <code class="code">sub</code> is a (non-strict) subterm of <code class="code">t</code><br>
</div>

<pre><span class="keyword">include</span> <a href="Interfaces.HASH.html">Interfaces.HASH</a></pre>

<pre><span class="keyword">include</span> <a href="Interfaces.ORD.html">Interfaces.ORD</a></pre>

<pre><span id="VALty"><span class="keyword">val</span> ty</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a></code></pre><div class="info ">
Obtain the type of a term..<br>
</div>

<pre><span class="keyword">module</span> <a href="Term.Set.html">Set</a>: <code class="type">CCSet.S</code><code class="type">  with type elt = t</code></pre>
<pre><span class="keyword">module</span> <a href="Term.Map.html">Map</a>: <code class="type">CCMap.S</code><code class="type">  with type key = t</code></pre>
<pre><span class="keyword">module</span> <a href="Term.Tbl.html">Tbl</a>: <code class="type">CCHashtbl.S</code><code class="type">  with type key = t</code></pre>
<pre><span id="VALhash_mod_alpha"><span class="keyword">val</span> hash_mod_alpha</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Hash invariant w.r.t variable renaming<br>
</div>

<pre><span id="VALsame_l"><span class="keyword">val</span> same_l</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a> list -> bool</code></pre><div class="info ">
<code class="code">same_l&nbsp;l1&nbsp;l2</code> returns <code class="code"><span class="keyword">true</span></code> if terms of <code class="code">l1</code> and <code class="code">l2</code> are pairwise
    equal, <code class="code"><span class="keyword">false</span></code> otherwise.
    Precondition: both lists have the same length<br>
<b>Raises</b> <code>Assert_failure</code> if lists have not the same length<br>
</div>
<br>
<h2 id="2_Constructors">Constructors</h2><br>

<pre><span id="VALvar"><span class="keyword">val</span> var</span> : <code class="type"><a href="Term.html#TYPEvar">var</a> -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALvar_of_int"><span class="keyword">val</span> var_of_int</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> int -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALbvar"><span class="keyword">val</span> bvar</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> int -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a bound variable. Providing a type is mandatory.
    <b>Warning</b>: be careful and try not to use this function directly.<br>
<b>Raises</b> <code>InnerTerm.IllFormedTerm</code> if the index is &lt; 0<br>
</div>

<pre><span id="VALbuiltin"><span class="keyword">val</span> builtin</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="Builtin.html#TYPEt">Builtin.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALapp_builtin"><span class="keyword">val</span> app_builtin</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="Builtin.html#TYPEt">Builtin.t</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="ID.html#TYPEt">ID.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a typed constant<br>
</div>

<pre><span id="VALtyapp"><span class="keyword">val</span> tyapp</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Apply a term to types<br>
<b>Raises</b> <code>Type.Error</code> if types do not match.<br>
</div>

<pre><span id="VALapp"><span class="keyword">val</span> app</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Apply a term to a list of terms<br>
<b>Raises</b> <code>Type.ApplyError</code> if types do not match.<br>
</div>

<pre><span id="VALapp_full"><span class="keyword">val</span> app_full</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Apply the term to types, then to terms<br>
</div>

<pre><span id="VALtrue_"><span class="keyword">val</span> true_</span> : <code class="type"><a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALfalse_"><span class="keyword">val</span> false_</span> : <code class="type"><a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALfun_"><span class="keyword">val</span> fun_</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALfun_l"><span class="keyword">val</span> fun_l</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALfun_of_fvars"><span class="keyword">val</span> fun_of_fvars</span> : <code class="type"><a href="Term.html#TYPEvar">var</a> list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Build a function from a list of free vars + the body.
    This performs the De Bruijn transformation, and shifts the body.<br>
</div>

<pre><span id="VALopen_fun"><span class="keyword">val</span> open_fun</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list * <a href="Term.html#TYPEt">t</a></code></pre>
<pre><span id="VALopen_fun_offset"><span class="keyword">val</span> open_fun_offset</span> : <code class="type">offset:int -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEvar">var</a> list * <a href="Term.html#TYPEt">t</a> * int</code></pre><div class="info ">
<code class="code">open_fun ~offset (λxy. F)</code> returns <code class="code">[v1,v2],&nbsp;<span class="constructor">F</span>[v1/x,v2/y],&nbsp;offset+2</code>
    where <code class="code">v1</code> and <code class="code">v2</code> are fresh variables starting from offset<br>
</div>

<pre><span id="VALgrounding"><span class="keyword">val</span> grounding</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">grounding&nbsp;ty</code> is a unique constant of type <code class="code">ty</code><br>
</div>

<pre><span id="VALis_var"><span class="keyword">val</span> is_var</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_bvar"><span class="keyword">val</span> is_bvar</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_app"><span class="keyword">val</span> is_app</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_const"><span class="keyword">val</span> is_const</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_fun"><span class="keyword">val</span> is_fun</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_type"><span class="keyword">val</span> is_type</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Does it have type <code class="code">tType</code>?<br>
</div>

<pre><span id="VALas_const"><span class="keyword">val</span> as_const</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a> option</code></pre>
<pre><span id="VALas_const_exn"><span class="keyword">val</span> as_const_exn</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a></code></pre>
<pre><span id="VALas_var"><span class="keyword">val</span> as_var</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEvar">var</a> option</code></pre>
<pre><span id="VALas_var_exn"><span class="keyword">val</span> as_var_exn</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEvar">var</a></code></pre>
<pre><span id="VALas_app"><span class="keyword">val</span> as_app</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> * <a href="Term.html#TYPEt">t</a> list</code></pre><div class="info ">
<code class="code">as_app&nbsp;t</code> decomposes <code class="code">t</code> into a head (non-application) and arguments,
    such as <code class="code">(<span class="keyword">let</span>&nbsp;f,l&nbsp;=&nbsp;as_app&nbsp;t&nbsp;<span class="keyword">in</span>&nbsp;app&nbsp;f&nbsp;l)&nbsp;=&nbsp;t</code><br>
</div>

<pre><span id="VALas_fun"><span class="keyword">val</span> as_fun</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list * <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Open functions<br>
</div>

<pre><span id="VALhead_term"><span class="keyword">val</span> head_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">head_term&nbsp;t&nbsp;=&nbsp;fst&nbsp;(as_app&nbsp;t)</code><br>
</div>

<pre><span id="VALhead_term_mono"><span class="keyword">val</span> head_term_mono</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
head term, but still with type arguments<br>
</div>

<pre><span id="VALargs"><span class="keyword">val</span> args</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> list</code></pre><div class="info ">
<code class="code">args&nbsp;t&nbsp;=&nbsp;snd&nbsp;(as_app&nbsp;t)</code><br>
</div>

<pre><span id="VALof_term_unsafe"><span class="keyword">val</span> of_term_unsafe</span> : <code class="type"><a href="InnerTerm.html#TYPEt">InnerTerm.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
<b>NOTE</b>: this can break the invariants and make <a href="Term.html#VALview"><code class="code"><span class="constructor">Term</span>.view</code></a> fail. Only
    apply with caution.<br>
</div>

<pre><span id="VALof_term_unsafe_l"><span class="keyword">val</span> of_term_unsafe_l</span> : <code class="type"><a href="InnerTerm.html#TYPEt">InnerTerm.t</a> list -> <a href="Term.html#TYPEt">t</a> list</code></pre>
<pre><span id="VALof_ty"><span class="keyword">val</span> of_ty</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Upcast from type<br>
</div>

<pre><span class="keyword">module</span> <a href="Term.VarSet.html">VarSet</a>: <code class="type">CCSet.S</code><code class="type">  with type elt = var</code></pre>
<pre><span class="keyword">module</span> <a href="Term.VarMap.html">VarMap</a>: <code class="type">CCMap.S</code><code class="type">  with type key = var</code></pre>
<pre><span class="keyword">module</span> <a href="Term.VarTbl.html">VarTbl</a>: <code class="type">CCHashtbl.S</code><code class="type">  with type key = var</code></pre><br>
<h2 id="2_Sequences">Sequences</h2><br>

<pre><span class="keyword">module</span> <a href="Term.Seq.html">Seq</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Seq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALvar_occurs"><span class="keyword">val</span> var_occurs</span> : <code class="type">var:<a href="Term.html#TYPEvar">var</a> -> <a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">var_occurs&nbsp;~var&nbsp;t</code> true iff <code class="code">var</code> in t<br>
</div>

<pre><span id="VALis_ground"><span class="keyword">val</span> is_ground</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
is the term ground? (no free vars)<br>
</div>

<pre><span id="VALmonomorphic"><span class="keyword">val</span> monomorphic</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
true if the term contains no type var<br>
</div>

<pre><span id="VALmax_var"><span class="keyword">val</span> max_var</span> : <code class="type">VarSet.t -> int</code></pre><div class="info ">
find the maximum variable<br>
</div>

<pre><span id="VALmin_var"><span class="keyword">val</span> min_var</span> : <code class="type">VarSet.t -> int</code></pre><div class="info ">
minimum variable<br>
</div>

<pre><span id="VALadd_vars"><span class="keyword">val</span> add_vars</span> : <code class="type">unit VarTbl.t -> <a href="Term.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
add variables of the term to the set<br>
</div>

<pre><span id="VALvars"><span class="keyword">val</span> vars</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> VarSet.t</code></pre><div class="info ">
compute variables of the terms<br>
</div>

<pre><span id="VALvars_prefix_order"><span class="keyword">val</span> vars_prefix_order</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEvar">var</a> list</code></pre><div class="info ">
variables in prefix traversal order<br>
</div>

<pre><span id="VALdepth"><span class="keyword">val</span> depth</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
depth of the term<br>
</div>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a> option</code></pre><div class="info ">
head ID.t<br>
</div>

<pre><span id="VALhead_exn"><span class="keyword">val</span> head_exn</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a></code></pre><div class="info ">
head ID.t (or Invalid_argument)<br>
</div>

<pre><span id="VALsize"><span class="keyword">val</span> size</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Size (number of nodes)<br>
</div>

<pre><span id="VALweight"><span class="keyword">val</span> weight</span> : <code class="type">?var:int -> ?sym:(<a href="ID.html#TYPEt">ID.t</a> -> int) -> <a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Compute the weight of a term, given a weight for variables
    and one for ID.ts.<br>
<b>Since</b> 0.5.3<br>
</div>
<div class="param_info"><code class="code">var</code> : unique weight for every variable (default 1)</div>
<div class="param_info"><code class="code">sym</code> : function from ID.ts to their weight (default <code class="code">const&nbsp;1</code>)</div>

<pre><span id="VALty_vars"><span class="keyword">val</span> ty_vars</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> Type.VarSet.t</code></pre><div class="info ">
Set of free type variables<br>
</div>

<pre><span id="VALis_ho_var"><span class="keyword">val</span> is_ho_var</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_ho_app"><span class="keyword">val</span> is_ho_app</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_ho_app (F t1…tn)</code> is true, when <code class="code"><span class="constructor">F</span></code> is a variable (of any function type)<br>
</div>

<pre><span id="VALas_ho_app"><span class="keyword">val</span> as_ho_app</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> (<a href="Type.html#TYPEt">Type.t</a> <a href="HVar.html#TYPEt">HVar.t</a> * <a href="Term.html#TYPEt">t</a> list) option</code></pre><div class="info ">
<code class="code">as_ho_app (F t1…tn) = Some (F, [t1…tn])</code><br>
</div>

<pre><span id="VALis_ho_pred"><span class="keyword">val</span> is_ho_pred</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_ho_pred (F t1…tn)</code> is true, when <code class="code"><span class="constructor">F</span></code> is a predicate variable<br>
</div>

<pre><span id="VALis_ho_at_root"><span class="keyword">val</span> is_ho_at_root</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_ho_at_root&nbsp;t</code> returns <code class="code"><span class="keyword">true</span></code> if the term <code class="code">t</code> is a higher-order variable,
    possibly applied (i.e. <code class="code">is_ho_var&nbsp;t&nbsp;<span class="keywordsign">||</span>&nbsp;is_ho_app&nbsp;t</code>)<br>
</div>
<br>
<h2 id="2_SubtermsandPositions">Subterms and Positions</h2><br>

<pre><span class="keyword">module</span> <a href="Term.Pos.html">Pos</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Pos.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALreplace"><span class="keyword">val</span> replace</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> old:<a href="Term.html#TYPEt">t</a> -> by:<a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">replace&nbsp;t&nbsp;~old&nbsp;~by</code> syntactically replaces all occurrences of <code class="code">old</code>
    in <code class="code">t</code> by the term <code class="code">by</code>.<br>
</div>

<pre><span id="VALreplace_m"><span class="keyword">val</span> replace_m</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> Map.t -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">replace&nbsp;t&nbsp;m</code> syntactically replaces all occurrences of bindings of
    the map in <code class="code">t</code>, starting from the root<br>
</div>
<br>
<h2 id="2_Highleveloperations">High-level operations</h2><br>

<pre><span id="VALsymbols"><span class="keyword">val</span> symbols</span> : <code class="type">?init:ID.Set.t -> <a href="Term.html#TYPEt">t</a> -> ID.Set.t</code></pre><div class="info ">
Symbols of the term (keys of signature)<br>
</div>

<pre><span id="VALcontains_symbol"><span class="keyword">val</span> contains_symbol</span> : <code class="type"><a href="ID.html#TYPEt">ID.t</a> -> <a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Does the term contain this given ID.t?<br>
</div>
<br>
<h2 id="2_Fold">Fold</h2><br>
<br>
High level fold-like combinators<br>

<pre><span id="VALall_positions"><span class="keyword">val</span> all_positions</span> : <code class="type">?vars:bool -><br>       ?ty_args:bool -><br>       ?pos:<a href="Position.html#TYPEt">Position.t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> <a href="Position.With.html#TYPEt">Position.With.t</a> Sequence.t</code></pre><div class="info ">
Iterate on all sub-terms with their position.<br>
</div>
<div class="param_info"><code class="code">vars</code> : specifies whether variables are folded on (default false).</div>
<div class="param_info"><code class="code">ty_args</code> : specifies whether type arguments are folded on (default true).</div>
<div class="param_info"><code class="code">pos</code> : the initial position (default empty)</div>
<br>
<h2 id="2_SomeACutils">Some AC-utils</h2><br>

<pre><span class="keyword">module type</span> <a href="Term.AC_SPEC.html">AC_SPEC</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Term.AC_SPEC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Term.AC.html">AC</a> <code class="code">(</code><code class="code"><span class="constructor">A</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Term.AC_SPEC.html">AC_SPEC</a></code><code class="code">)&nbsp;</code>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.AC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Printingparsing">Printing/parsing</h2><br>

<pre><span id="VALprint_all_types"><span class="keyword">val</span> print_all_types</span> : <code class="type">bool Pervasives.ref</code></pre><div class="info ">
If true, <code class="code">pp</code> will print the types of all annotated terms<br>
</div>

<pre><span class="keyword">include</span> <a href="Interfaces.PRINT.html">Interfaces.PRINT</a></pre>

<pre><span class="keyword">include</span> <a href="Interfaces.PRINT_DE_BRUIJN.html">Interfaces.PRINT_DE_BRUIJN</a></pre>

<pre><span id="VALpp_var"><span class="keyword">val</span> pp_var</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> <a href="HVar.html#TYPEt">HVar.t</a> CCFormat.printer</code></pre>
<pre><span id="VALadd_hook"><span class="keyword">val</span> add_hook</span> : <code class="type">print_hook -> unit</code></pre><div class="info ">
Hook used by default for printing<br>
</div>

<pre><span id="VALdefault_hooks"><span class="keyword">val</span> default_hooks</span> : <code class="type">unit -> print_hook list</code></pre><div class="info ">
List of default hooks<br>
</div>

<pre><span id="VALdebugf"><span class="keyword">val</span> debugf</span> : <code class="type">Format.formatter -> <a href="Term.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
debugf printing, with sorts<br>
</div>
<br>
<h2 id="2_Formulas">Formulas</h2><br>

<pre><span class="keyword">module</span> <a href="Term.Form.html">Form</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Form.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Arith">Arith</h2><br>

<pre><span class="keyword">module</span> <a href="Term.Arith.html">Arith</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Arith.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Term.DB.html">DB</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.DB.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
De Bruijn
</div>
<br>
<h2 id="2_TPTP">TPTP</h2><br>

<pre><span class="keyword">module</span> <a href="Term.TPTP.html">TPTP</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.TPTP.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Term.ZF.html">ZF</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.ZF.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALpp_in"><span class="keyword">val</span> pp_in</span> : <code class="type"><a href="Output_format.html#TYPEt">Output_format.t</a> -> <a href="Term.html#TYPEt">t</a> CCFormat.printer</code></pre>
<pre><span class="keyword">module</span> <a href="Term.Conv.html">Conv</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Conv.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>