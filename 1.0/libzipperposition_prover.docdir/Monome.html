<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Env.html">
<link rel="next" href="ArithLit.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="ClauseQueue" rel="Chapter" href="ClauseQueue.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="SClause" rel="Chapter" href="SClause.html">
<link title="Const" rel="Chapter" href="Const.html">
<link title="Extensions" rel="Chapter" href="Extensions.html">
<link title="Literal" rel="Chapter" href="Literal.html">
<link title="Literals" rel="Chapter" href="Literals.html">
<link title="Ctx" rel="Chapter" href="Ctx.html">
<link title="ProofStep" rel="Chapter" href="ProofStep.html">
<link title="ProofPrint" rel="Chapter" href="ProofPrint.html">
<link title="ProofState" rel="Chapter" href="ProofState.html">
<link title="Saturate" rel="Chapter" href="Saturate.html">
<link title="Selection" rel="Chapter" href="Selection.html">
<link title="AC" rel="Chapter" href="AC.html">
<link title="AC_intf" rel="Chapter" href="AC_intf.html">
<link title="SimplM" rel="Chapter" href="SimplM.html">
<link title="Compute_prec" rel="Chapter" href="Compute_prec.html">
<link title="Params" rel="Chapter" href="Params.html">
<link title="Env" rel="Chapter" href="Env.html">
<link title="Monome" rel="Chapter" href="Monome.html">
<link title="ArithLit" rel="Chapter" href="ArithLit.html">
<link title="Signals" rel="Chapter" href="Signals.html">
<link title="Multisets" rel="Chapter" href="Multisets.html">
<link title="Ctx_intf" rel="Chapter" href="Ctx_intf.html">
<link title="Clause_intf" rel="Chapter" href="Clause_intf.html">
<link title="Env_intf" rel="Chapter" href="Env_intf.html">
<link title="ProofState_intf" rel="Chapter" href="ProofState_intf.html">
<link title="BBox" rel="Chapter" href="BBox.html">
<link title="ClauseContext" rel="Chapter" href="ClauseContext.html">
<link title="ClauseQueue_intf" rel="Chapter" href="ClauseQueue_intf.html">
<link title="Bool_lit" rel="Chapter" href="Bool_lit.html">
<link title="Bool_lit_intf" rel="Chapter" href="Bool_lit_intf.html">
<link title="Sat_solver" rel="Chapter" href="Sat_solver.html">
<link title="Sat_solver_intf" rel="Chapter" href="Sat_solver_intf.html">
<link title="Trail" rel="Chapter" href="Trail.html">
<link title="Ind_cst" rel="Chapter" href="Ind_cst.html">
<link title="Phases" rel="Chapter" href="Phases.html">
<link title="Phases_impl" rel="Chapter" href="Phases_impl.html">
<link title="Flex_state" rel="Chapter" href="Flex_state.html">
<link title="Classify_cst" rel="Chapter" href="Classify_cst.html">
<link title="Rewrite_rule" rel="Chapter" href="Rewrite_rule.html">
<link title="Avatar" rel="Chapter" href="Avatar.html">
<link title="Avatar_intf" rel="Chapter" href="Avatar_intf.html">
<link title="Induction" rel="Chapter" href="Induction.html">
<link title="Induction_intf" rel="Chapter" href="Induction_intf.html">
<link title="Superposition" rel="Chapter" href="Superposition.html">
<link title="Rewriting" rel="Chapter" href="Rewriting.html">
<link title="EnumTypes" rel="Chapter" href="EnumTypes.html">
<link title="ArithInt" rel="Chapter" href="ArithInt.html">
<link title="Heuristics" rel="Chapter" href="Heuristics.html">
<link title="Ind_types" rel="Chapter" href="Ind_types.html">
<link title="MetaProverState" rel="Chapter" href="MetaProverState.html">
<link title="MetaProverState_intf" rel="Chapter" href="MetaProverState_intf.html"><link title="For fields (Q,R)" rel="Section" href="#2_ForfieldsQR">
<title>Monome</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Env.html" title="Env">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="ArithLit.html" title="ArithLit">Next</a>
</div>
<h1>Module <a href="type_Monome.html">Monome</a></h1>

<pre><span class="keyword">module</span> Monome: <code class="code">sig</code> <a href="Monome.html">..</a> <code class="code">end</code></pre><div class="info module top">
<h1 id="1_Polynomesoforder1overseveralvariables">Polynomes of order 1, over several variables</h1>.
<p>

    Variables, in this module, are non-arithmetic terms, i.e. non-interpreted
    functions and predicates, that occur immediately under an arithmetic
    operator. For instance, in the term "f(X) + 1 + 3 Ã— a", the variables
    are "f(X)" and "a", with coefficients "1" and "3".<br>
</div>
<hr width="100%">

<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type"></code>term</span> = <code class="type">Libzipperposition.FOTerm.t</code> </pre>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>
<div class="info ">
A monome over terms, with coefficient of type 'a<br>
</div>


<pre><span id="TYPEmonome"><span class="keyword">type</span> <code class="type">'a</code> monome</span> = <code class="type">'a <a href="Monome.html#TYPEt">t</a></code> </pre>


<pre><span id="VALeq"><span class="keyword">val</span> eq</span> : <code class="type">'n <a href="Monome.html#TYPEt">t</a> -> 'n <a href="Monome.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type">'n <a href="Monome.html#TYPEt">t</a> -> 'n <a href="Monome.html#TYPEt">t</a> -> int</code></pre>
<pre><span id="VALhash"><span class="keyword">val</span> hash</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int</code></pre>
<pre><span id="VALhash_fun"><span class="keyword">val</span> hash_fun</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> CCHash.hash_fun</code></pre>
<pre><span id="VALty"><span class="keyword">val</span> ty</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> Libzipperposition.Type.t</code></pre><div class="info ">
type of the monome (int or rat)<br>
</div>

<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
constant<br>
</div>

<pre><span id="VALcoeffs"><span class="keyword">val</span> coeffs</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> ('a * <a href="Monome.html#TYPEterm">term</a>) list</code></pre><div class="info ">
coefficients<br>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> <a href="Monome.html#TYPEterm">term</a> -> 'a option</code></pre>
<pre><span id="VALfind_exn"><span class="keyword">val</span> find_exn</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> <a href="Monome.html#TYPEterm">term</a> -> 'a</code></pre><div class="info ">
<b>Raises</b> <code>Not_found</code> if not present<br>
</div>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> <a href="Monome.html#TYPEterm">term</a> -> bool</code></pre><div class="info ">
Is the term in the monome?<br>
</div>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a -> <a href="Monome.html#TYPEterm">term</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Add term with coefficient. Sums coeffs.<br>
</div>

<pre><span id="VALadd_const"><span class="keyword">val</span> add_const</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Add given number to constant<br>
</div>

<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> <a href="Monome.html#TYPEterm">term</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Remove the term<br>
</div>

<pre><span id="VALremove_const"><span class="keyword">val</span> remove_const</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Remove the constant<br>
</div>

<pre><span id="VALadd_list"><span class="keyword">val</span> add_list</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> ('a * <a href="Monome.html#TYPEterm">term</a>) list -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="Monome.html#TYPEterm">term</a> -> <a href="Monome.html#TYPEterm">term</a>) -> 'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span id="VALmap_num"><span class="keyword">val</span> map_num</span> : <code class="type">('a -> 'a) -> 'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span class="keyword">module</span> <a href="Monome.Seq.html">Seq</a>: <code class="code">sig</code> <a href="Monome.Seq.html">..</a> <code class="code">end</code></pre>
<pre><span id="VALis_const"><span class="keyword">val</span> is_const</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Returns <code class="code">true</code> if the monome is only a constant<br>
</div>

<pre><span id="VALis_zero"><span class="keyword">val</span> is_zero</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
return <code class="code">true</code> if the monome is the constant 0<br>
</div>

<pre><span id="VALsign"><span class="keyword">val</span> sign</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Assuming <code class="code">is_constant m</code>, <code class="code">sign m</code> returns the sign of <code class="code">m</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> if the monome is not a constant<br>
</div>

<pre><span id="VALsize"><span class="keyword">val</span> size</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Number of distinct terms. 0 means that the monome is a constant<br>
</div>

<pre><span id="VALterms"><span class="keyword">val</span> terms</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> <a href="Monome.html#TYPEterm">term</a> list</code></pre><div class="info ">
List of terms that occur in the monome with non-nul coefficients<br>
</div>

<pre><span id="VALvar_occurs"><span class="keyword">val</span> var_occurs</span> : <code class="type">var:Libzipperposition.FOTerm.var -> 'a <a href="Monome.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Does the variable occur in the monome?<br>
</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span id="VALdifference"><span class="keyword">val</span> difference</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span id="VALuminus"><span class="keyword">val</span> uminus</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre>
<pre><span id="VALproduct"><span class="keyword">val</span> product</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Product with constant<br>
</div>

<pre><span id="VALsucc"><span class="keyword">val</span> succ</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
+1<br>
</div>

<pre><span id="VALpred"><span class="keyword">val</span> pred</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
-1<br>
</div>

<pre><span id="VALsum_list"><span class="keyword">val</span> sum_list</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> list -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Sum of a list.<br>
<b>Raises</b> <code>Failure</code> if the list is empty<br>
</div>

<pre><span id="VALcomparison"><span class="keyword">val</span> comparison</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a> -> Libzipperposition.Comparison.t</code></pre><div class="info ">
Try to compare two monomes. They may not be comparable (ie on some
    points, or in some models, one will be bigger), but some pairs of
    monomes are:
    for instance, 2X + 1 &lt; 2X + 4  is always true<br>
</div>

<pre><span id="VALdominates"><span class="keyword">val</span> dominates</span> : <code class="type">strict:bool -> 'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">dominates ~strict m1 m2</code> is true if <code class="code">m1</code> is always greater than
    <code class="code">m2</code>, in any model or variable valuation.
    if <code class="code">dominates ~strict:false m1 m2 &amp;&amp; dominates ~strict:false m2 m1</code>,
    then <code class="code">m1 = m2</code>.<br>
</div>

<pre><span id="VALsplit"><span class="keyword">val</span> split</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> 'a <a href="Monome.html#TYPEt">t</a> * 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">split m</code> splits into a monome with positive coefficients, and one
    with negative coefficients.<br>
<b>Returns</b> <code class="code">m1, m2</code> such that <code class="code">m = m1 - m2</code> and <code class="code">m1,m2</code> both have positive
      coefficients<br>
</div>

<pre><span id="VALapply_subst"><span class="keyword">val</span> apply_subst</span> : <code class="type">renaming:Libzipperposition.Substs.Renaming.t -><br>       Libzipperposition.Substs.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Apply a substitution to the monome's terms<br>
</div>

<pre><span id="VALapply_subst_no_renaming"><span class="keyword">val</span> apply_subst_no_renaming</span> : <code class="type">Libzipperposition.Substs.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
Apply a substitution but doesn't rename free variables. Careful
    with the collisions<br>
</div>

<pre><span id="VALvariant"><span class="keyword">val</span> variant</span> : <code class="type">?subst:Libzipperposition.Substs.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       Libzipperposition.Substs.t Sequence.t</code></pre><br>
Matching and unification aren't complete in the presence of variables
    occurring directly under the sum, for this would require the variable
    to be bound to sums (monomes) itself in the general case.
    Instead, such variables are only bound to atomic terms, excluding
    constants (ie X+1 = a+1 will bind X to a without problem, but
    will X+a=a+1 will fail to bind X to 1)<br>

<pre><span id="VALmatching"><span class="keyword">val</span> matching</span> : <code class="type">?subst:Libzipperposition.Substs.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       Libzipperposition.Substs.t Sequence.t</code></pre>
<pre><span id="VALunify"><span class="keyword">val</span> unify</span> : <code class="type">?subst:Libzipperposition.Substs.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       'a <a href="Monome.html#TYPEt">t</a> Libzipperposition.Scoped.t -><br>       Libzipperposition.Substs.t Sequence.t</code></pre>
<pre><span id="VALis_ground"><span class="keyword">val</span> is_ground</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Are there no variables in the monome?<br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> int -> 'b -> <a href="Monome.html#TYPEterm">term</a> -> 'a) -> 'a -> 'b <a href="Monome.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Fold over terms<br>
</div>

<pre><span id="VALfold_max"><span class="keyword">val</span> fold_max</span> : <code class="type">ord:Libzipperposition.Ordering.t -><br>       ('a -> int -> 'b -> <a href="Monome.html#TYPEterm">term</a> -> 'a) -> 'a -> 'b <a href="Monome.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Fold over terms that are maximal in the given ordering.<br>
</div>

<pre><span id="VALnth"><span class="keyword">val</span> nth</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int -> 'a * <a href="Monome.html#TYPEterm">term</a></code></pre><div class="info ">
<b>Raises</b> <code>Invalid_argument</code> if the index is invalid<br>
</div>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int -> 'a * <a href="Monome.html#TYPEterm">term</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
<b>Raises</b> <code>Invalid_argument</code> if the index is invalid<br>
</div>

<pre><span id="VALset_term"><span class="keyword">val</span> set_term</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> int -> <a href="Monome.html#TYPEterm">term</a> -> 'a <a href="Monome.html#TYPEt">t</a></code></pre><div class="info ">
<b>Raises</b> <code>Invalid_argument</code> if the index is invalid<br>
</div>

<pre><span class="keyword">module</span> <a href="Monome.Focus.html">Focus</a>: <code class="code">sig</code> <a href="Monome.Focus.html">..</a> <code class="code">end</code></pre><div class="info">
Focus on a specific term
</div>

<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> CCFormat.printer</code></pre>
<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALpp_tstp"><span class="keyword">val</span> pp_tstp</span> : <code class="type">'a <a href="Monome.html#TYPEt">t</a> CCFormat.printer</code></pre>
<pre><span id="EXCEPTIONNotLinear"><span class="keyword">exception</span> NotLinear</span></pre>

<pre><span class="keyword">module</span> <a href="Monome.Int.html">Int</a>: <code class="code">sig</code> <a href="Monome.Int.html">..</a> <code class="code">end</code></pre><br>
<h2 id="2_ForfieldsQR">For fields (Q,R)</h2><br>
</body></html>