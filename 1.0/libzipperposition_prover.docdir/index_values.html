<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="ClauseQueue" rel="Chapter" href="ClauseQueue.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="SClause" rel="Chapter" href="SClause.html">
<link title="Const" rel="Chapter" href="Const.html">
<link title="Extensions" rel="Chapter" href="Extensions.html">
<link title="Literal" rel="Chapter" href="Literal.html">
<link title="Literals" rel="Chapter" href="Literals.html">
<link title="Ctx" rel="Chapter" href="Ctx.html">
<link title="ProofStep" rel="Chapter" href="ProofStep.html">
<link title="ProofPrint" rel="Chapter" href="ProofPrint.html">
<link title="ProofState" rel="Chapter" href="ProofState.html">
<link title="Saturate" rel="Chapter" href="Saturate.html">
<link title="Selection" rel="Chapter" href="Selection.html">
<link title="AC" rel="Chapter" href="AC.html">
<link title="AC_intf" rel="Chapter" href="AC_intf.html">
<link title="SimplM" rel="Chapter" href="SimplM.html">
<link title="Compute_prec" rel="Chapter" href="Compute_prec.html">
<link title="Params" rel="Chapter" href="Params.html">
<link title="Env" rel="Chapter" href="Env.html">
<link title="Monome" rel="Chapter" href="Monome.html">
<link title="ArithLit" rel="Chapter" href="ArithLit.html">
<link title="Signals" rel="Chapter" href="Signals.html">
<link title="Multisets" rel="Chapter" href="Multisets.html">
<link title="Ctx_intf" rel="Chapter" href="Ctx_intf.html">
<link title="Clause_intf" rel="Chapter" href="Clause_intf.html">
<link title="Env_intf" rel="Chapter" href="Env_intf.html">
<link title="ProofState_intf" rel="Chapter" href="ProofState_intf.html">
<link title="BBox" rel="Chapter" href="BBox.html">
<link title="ClauseContext" rel="Chapter" href="ClauseContext.html">
<link title="ClauseQueue_intf" rel="Chapter" href="ClauseQueue_intf.html">
<link title="Bool_lit" rel="Chapter" href="Bool_lit.html">
<link title="Bool_lit_intf" rel="Chapter" href="Bool_lit_intf.html">
<link title="Sat_solver" rel="Chapter" href="Sat_solver.html">
<link title="Sat_solver_intf" rel="Chapter" href="Sat_solver_intf.html">
<link title="Trail" rel="Chapter" href="Trail.html">
<link title="Ind_cst" rel="Chapter" href="Ind_cst.html">
<link title="Phases" rel="Chapter" href="Phases.html">
<link title="Phases_impl" rel="Chapter" href="Phases_impl.html">
<link title="Flex_state" rel="Chapter" href="Flex_state.html">
<link title="Classify_cst" rel="Chapter" href="Classify_cst.html">
<link title="Rewrite_rule" rel="Chapter" href="Rewrite_rule.html">
<link title="Avatar" rel="Chapter" href="Avatar.html">
<link title="Avatar_intf" rel="Chapter" href="Avatar_intf.html">
<link title="Induction" rel="Chapter" href="Induction.html">
<link title="Induction_intf" rel="Chapter" href="Induction_intf.html">
<link title="Superposition" rel="Chapter" href="Superposition.html">
<link title="Rewriting" rel="Chapter" href="Rewriting.html">
<link title="EnumTypes" rel="Chapter" href="EnumTypes.html">
<link title="ArithInt" rel="Chapter" href="ArithInt.html">
<link title="Heuristics" rel="Chapter" href="Heuristics.html">
<link title="Ind_types" rel="Chapter" href="Ind_types.html">
<link title="MetaProverState" rel="Chapter" href="MetaProverState.html">
<link title="MetaProverState_intf" rel="Chapter" href="MetaProverState_intf.html"><title>Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL( ** )">( ** )</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "and"
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL(++)">(++)</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "or"
</div>
</td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.Infix.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="SimplM.Infix.html">SimplM.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="SimplM.html">SimplM</a>]</td>
<td><div class="info">
Monadic bind
</div>
</td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>>?=)">(&gt;&gt;?=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>|=)">(&gt;|=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.Infix.html#VAL(>|=)">(&gt;|=)</a> [<a href="SimplM.Infix.html">SimplM.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL(~~)">(~~)</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "not"
</div>
</td></tr>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALabs">abs</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Literal without its sign
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALadapt_c">adapt_c</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALadapt_f">adapt_f</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Flex_state.html#VALadd">add</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALadd">add</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALadd">add</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Add term with coefficient.
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALadd">add</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Declare that the given symbol is AC, and update the Env subsequently
      by adding clauses, etc.
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALadd">add</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
Add clauses to the set
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALadd">add</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Add a clause to the Queue
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_active">add_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add active clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_active_simplify">add_active_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification w.r.t active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_backward_redundant">add_backward_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add rule that finds redundant clauses within active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_backward_simplify">add_backward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification of the active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_binary_inf">add_binary_inf</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a binary inference rule
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clause">add_clause</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
<code class="code">add_clause ~tag ~proof c</code> adds the constraint <code class="code">c</code> to the SAT solver,
      annotated with <code class="code">proof</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_clause_conversion">add_clause_conversion</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clause_seq">add_clause_seq</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clauses">add_clauses</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALadd_const">add_const</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Add given number to constant
</div>
</td></tr>
<tr><td><a href="Compute_prec.html#VALadd_constr">add_constr</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td><div class="info">
Add a precedence constraint with its priority.
</div>
</td></tr>
<tr><td><a href="Compute_prec.html#VALadd_constr_rule">add_constr_rule</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td><div class="info">
Add a precedence constraint rule
</div>
</td></tr>
<tr><td><a href="Compute_prec.html#VALadd_constrs">add_constrs</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALadd_default_hook">add_default_hook</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALadd_from_hook">add_from_hook</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_generate">add_generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_is_trivial">add_is_trivial</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add tautology detection rule
</div>
</td></tr>
<tr><td><a href="Trail.html#VALadd_list">add_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALadd_list">add_list</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_lit_rule">add_lit_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a literal rewrite rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_multi_simpl_rule">add_multi_simpl_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a multi-clause simplification rule
</div>
</td></tr>
<tr><td><a href="Params.html#VALadd_opt">add_opt</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALadd_opts">add_opts</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_passive">add_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add passive clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_redundant">add_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add redundancy criterion w.r.t.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_rewrite_rule">add_rewrite_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a term rewrite rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_rw_simplify">add_rw_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add forward rewriting rule
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALadd_signature">add_signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Merge  the given signature with the context's one
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_simpl">add_simpl</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_simplify">add_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add basic simplification rule
</div>
</td></tr>
<tr><td><a href="Compute_prec.html#VALadd_status">add_status</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td><div class="info">
Specify explicitely the status of some symbols
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_step_init">add_step_init</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
add a function to call before each saturation step
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.Set.html#VALadd_stmt">add_stmt</a> [<a href="Rewrite_rule.Set.html">Rewrite_rule.Set</a>]</td>
<td><div class="info">
<code class="code">add_stmt st set</code> adds rewrite rules from <code class="code">st</code> to <code class="code">set</code>, if any
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALadd_to_hook">add_to_hook</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_unary_inf">add_unary_inf</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a unary inference rule
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALadds">adds</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Add clauses to the queue
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALafter_check_sat">after_check_sat</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALage">age</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Returns the age of the clause (or 0 for the empty clause)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALall_simplify">all_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Use all simplification rules to convert a clause into a set
      of maximally simplified clause (or <code class="code">[]</code> if they are all trivial).
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALalways">always</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
All literals
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALapp_list">app_list</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALapply">apply</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
<code class="code">apply c t</code> fills the hole of <code class="code">c</code> with the given term <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALapply_same_scope">apply_same_scope</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Same as <a href="ClauseContext.html#VALapply"><code class="code">ClauseContext.apply</code></a>, but now variables from the context and variables
    from the term live in the same scope
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALapply_sign">apply_sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
<code class="code">apply_sign s lit</code> is <code class="code">lit</code> if <code class="code">s</code>, <code class="code">neg lit</code> otherwise
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALapply_subst">apply_subst</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Apply a substitution
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALapply_subst">apply_subst</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALapply_subst">apply_subst</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Apply a substitution.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALapply_subst">apply_subst</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Apply a substitution to the monome's terms
</div>
</td></tr>
<tr><td><a href="Literals.html#VALapply_subst">apply_subst</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALapply_subst">apply_subst</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALapply_subst">apply_subst</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
apply the substitution to the clause
</div>
</td></tr>
<tr><td><a href="Literal.html#VALapply_subst_list">apply_subst_list</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALapply_subst_no_renaming">apply_subst_no_renaming</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Apply a substitution with renaming (careful with collisions!)
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALapply_subst_no_renaming">apply_subst_no_renaming</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALapply_subst_no_renaming">apply_subst_no_renaming</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Apply a substitution but doesn't rename free variables.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALapply_subst_no_renaming">apply_subst_no_renaming</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Apply a substitution but doesn't rename free variables.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALapply_subst_no_renaming">apply_subst_no_renaming</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALapply_subst_no_simp">apply_subst_no_simp</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Same as <a href="ArithLit.html#VALapply_subst"><code class="code">ArithLit.apply_subst</code></a> but takes care  simplifying the
    literal.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALapply_subst_no_simp">apply_subst_no_simp</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALare_variant">are_variant</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALare_variant">are_variant</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Simple interface on top of <a href="Literals.html#VALvariant"><code class="code">Literals.variant</code></a> with distinc scopes
</div>
</td></tr>
<tr><td><a href="Literal.html#VALare_variant">are_variant</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALarith">arith</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Conv.html#VALarith_hook_from">arith_hook_from</a> [<a href="Literal.Conv.html">Literal.Conv</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALas_case">as_case</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
If <code class="code">payload t = Case p</code>, then return <code class="code">Some p</code>, else return <code class="code">None</code>
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALas_cst">as_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALas_cst_exn">as_cst_exn</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Unsafe version of <a href="Ind_cst.html#VALas_cst"><code class="code">Ind_cst.as_cst</code></a>
</div>
</td></tr>
<tr><td><a href="Literal.View.html#VALas_eqn">as_eqn</a> [<a href="Literal.View.html">Literal.View</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALas_graph">as_graph</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
Get a graph of the proof
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALas_sub_cst_of">as_sub_cst_of</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
downcasts iff <code class="code">t</code> is a sub-constant of <code class="code">cst</code>
</div>
</td></tr>
<tr><td><a href="Literals.Pos.html#VALat">at</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
Return the subterm at the given position, or
</div>
</td></tr>
<tr><td><a href="Literal.Pos.html#VALat">at</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
Subterm at given position, or
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Pos.html#VALat">at</a> [<a href="Clause_intf.S.Pos.html">Clause_intf.S.Pos</a>]</td>
<td></td></tr>
<tr><td><a href="Selection.html#VALavailable_selections">available_selections</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
available names for selection functions
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALaxioms">axioms</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td><div class="info">
Additional axioms
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALaxioms">axioms</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
List of (persistent) axioms that are needed for simplifications to
      be complete for the given symbol.
</div>
</td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Superposition.S.html#VALbackward_demodulate">backward_demodulate</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
backward version of demodulation: add to the set active clauses that
      can potentially be rewritten by the given clause
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALbackward_simplify">backward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Perform backward simplification with the given clause.
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALbasic_simplify">basic_simplify</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
basic simplifications (remove duplicate literals, trivial literals,
      destructive equality resolution...)
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALbefore_check_sat">before_check_sat</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALbfs">bfs</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Strong orientation toward FIFO
</div>
</td></tr>
<tr><td><a href="Phases.html#VALbind">bind</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">bind state f</code> calls <code class="code">f</code> to go one step further from <code class="code">state</code>
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALby_name">by_name</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Get an extension by its name, if any
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_div_case_switch">canc_div_case_switch</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Eliminate negative divisibility literals within a power-of-prime
      quotient of Z:
      not (d^i | m) -----&gt;
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_div_chaining">canc_div_chaining</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Chain together two divisibility literals, assuming they share the
      same prime
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_div_prime_decomposition">canc_div_prime_decomposition</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Eliminate divisibility literals with a non-power-of-prime
      quotient of Z (for instance  <code class="code">6 | a ---&gt; { 2 | a, 3 | a }</code>)
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_divisibility">canc_divisibility</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Infer divisibility constraints from integer equations,
      for instace   C or  2a=b ----&gt;  C or 2 | b    if a is maximal
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_equality_factoring">canc_equality_factoring</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
cancellative equality factoring
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_ineq_chaining">canc_ineq_chaining</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
cancellative inequality chaining.
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_ineq_factoring">canc_ineq_factoring</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Factoring between two inequation literals
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_less_to_lesseq">canc_less_to_lesseq</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Simplification:  a &lt; b  ----&gt; a+1 ≤ b
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_sup_active">canc_sup_active</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
cancellative superposition where given clause is active
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcanc_sup_passive">canc_sup_passive</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
cancellative superposition where given clause is passive
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALcancellation">cancellation</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
cancellation (unifies some terms on both sides of a
      comparison operator)
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcase_compare">case_compare</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcase_equal">case_equal</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcase_hash">case_hash</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcase_is_base">case_is_base</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcase_is_rec">case_is_rec</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcase_sub_constants">case_sub_constants</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
All sub-constants that are subterms of a specific case
</div>
</td></tr>
<tr><td><a href="ArithInt.html#VALcase_switch_limit">case_switch_limit</a> [<a href="ArithInt.html">ArithInt</a>]</td>
<td><div class="info">
Positive integer: maximum width of an inequality case switch.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcase_to_term">case_to_term</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALcheck">check</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Is the current problem satisfiable?
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcheck_empty">check_empty</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Forbid empty clauses with trails, i.e.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcheck_satisfiability">check_satisfiability</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Checks  that the SAT context is still valid
</div>
</td></tr>
<tr><td><a href="Saturate.html#VALcheck_timeout">check_timeout</a> [<a href="Saturate.html">Saturate</a>]</td>
<td><div class="info">
check whether we still have some time w.r.t timeout
</div>
</td></tr>
<tr><td><a href="Classify_cst.html#VALclassify">classify</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td><div class="info">
<code class="code">classify id</code> returns the role <code class="code">id</code> plays in inductive reasoning
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALclauses">clauses</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Current set of clauses
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.ActiveSet.html#VALclauses">clauses</a> [<a href="ProofState_intf.S.ActiveSet.html">ProofState_intf.S.ActiveSet</a>]</td>
<td><div class="info">
Current set of clauses
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALcoeff">coeff</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Seq.html#VALcoeffs">coeffs</a> [<a href="Monome.Seq.html">Monome.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALcoeffs">coeffs</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
coefficients
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALcoeffs_n">coeffs_n</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
<code class="code">coeffs_n l gcd</code>, if <code class="code">length l = n</code>, returns a function that
        takes a list of <code class="code">n-1</code> terms <code class="code">k1, ..., k(n-1)</code> and returns a list of
        monomes <code class="code">m1, ..., mn</code> that depend on <code class="code">k1, ..., k(n-1)</code> such that the sum
        <code class="code">l1 * m1 + l2 * m2 + ... + ln * mn = 0</code>.
</div>
</td></tr>
<tr><td><a href="Monome.Seq.html#VALcoeffs_swap">coeffs_swap</a> [<a href="Monome.Seq.html">Monome.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALcombine">combine</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Combine a list of pairs <code class="code">w, coeff</code> where <code class="code">w</code> is a weight function,
        and <code class="code">coeff</code> a strictly positive number.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALcombine">combine</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "and" of the given eligibility criteria.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALcompare">compare</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALcompare">compare</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALcompare">compare</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALcompare">compare</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALcompare">compare</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Compare monomes as if they were multisets of terms, the coefficient
      in front of a term being its multiplicity.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALcompare">compare</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALcompare">compare</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALcompare">compare</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Comp.html#VALcompare">compare</a> [<a href="Literal.Comp.html">Literal.Comp</a>]</td>
<td><div class="info">
partial comparison of literals under the given term ordering
</div>
</td></tr>
<tr><td><a href="Literal.html#VALcompare">compare</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
lexicographic comparison of literals
</div>
</td></tr>
<tr><td><a href="SClause.html#VALcompare">compare</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.WithPos.html#VALcompare">compare</a> [<a href="Clause_intf.S.WithPos.html">Clause_intf.S.WithPos</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALcompare">compare</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Compare two terms
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALcompare">compare</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALcompare_by_result">compare_by_result</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td><div class="info">
Compare proofs by their result
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALcompare_proof">compare_proof</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALcomparison">comparison</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Try to compare two monomes.
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALcondensation">condensation</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
condensation
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALconst">const</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Empty monomial, from constant (decides type)
</div>
</td></tr>
<tr><td><a href="Monome.html#VALconst">const</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
constant
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALcontextual_literal_cutting">contextual_literal_cutting</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
contexual Literal.t cutting of the given clause by the active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALconvert_input_statements">convert_input_statements</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Convert raw input statements into clauses, triggering
      <a href="Env_intf.S.html#VALon_input_statement"><code class="code">Env_intf.S.on_input_statement</code></a>
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALconvert_lemma">convert_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Intercepts input lemmas and converts them into clauses.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcover_set_cases">cover_set_cases</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Cases of the cover set
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcover_set_sub_constants">cover_set_sub_constants</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
All sub-constants of a given inductive constant
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_add">cr_add</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_return">cr_return</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_skip">cr_skip</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALcreate">create</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Build a new clause from the given literals.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALcreate_a">create_a</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Build a new clause from the given literals.
</div>
</td></tr>
<tr><td><a href="Flex_state.html#VALcreate_key">create_key</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_compare">cst_compare</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_cover_set">cst_cover_set</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Get the cover set of this constant:
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcst_depth">cst_depth</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_equal">cst_equal</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_hash">cst_hash</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_id">cst_id</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_of_id">cst_of_id</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">cst_of_id id ty</code> returns a new or existing constant for this id.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcst_of_term">cst_of_term</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">cst_of_term t</code> returns a new or existing constant for this term, if any.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALcst_same_type">cst_same_type</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_to_term">cst_to_term</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcst_ty">cst_ty</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.Key.html#VALcur_phase">cur_phase</a> [<a href="Phases.Key.html">Phases.Key</a>]</td>
<td><div class="info">
The current phase is stored in the state using this key
</div>
</td></tr>
<tr><td><a href="Phases.html#VALcurrent_phase">current_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Get the current phase
</div>
</td></tr>
<tr><td><a href="Literals.Pos.html#VALcut">cut</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
Index + literal position
</div>
</td></tr>
<tr><td><a href="Literal.Pos.html#VALcut">cut</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
cut the subterm position off.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_res_clauses">cut_res_clauses</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="ProofState_intf.S.html#VALdebug">debug</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
debug functions: much more detailed printing
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALdeclarations_of_cst">declarations_of_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">declarations_of_cst c</code> returns a list of type declarations that should
    be made if <code class="code">c</code> is new (declare the subcases of its coverset)
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALdeclare">declare</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Declare the type of a symbol (updates signature)
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALdeclare_cst">declare_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Adds the constant to the set of inductive constants, make a coverset...
</div>
</td></tr>
<tr><td><a href="EnumTypes.S.html#VALdeclare_ty">declare_ty</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Declare that the domain of the type <code class="code">ty_id</code> is restricted to
      given list of <code class="code">cases</code>, in the form <code class="code">forall var. Or_{c in cases} var = c</code>.
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALdefault">default</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Default extension.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALdefault">default</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Use <a href="Literal.html#VALheuristic_weight"><code class="code">Literal.heuristic_weight</code></a>
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALdefault">default</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Obtain the default queue
</div>
</td></tr>
<tr><td><a href="Selection.html#VALdefault_selection">default_selection</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Default selection function
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALdemodulate">demodulate</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
rewrite clause using orientable unit equations
</div>
</td></tr>
<tr><td><a href="Literals.html#VALdepth">depth</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALdepth">depth</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
depth of literal
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALdifference">difference</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALdifference">difference</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALdiophant2">diophant2</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Find the solution vector for this diophantine equation, or fails.
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALdiophant_l">diophant_l</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
generalize diophantine equation solving to a list of at least two
        coefficients.
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALdistance_to_goal">distance_to_goal</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td><div class="info">
<code class="code">distance_to_conjecture p</code> returns <code class="code">None</code> if <code class="code">p</code> has no ancestor
    that is a conjecture (including <code class="code">p</code> itself).
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALdistance_to_goal">distance_to_goal</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
See <code class="code">Proof.distance_to_goal</code>, applied to the clause's proof
</div>
</td></tr>
<tr><td><a href="ArithInt.html#VALdiv_case_switch_limit">div_case_switch_limit</a> [<a href="ArithInt.html">ArithInt</a>]</td>
<td><div class="info">
Positive integer: maximum prime number suitable for div_case_switch
    (ie maximum n for enumeration of cases in n^k | x)
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALdivisible">divisible</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
<code class="code">divisible e n</code> returns true if all coefficients of <code class="code">e</code> are
      divisible by <code class="code">n</code> and n is an int &gt;= 2
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_binary_inferences">do_binary_inferences</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do binary inferences that involve the given clause
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_generate">do_generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do generating inferences
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_unary_inferences">do_unary_inferences</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do unary inferences for the given clause
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALdominates">dominates</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">dominates c sub</code> is true if <code class="code">sub</code> is a sub-constant of <code class="code">c</code>,
    or if some sub-constant of <code class="code">c</code> dominates <code class="code">sub</code> transitively
</div>
</td></tr>
<tr><td><a href="Monome.html#VALdominates">dominates</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
<code class="code">dominates ~strict m1 m2</code> is true if <code class="code">m1</code> is always greater than
    <code class="code">m2</code>, in any model or variable valuation.
</div>
</td></tr>
<tr><td><a href="Params.html#VALdot_all_roots">dot_all_roots</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALdot_file">dot_file</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALdot_sat">dot_sat</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit.PAYLOAD.html#VALdummy">dummy</a> [<a href="Bool_lit.PAYLOAD.html">Bool_lit.PAYLOAD</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALdummy">dummy</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Value that should not be used
</div>
</td></tr>
<tr><td><a href="BBox.html#VALdummy">dummy</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Clause_intf.S.html#VALeligible_param">eligible_param</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Bitvector that indicates which of the literals of <code class="code">subst(clause)</code>
      are eligible for paramodulation.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALeligible_res">eligible_res</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Bitvector that indicates which of the literals of <code class="code">subst(clause)</code>
      are eligible for resolution.
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALeliminate_unshielded">eliminate_unshielded</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Eliminate unshielded variables using an adaptation of
      Cooper's algorithm
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.Set.html#VALempty">empty</a> [<a href="Rewrite_rule.Set.html">Rewrite_rule.Set</a>]</td>
<td></td></tr>
<tr><td><a href="Flex_state.html#VALempty">empty</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALempty">empty</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Compute_prec.html#VALempty">empty</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALempty_state">empty_state</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Heuristics.html#VALenable_depth_limit">enable_depth_limit</a> [<a href="Heuristics.html">Heuristics</a>]</td>
<td><div class="info">
Set a maximal depth for terms.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALeq">eq</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALeq">eq</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Equations
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALeq_subsumes">eq_subsumes</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
equality subsumption
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALeq_zero">eq_zero</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Returns substitutions that make the monome always equal to zero.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALequal">equal</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALequal">equal</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALequal">equal</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALequal">equal</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALequal">equal</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALequal">equal</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALequal">equal</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
equality of literals
</div>
</td></tr>
<tr><td><a href="SClause.html#VALequal">equal</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALequal_com">equal_com</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALequal_com">equal_com</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALequal_com">equal_com</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
commutative equality of lits
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALequal_proof">equal_proof</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALexists">exists</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALexists_ac">exists_ac</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Is there any AC symbol?
</div>
</td></tr>
<tr><td><a href="Phases.html#VALexit">exit</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Exit
</div>
</td></tr>
<tr><td><a href="Params.html#VALexpand_def">expand_def</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALexplore">explore</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Use heuristics for selecting "small" clauses
</div>
</td></tr>
<tr><td><a href="MetaProverState.html#VALextension">extension</a> [<a href="MetaProverState.html">MetaProverState</a>]</td>
<td><div class="info">
Prover extension
</div>
</td></tr>
<tr><td><a href="Ind_types.html#VALextension">extension</a> [<a href="Ind_types.html">Ind_types</a>]</td>
<td></td></tr>
<tr><td><a href="Heuristics.html#VALextension">extension</a> [<a href="Heuristics.html">Heuristics</a>]</td>
<td></td></tr>
<tr><td><a href="ArithInt.html#VALextension">extension</a> [<a href="ArithInt.html">ArithInt</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.html#VALextension">extension</a> [<a href="EnumTypes.html">EnumTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Rewriting.html#VALextension">extension</a> [<a href="Rewriting.html">Rewriting</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.html#VALextension">extension</a> [<a href="Superposition.html">Superposition</a>]</td>
<td></td></tr>
<tr><td><a href="Induction.html#VALextension">extension</a> [<a href="Induction.html">Induction</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar.html#VALextension">extension</a> [<a href="Avatar.html">Avatar</a>]</td>
<td><div class="info">
Extension that enables Avatar splitting and create a new SAT-solver.
</div>
</td></tr>
<tr><td><a href="AC.html#VALextension">extension</a> [<a href="AC.html">AC</a>]</td>
<td></td></tr>
<tr><td><a href="Extensions.html#VALextensions">extensions</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
All currently available extensions
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALextract">extract</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
<code class="code">extract lits t</code> returns <code class="code">None</code> if <code class="code">t</code> doesn't occur in <code class="code">lits</code>.
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALextract_exn">extract_exn</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Unsafe version of <a href="ClauseContext.html#VALextract"><code class="code">ClauseContext.extract</code></a>.
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Monome.Int.html#VALfactorize">factorize</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Factorize <code class="code">e</code> into <code class="code">Some (e',s)</code> if <code class="code">e = e' x s</code>, None
      otherwise (ie if s=1).
</div>
</td></tr>
<tr><td><a href="Phases.html#VALfail">fail</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Fail with the given error message
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_all_neg">favor_all_neg</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Favor clauses with only negative ground lits
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_goal">favor_goal</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
The closest a clause is from the initial goal, the lowest its weight.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_ground">favor_ground</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_horn">favor_horn</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_non_all_neg">favor_non_all_neg</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Favor clauses that have at least one non-(ground negative) lit
</div>
</td></tr>
<tr><td><a href="Params.html#VALfiles">files</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALfilter">filter</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Only keep a subset of boolean literals
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALfilter">filter</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALfilter_absurd_trails">filter_absurd_trails</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
<code class="code">filter_trails f</code> calls <code class="code">f</code> on every trail associated with the empty
      clause.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALfind">find</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALfind_cst_in_term">find_cst_in_term</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">find_cst_in_lits term</code> searches subterms of <code class="code">term</code> for constants
    that are of an inductive type and that are not constructors.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALfind_exn">find_exn</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALfind_proof">find_proof</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Recover the proof for the AC-property of this symbol.
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALfind_signature">find_signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Find the type of the given symbol
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALfind_signature_exn">find_signature_exn</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Unsafe version of <a href="Ctx_intf.S.html#VALfind_signature"><code class="code">Ctx_intf.S.find_signature</code></a>.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_backward_simplified">flag_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause has been backward simplified
</div>
</td></tr>
<tr><td><a href="Avatar.html#VALflag_cut_introduced">flag_cut_introduced</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALflag_lemma">flag_lemma</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause is a lemma
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_persistent">flag_persistent</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause cannot be redundant
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_redundant">flag_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause has been shown to be redundant
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_add">flex_add</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
add <code class="code">k -&gt; v</code> to the flex state
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_get">flex_get</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
<code class="code">flex_get k</code> is the same as <code class="code">Flex_state.get_exn k (flex_state ())</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_state">flex_state</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
State inherited from configuration
</div>
</td></tr>
<tr><td><a href="Literal.View.html#VALfocus_arith">focus_arith</a> [<a href="Literal.View.html">Literal.View</a>]</td>
<td><div class="info">
Focus on a specific term in an arithmetic literal.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALfocus_term">focus_term</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Attempt to focus on the given atomic term, if it occurs directly
      under the arith literal
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALfocus_term">focus_term</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Focus on the given term, if it is one of the members of
      the given monome.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALfocus_term_exn">focus_term_exn</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALfocus_term_exn">focus_term_exn</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Same as <a href="Monome.Focus.html#VALfocus_term"><code class="code">Monome.Focus.focus_term</code></a>, but
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALfocused_monome">focused_monome</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
The focused monome
</div>
</td></tr>
<tr><td><a href="Trail.html#VALfold">fold</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALfold">fold</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALfold">fold</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Fold over terms
</div>
</td></tr>
<tr><td><a href="Literal.html#VALfold">fold</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
basic fold
</div>
</td></tr>
<tr><td><a href="Literals.html#VALfold_arith">fold_arith</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Fold over eligible arithmetic literals
</div>
</td></tr>
<tr><td><a href="Literals.html#VALfold_arith_terms">fold_arith_terms</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Fold on terms under arithmetic literals, with the focus on
    the current term
</div>
</td></tr>
<tr><td><a href="Literals.html#VALfold_eqn">fold_eqn</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
fold f over all literals sides, with their positions.
</div>
</td></tr>
<tr><td><a href="Phases.html#VALfold_l">fold_l</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALfold_l">fold_l</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALfold_lits">fold_lits</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Fold over literals who satisfy <code class="code">eligible</code>.
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALfold_m">fold_m</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Fold on terms of the given monome, focusing on them one by one,
      along with the position of the focused term
</div>
</td></tr>
<tr><td><a href="Monome.html#VALfold_max">fold_max</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Fold over terms that are maximal in the given ordering.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALfold_terms">fold_terms</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Fold on focused terms in the literal, one by one, with
      the position of the focused term
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALfold_terms">fold_terms</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALfold_terms">fold_terms</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
See <a href="Literal.html#VALfold_terms"><code class="code">Literal.fold_terms</code></a>, which is the same but for the
    <code class="code">eligible</code> argument
</div>
</td></tr>
<tr><td><a href="Literal.html#VALfold_terms">fold_terms</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
Iterate on terms, maybe subterms, of the literal.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALfor_all">for_all</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALforward_simplify">forward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Simplify the clause w.r.t to the active set and experts
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALfresh_id">fresh_id</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Make a fresh ID.
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALfrom_hooks">from_hooks</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Env_intf.S.html#VALgenerate">generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Perform all generating inferences
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALgeneric_unif">generic_unif</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Generic unification/matching/variant, given such an operation on monomes
</div>
</td></tr>
<tr><td><a href="Flex_state.html#VALget">get</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALget">get</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALget">get</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALget">get</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALget">get</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALget_active">get_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Active clauses
</div>
</td></tr>
<tr><td><a href="Literals.View.html#VALget_arith">get_arith</a> [<a href="Literals.View.html">Literals.View</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.View.html#VALget_arith">get_arith</a> [<a href="Literal.View.html">Literal.View</a>]</td>
<td><div class="info">
Extract an arithmetic literal
</div>
</td></tr>
<tr><td><a href="Literals.View.html#VALget_arith_exn">get_arith_exn</a> [<a href="Literals.View.html">Literals.View</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALget_empty_clauses">get_empty_clauses</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Set of known empty clauses
</div>
</td></tr>
<tr><td><a href="MetaProverState.html#VALget_env">get_env</a> [<a href="MetaProverState.html">MetaProverState</a>]</td>
<td><div class="info">
<code class="code">get_env (module Env)</code> returns the meta-prover saved in <code class="code">Env</code>,
    assuming the extension has been loaded in <code class="code">Env</code>.
</div>
</td></tr>
<tr><td><a href="Avatar.html#VALget_env">get_env</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.View.html#VALget_eqn">get_eqn</a> [<a href="Literals.View.html">Literals.View</a>]</td>
<td><div class="info">
get the term l at given position in clause, and r such that l ?= r
      is the Literal.t at the given position.
</div>
</td></tr>
<tr><td><a href="Literal.View.html#VALget_eqn">get_eqn</a> [<a href="Literal.View.html">Literal.View</a>]</td>
<td><div class="info">
View of a Prop or Equation literal, oriented by the position.
</div>
</td></tr>
<tr><td><a href="Literals.View.html#VALget_eqn_exn">get_eqn_exn</a> [<a href="Literals.View.html">Literals.View</a>]</td>
<td></td></tr>
<tr><td><a href="Flex_state.html#VALget_exn">get_exn</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALget_exn">get_exn</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="SClause.html#VALget_flag">get_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
get value of boolean flag
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALget_flag">get_flag</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
get value of boolean flag
</div>
</td></tr>
<tr><td><a href="Phases.html#VALget_key">get_key</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">get_key k</code> returns the value associated with <code class="code">k</code> in the state
</div>
</td></tr>
<tr><td><a href="Flex_state.html#VALget_or">get_or</a> [<a href="Flex_state.html">Flex_state</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALget_passive">get_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Passive clauses
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALget_profile">get_profile</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALget_proof">get_proof</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Return a proof of <code class="code">false</code>, assuming <a href="Sat_solver_intf.S.html#VALcheck"><code class="code">Sat_solver_intf.S.check</code></a> returned <code class="code">Unsat</code>.
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALget_proof_of_lit">get_proof_of_lit</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
<code class="code">get_proof_of_lit lit</code> returns the proof of <code class="code">lit</code>, assuming it has been
      proved true at level 0 (see <a href="Sat_solver_intf.S.html#VALvaluation_level"><code class="code">Sat_solver_intf.S.valuation_level</code></a>)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALget_some_empty_clause">get_some_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Some empty clause, if present, otherwise None
</div>
</td></tr>
<tr><td><a href="Saturate.S.html#VALgiven_clause">given_clause</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
run the given clause until a timeout occurs or a result
      is found.
</div>
</td></tr>
<tr><td><a href="Saturate.S.html#VALgiven_clause_step">given_clause_step</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
Perform one step of the given clause algorithm.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALgoal_oriented">goal_oriented</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
custom weight function that favors clauses that are "close" to
      initial conjectures.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALground">ground</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Favor positive unit clauses and ground clauses
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="Superposition.S.html#VALhandle_distinct_constants">handle_distinct_constants</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
Decide on "quoted" "symbols" (which are all distinct)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALhas_empty_clause">has_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is there an empty clause?
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALhas_instances">has_instances</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
For real or rational, always true.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALhas_selected_lits">has_selected_lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
does the clause have some selected literals?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALhas_trail">has_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Has a non-empty trail?
</div>
</td></tr>
<tr><td><a href="Trail.html#VALhash">hash</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALhash">hash</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALhash">hash</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALhash">hash</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALhash">hash</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALhash">hash</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
hashing of literal
</div>
</td></tr>
<tr><td><a href="SClause.html#VALhash">hash</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALhash_fun">hash_fun</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALhash_fun">hash_fun</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALhash_fun">hash_fun</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALhash_proof">hash_proof</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALheuristic_weight">heuristic_weight</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
heuristic difficulty to eliminate lit
</div>
</td></tr>
<tr><td><a href="Const.html#VALhome">home</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="SClause.html#VALid">id</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALid">id</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.Pos.html#VALidx">idx</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
Index in the literal array
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALidx_back_demod">idx_back_demod</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
index for backward demodulation/simplifications
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALidx_fv">idx_fv</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
index for subsumption
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALidx_simpl">idx_simpl</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
index for forward simplifications
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALidx_sup_from">idx_sup_from</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
index for superposition from the set
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALidx_sup_into">idx_sup_into</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
index for superposition into the set
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALinfer_active">infer_active</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
superposition where given clause is active
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALinfer_equality_factoring">infer_equality_factoring</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.S.html#VALinfer_equality_resolution">infer_equality_resolution</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.S.html#VALinfer_passive">infer_passive</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
superposition where given clause is passive
</div>
</td></tr>
<tr><td><a href="BBox.html#VALinject_case">inject_case</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Inject <code class="code">cst = case</code>
</div>
</td></tr>
<tr><td><a href="BBox.html#VALinject_lemma">inject_lemma</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Make a new literal from this list of clauses that we are going to cut
    on.
</div>
</td></tr>
<tr><td><a href="BBox.html#VALinject_lits">inject_lits</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Inject a clause into a boolean literal.
</div>
</td></tr>
<tr><td><a href="EnumTypes.S.html#VALinstantiate_vars">instantiate_vars</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Instantiate variables whose type is a known enumerated type,
      with all cases of this type.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALintroduce_cut">introduce_cut</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Introduce a cut on the given clause(s).
</div>
</td></tr>
<tr><td><a href="Literals.html#VALis_RR_horn_clause">is_RR_horn_clause</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Recognized whether the clause is a Range-Restricted Horn clause
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_absurd">is_absurd</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALis_absurd">is_absurd</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
All literals are false, or there are no literals
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_absurd">is_absurd</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALis_ac">is_ac</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALis_active">is_active</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
<code class="code">Trail.is_active t ~v</code> is true iff all boolean literals
    in <code class="code">t</code> are satisfied in the boolean valuation <code class="code">v</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_active">is_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the clause in the active set
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_active">is_active</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
True if the clause's trail is active in this valuation
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_arith">is_arith</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_arith_divides">is_arith_divides</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_arith_eq">is_arith_eq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_arith_eqn">is_arith_eqn</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
= or !=
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_arith_ineq">is_arith_ineq</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
&lt; or &lt;=
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_arith_less">is_arith_less</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_arith_lesseq">is_arith_lesseq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_arith_neq">is_arith_neq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALis_assert">is_assert</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td><div class="info">
Proof: the statement was asserted in some file
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_backward_simplified">is_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_backward_simplified">is_backward_simplified</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALis_completeness_preserved">is_completeness_preserved</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Check whether completeness was preserved so far
</div>
</td></tr>
<tr><td><a href="Monome.html#VALis_const">is_const</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Returns <code class="code">true</code> if the monome is only a constant
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALis_cst">is_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Check whether the given constant is an inductive constant
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_divides">is_divides</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_eligible_param">is_eligible_param</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Check whether the <code class="code">idx</code>-th literal is eligible for paramodulation
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.Set.html#VALis_empty">is_empty</a> [<a href="Rewrite_rule.Set.html">Rewrite_rule.Set</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALis_empty">is_empty</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Empty trail?
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_empty">is_empty</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_empty">is_empty</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the clause an empty clause?
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALis_empty">is_empty</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
check whether the queue is empty
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_eq">is_eq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_eq">is_eq</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal of the form a = b?
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_eqn">is_eqn</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_eqn">is_eqn</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal a proper (in)equation or prop?
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALis_goal">is_goal</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td><div class="info">
The statement comes from the negation of a goal in some file
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_goal">is_goal</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Looking at the clause's proof, return <code class="code">true</code> iff the clause is an
      initial (negated) goal from the problem
</div>
</td></tr>
<tr><td><a href="Monome.html#VALis_ground">is_ground</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Are there no variables in the monome?
</div>
</td></tr>
<tr><td><a href="Literals.html#VALis_ground">is_ground</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
all the literals are ground?
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_ground">is_ground</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_ground">is_ground</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALis_horn">is_horn</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Recognizes Horn clauses (at most one positive literal)
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_ineq">is_ineq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
&lt; or &lt;=
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_less">is_less</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALis_lesseq">is_lesseq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALis_max">is_max</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Is the focused term maximal in the literal?
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALis_max">is_max</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Is the focused term maximal in the monome?
</div>
</td></tr>
<tr><td><a href="Literals.html#VALis_max">is_max</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Is the i-th literal maximal in the ordering?
</div>
</td></tr>
<tr><td><a href="Literal.Pos.html#VALis_max_term">is_max_term</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
Is the term at the given position, maximal in the literal w.r.t this
      ordering? In other words, if the term is replaced by a smaller term,
      can the whole literal becomes smaller?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_maxlit">is_maxlit</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the i-th literal maximal in subst(clause)? Equivalent to
      Bitvector.get (maxlits ~ord c subst) i
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_neg">is_neg</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_neg">is_neg</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal negative?
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_neq">is_neq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_neq">is_neq</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal of the form a != b?
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALis_new">is_new</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_oriented_rule">is_oriented_rule</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the clause a positive oriented clause?
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_passive">is_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the clause a passive clause?
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_pos">is_pos</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_pos">is_pos</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal positive?
</div>
</td></tr>
<tr><td><a href="Literals.html#VALis_pos_eq">is_pos_eq</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Recognize whether the clause is a positive unit equality.
</div>
</td></tr>
<tr><td><a href="ArithLit.Util.html#VALis_prime">is_prime</a> [<a href="ArithLit.Util.html">ArithLit.Util</a>]</td>
<td><div class="info">
Is the integer prime?
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALis_proof_of_false">is_proof_of_false</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALis_prop">is_prop</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
is the literal a boolean proposition?
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_redundant">is_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the given clause redundant w.r.t the active set?
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_redundant">is_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_redundant">is_redundant</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALis_same">is_same</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_selected">is_selected</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
check whether a literal is selected
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALis_semantic_tautology">is_semantic_tautology</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
semantic tautology deletion, using a congruence closure algorithm
      to see if negative literals imply some positive Literal.t
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALis_strictly_max">is_strictly_max</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Is the focused term maximal in the literal, ie is it greater
      than all the othe terms?
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALis_sub_cst">is_sub_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Is the term a constant that was created within a cover set?
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALis_sub_cst_of">is_sub_cst_of</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="ArithInt.S.html#VALis_tautology">is_tautology</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
is the clause a tautology w.r.t linear expressions?
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALis_tautology">is_tautology</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
Check whether the clause is a (syntactic) tautology, ie whether
      it contains true or "A" and "not A"
</div>
</td></tr>
<tr><td><a href="Trail.html#VALis_trivial">is_trivial</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
returns <code class="code">true</code> iff the trail contains both <code class="code">i</code> and <code class="code">-i</code>.
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALis_trivial">is_trivial</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALis_trivial">is_trivial</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Check whether the clause is AC-trivial
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_trivial">is_trivial</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Check whether the clause is trivial
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALis_trivial">is_trivial</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALis_trivial">is_trivial</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Tautology? (simple syntactic criterion only)
</div>
</td></tr>
<tr><td><a href="Literal.html#VALis_trivial">is_trivial</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALis_trivial_lit">is_trivial_lit</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Is the literal AC-trivial?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_unit_clause">is_unit_clause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
is the clause a unit clause?
</div>
</td></tr>
<tr><td><a href="Monome.html#VALis_zero">is_zero</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
return <code class="code">true</code> if the monome is the constant 0
</div>
</td></tr>
<tr><td align="left"><br>K</td></tr>
<tr><td><a href="Avatar.html#VALk_avatar">k_avatar</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState.html#VALkey">key</a> [<a href="MetaProverState.html">MetaProverState</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.html#VALkey">key</a> [<a href="Superposition.html">Superposition</a>]</td>
<td><div class="info">
key to access the <code class="code">Env.flex_state</code>.
</div>
</td></tr>
<tr><td><a href="Params.html#VALkey">key</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="AC.html#VALkey_ac">key_ac</a> [<a href="AC.html">AC</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALkind">kind</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALlast_result">last_result</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Last computed result.
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALlemmas">lemmas</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td><div class="info">
Discovered lemmas
</div>
</td></tr>
<tr><td><a href="Trail.html#VALlength">length</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALlength">length</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALlength">length</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Number of literals
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALleq_zero">leq_zero</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Shortcut for <a href="Monome.Int.Solve.html#VALlower_zero"><code class="code">Monome.Int.Solve.lower_zero</code></a> when <code class="code">strict = false</code>
</div>
</td></tr>
<tr><td><a href="Literals.Pos.html#VALlit_at">lit_at</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
Lookup which literal the position is about, return it
      and the rest of the position.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALlits">lits</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALlits">lits</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALlits">lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALlits_of_path">lits_of_path</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Extract the raw equality literals from this path
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALload_extensions">load_extensions</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.Key.html#VALlost_completeness">lost_completeness</a> [<a href="Ctx.Key.html">Ctx.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALlost_completeness">lost_completeness</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
To be called when completeness is not preserved
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALlower_zero">lower_zero</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Solve for the monome to be always lower than zero (<code class="code">strict</code> determines
        whether the inequality is strict or not).
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALlt_zero">lt_zero</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Shortcut for <a href="Monome.Int.Solve.html#VALlower_zero"><code class="code">Monome.Int.Solve.lower_zero</code></a> when <code class="code">strict = true</code>
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="ClauseContext.html#VALmake">make</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Make a context from a var and literals containing this var.
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALmake">make</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Make a fresh literal with the given payload
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALmake">make</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALmake">make</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALmake">make</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Bring your own implementation of queue.
</div>
</td></tr>
<tr><td><a href="Phases.html#VALmap">map</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Map the current value
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmap">map</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmap">map</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
functor
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALmap">map</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALmap">map</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALmap">map</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALmap">map</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmap">map</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
functor
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALmap_l">map_l</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALmap_lit">map_lit</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Apply a function to the monomes and focused monomes
</div>
</td></tr>
<tr><td><a href="Monome.html#VALmap_num">map_num</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALmark_backward_simplified">mark_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALmark_backward_simplified">mark_backward_simplified</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALmark_redundant">mark_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALmark_redundant">mark_redundant</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmatching">matching</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
checks whether subst(lit_a) is equal to lit_b.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALmatching">matching</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmatching">matching</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
checks whether subst(lit_a) matches lit_b.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALmax">max</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Maximal literals of the clause
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALmax_terms">max_terms</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Maximal terms of the literal
</div>
</td></tr>
<tr><td><a href="Literal.Comp.html#VALmax_terms">max_terms</a> [<a href="Literal.Comp.html">Literal.Comp</a>]</td>
<td><div class="info">
Maximal terms of the literal
</div>
</td></tr>
<tr><td><a href="Literals.html#VALmaxlits">maxlits</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Bitvector of positions of maximal literals
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALmaxlits">maxlits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
List of maximal literals
</div>
</td></tr>
<tr><td><a href="Literals.html#VALmaxlits_l">maxlits_l</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
List of maximal literals, with their index, among the array
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmem">mem</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALmem">mem</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Is the term in the monome?
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmerge">merge</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Merge several trails (e.g.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmerge_l">merge_l</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Merge several trails (e.g.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALmk_absurd">mk_absurd</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith">mk_arith</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith_eq">mk_arith_eq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith_less">mk_arith_less</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith_lesseq">mk_arith_lesseq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith_neq">mk_arith_neq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_arith_op">mk_arith_op</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_assert">mk_assert</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_assert'">mk_assert'</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_bc">mk_bc</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_c">mk_c</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_data">mk_data</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALmk_div">mk_div</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_divides">mk_divides</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_divides">mk_divides</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_eq">mk_eq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_eq">mk_eq</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
build literals.
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALmk_esa">mk_esa</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_f_esa">mk_f_esa</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_f_inference">mk_f_inference</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_f_simp">mk_f_simp</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_f_trivial">mk_f_trivial</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_false">mk_false</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_goal">mk_goal</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_goal'">mk_goal'</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_inference">mk_inference</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALmk_left">mk_left</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_less">mk_less</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_lesseq">mk_lesseq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_lit">mk_lit</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_neq">mk_neq</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_neq">mk_neq</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALmk_not_divides">mk_not_divides</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_not_divides">mk_not_divides</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Compute_prec.html#VALmk_precedence">mk_precedence</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td><div class="info">
Make a precedence
</div>
</td></tr>
<tr><td><a href="Literal.html#VALmk_prop">mk_prop</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALmk_right">mk_right</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_rule">mk_rule</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_simp">mk_simp</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_tauto">mk_tauto</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALmk_trivial">mk_trivial</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALmk_true">mk_true</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.Modulo.html#VALmodulo">modulo</a> [<a href="Monome.Int.Modulo.html">Monome.Int.Modulo</a>]</td>
<td><div class="info">
Representative of the number in Z/nZ
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALmulti_simplify">multi_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Can we simplify the clause into a List of simplified clauses?
</div>
</td></tr>
<tr><td><a href="BBox.html#VALmust_be_kept">must_be_kept</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
<code class="code">must_be_kept lit</code> means that <code class="code">lit</code> should survive in boolean splitting,
    that is, that if <code class="code">C &lt;- lit, Gamma</code> then any clause derived from <code class="code">C</code>
    recursively will have <code class="code">lit</code> in its trail.
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALname">name</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Name of the implementation/role of the queue
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALnames">names</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Names of loaded extensions
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.html#VALnarrow_lit">narrow_lit</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td><div class="info">
<code class="code">narrow_term rules lit</code> finds the set of rules <code class="code">(l --&gt; clauses) in rules</code>
    and substitutions <code class="code">sigma</code> such that <code class="code">sigma(l) = sigma(tit)</code>
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.html#VALnarrow_term">narrow_term</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td><div class="info">
<code class="code">narrow_term rules t</code> finds the set of rules <code class="code">(l --&gt; r) in rules</code>
    and substitutions <code class="code">sigma</code> such that <code class="code">sigma(l) = sigma(t)</code>
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALneg">neg</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Negate the boolean literal
</div>
</td></tr>
<tr><td><a href="Literals.html#VALneg">neg</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALneg">neg</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only negative literals
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALnegate">negate</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALnegate">negate</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
negate literal
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALnegative_simplify_reflect">negative_simplify_reflect</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALneq_zero">neq_zero</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Find some solutions that negate the equation.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALnew_flag">new_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
new flag that can be used on clauses
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALnext">next</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Get-and-remove the next passive clause to process
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALnext_passive">next_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Extract next passive clause
</div>
</td></tr>
<tr><td><a href="Selection.html#VALno_select">no_select</a> [<a href="Selection.html">Selection</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALnorm">norm</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
<code class="code">norm l = abs l, not (sign l)</code>
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALnormalize">normalize</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Normalize the monome, which means that if some terms are
      integer constants, they are moved to the constant part
      (e.g after apply X-&gt;3 in 2.X+1, one gets 2.3 +1.
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.html#VALnormalize_clause">normalize_clause</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td><div class="info">
normalize literals of the clause w.r.t.
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.html#VALnormalize_term">normalize_term</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td><div class="info">
<code class="code">normalize rules t</code> computes the normal form of <code class="code">t</code> w.r.t the set
    of rewrite rules
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALnormalize_wrt_zero">normalize_wrt_zero</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Allows to multiply or divide by any positive number since we consider
      that the monome is equal to (or compared with) zero.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALnth">nth</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALnum_clauses">num_clauses</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.ActiveSet.html#VALnum_clauses">num_clauses</a> [<a href="ProofState_intf.S.ActiveSet.html">ProofState_intf.S.ActiveSet</a>]</td>
<td></td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Literal.Conv.html#VALof_form">of_form</a> [<a href="Literal.Conv.html">Literal.Conv</a>]</td>
<td><div class="info">
Conversion from a formula.
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALof_form">of_form</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Literals.Conv.html#VALof_forms">of_forms</a> [<a href="Literals.Conv.html">Literals.Conv</a>]</td>
<td><div class="info">
Convert a list of atoms into literals
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_forms">of_forms</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Directly from list of formulas
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_forms_axiom">of_forms_axiom</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Construction from formulas as axiom (initial clause)
</div>
</td></tr>
<tr><td><a href="Trail.html#VALof_list">of_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALof_list">of_list</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALof_profile">of_profile</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Select the queue corresponding to the given profile
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_sclause">of_sclause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_statement">of_statement</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Extract a clause from a statement, if any
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALof_term">of_term</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALof_term_exn">of_term_exn</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
try to get a monome from a term.
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALon_add">on_add</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALon_add_clause">on_add_clause</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
signal triggered when a clause is added to the set
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALon_axiom">on_axiom</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALon_empty_clause">on_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Signal triggered when an empty clause is found
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALon_input_lemma">on_input_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Triggered every time a cut is introduced  for an input lemma
      (i.e.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALon_input_statement">on_input_statement</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Triggered on every input statement
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALon_lemma">on_lemma</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALon_new_cst">on_new_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Triggered with new inductive constants
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALon_new_symbol">on_new_symbol</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALon_pre_rewrite">on_pre_rewrite</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALon_remove_clause">on_remove_clause</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
signal triggered when a clause is removed from the set
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALon_rewrite">on_rewrite</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALon_signature_update">on_signature_update</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALon_start">on_start</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Triggered before starting saturation
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALon_theory">on_theory</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALop">op</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALopposite_monome">opposite_monome</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
The opposite monome (in <code class="code">Left</code> and <code class="code">Right</code>), if any.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALopposite_monome_exn">opposite_monome_exn</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Unsafe version of <a href="ArithLit.Focus.html#VALopposite_monome"><code class="code">ArithLit.Focus.opposite_monome</code></a>.
</div>
</td></tr>
<tr><td><a href="Params.html#VALord">ord</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALord">ord</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALord">ord</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALord">ord</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
current ordering on terms
</div>
</td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALparam">param</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only literals that are eligible for paramodulation
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALparams">params</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALparents">parents</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALparse_args">parse_args</a> [<a href="Params.html">Params</a>]</td>
<td><div class="info">
parse_args returns parameters
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALparse_cli">parse_cli</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Parses the file list and parameters, also puts the parameters in
  the state
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALparse_theory_file">parse_theory_file</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Update prover with the content of this file, returns the new results
      or an error
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALparse_theory_files">parse_theory_files</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Parse several files
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALpath_compare">path_compare</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpath_cons">path_cons</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpath_contains_cst">path_contains_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Does the path contain this inductive constant?
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALpath_dominates">path_dominates</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">path_dominates a b</code> is true if <code class="code">b</code> is a suffix of <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALpath_empty">path_empty</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpath_equal">path_equal</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpath_hash">path_hash</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpath_length">path_length</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALpayload">payload</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Obtain the payload
</div>
</td></tr>
<tr><td><a href="BBox.html#VALpayload">payload</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Obtain the payload of this boolean literal, that is, what the literal
    represents
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALpolarity">polarity</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Used for the literal ordering
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALpop_new_results">pop_new_results</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Obtain the difference between last call to <code class="code">pop_new_results p</code>
      and <code class="code">results p</code>, and pop this difference.
</div>
</td></tr>
<tr><td><a href="Literals.html#VALpos">pos</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALpos">pos</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only positive literals
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALpositive_simplify_reflect">positive_simplify_reflect</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td></td></tr>
<tr><td><a href="Rewrite_rule.Set.html#VALpp">pp</a> [<a href="Rewrite_rule.Set.html">Rewrite_rule.Set</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALpp">pp</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALpp">pp</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALpp">pp</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALpp">pp</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALpp">pp</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALpp">pp</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALpp">pp</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALpp">pp</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.html#VALpp">pp</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
pretty print the content of the state
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALpp">pp</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
Prints the proof according to the given input switch
</div>
</td></tr>
<tr><td><a href="Literals.html#VALpp">pp</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALpp">pp</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp">pp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.WithPos.html#VALpp">pp</a> [<a href="Clause_intf.S.WithPos.html">Clause_intf.S.WithPos</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp">pp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALpp">pp</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALpp_bclause">pp_bclause</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpp_case">pp_case</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpp_cst">pp_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALpp_cut_res">pp_cut_res</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALpp_debug">pp_debug</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.S.html#VALpp_decl">pp_decl</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_dot">pp_dot</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
Pretty print the proof as a DOT graph
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALpp_dot_file">pp_dot_file</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
print to dot into a file
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALpp_dot_seq">pp_dot_seq</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
Print a set of proofs as a DOT graph, sharing common subproofs
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALpp_dot_seq_file">pp_dot_seq_file</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
same as <a href="ProofPrint.html#VALpp_dot_seq"><code class="code">ProofPrint.pp_dot_seq</code></a> but into a file
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALpp_full">pp_full</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALpp_kind">pp_kind</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALpp_kind_tstp">pp_kind_tstp</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_normal">pp_normal</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_notrec">pp_notrec</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td><div class="info">
Non recursive printing on formatter
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALpp_path">pp_path</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALpp_payload">pp_payload</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_result">pp_result</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_result_of">pp_result_of</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALpp_rule">pp_rule</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Rewrite_rule.html#VALpp_rule_clause">pp_rule_clause</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td></td></tr>
<tr><td><a href="Rewrite_rule.html#VALpp_rule_term">pp_rule_term</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_set">pp_set</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_set_tstp">pp_set_tstp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALpp_src">pp_src</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALpp_src_tstp">pp_src_tstp</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp_trail">pp_trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_trail">pp_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Printer for boolean trails, that uses <a href="Clause_intf.S.Ctx.html"><code class="code">Clause_intf.S.Ctx</code></a> to display boxes
</div>
</td></tr>
<tr><td><a href="SClause.html#VALpp_trail_tstp">pp_trail_tstp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALpp_tstp">pp_tstp</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALpp_tstp">pp_tstp</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="ProofPrint.html#VALpp_tstp">pp_tstp</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALpp_tstp">pp_tstp</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALpp_tstp">pp_tstp</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp_tstp">pp_tstp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_tstp">pp_tstp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp_tstp_full">pp_tstp_full</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
Print in a toplevel TPTP statement
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_tstp_full">pp_tstp_full</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Print in a cnf() statement
</div>
</td></tr>
<tr><td><a href="SClause.html#VALpp_vars">pp_vars</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALpre_rewrite">pre_rewrite</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td><div class="info">
Pre-processing rules
</div>
</td></tr>
<tr><td><a href="Classify_cst.html#VALprec_constr">prec_constr</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td><div class="info">
Partial order on <code class="code">ID.t</code>, with:
    regular &gt; constant &gt; sub_constant &gt; cstor
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALprecedence">precedence</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALpred">pred</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
-1
</div>
</td></tr>
<tr><td><a href="Params.html#VALpresaturate">presaturate</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Saturate.S.html#VALpresaturate">presaturate</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
Interreduction of the given state, without generating inferences.
</div>
</td></tr>
<tr><td><a href="ArithLit.Util.html#VALprime_decomposition">prime_decomposition</a> [<a href="ArithLit.Util.html">ArithLit.Util</a>]</td>
<td><div class="info">
Decompose the number into a product of power-of-primes.
</div>
</td></tr>
<tr><td><a href="ArithLit.Util.html#VALprimes_leq">primes_leq</a> [<a href="ArithLit.Util.html">ArithLit.Util</a>]</td>
<td><div class="info">
Sequence of prime numbers smaller than (or equal to) the given number
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALprint">print</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td></td></tr>
<tr><td><a href="Phases_impl.html#VALprint">print</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Printing of results
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALprint_lemmas">print_lemmas</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
print the current list of lemmas, and their status
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALprocess_file">process_file</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
<code class="code">process_file f</code> parses <code class="code">f</code>, does the preprocessing phases, including
    type inference, choice of precedence, ordering, etc.
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALprocess_files_and_print">process_files_and_print</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Process each file in the list successively, printing the results.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALproduct">product</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Product by a constant
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALproduct">product</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Monome.html#VALproduct">product</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Product with constant
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALprofile_of_string">profile_of_string</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof">proof</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Obtain the pair <code class="code">conclusion, step</code>
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof_step">proof_step</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Extract its proof from the clause
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALproofs">proofs</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
All proofs for all AC axioms
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALproved_at_0">proved_at_0</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
If the literal has been propagated at decision level 0,
      return its value (which does not depend on the model).
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALprover">prover</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
meta-prover
</div>
</td></tr>
<tr><td><a href="ArithInt.S.html#VALpurify">purify</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td><div class="info">
Purify clauses by replacing arithmetic expressions occurring
      under terms by variables, and adding constraints
</div>
</td></tr>
<tr><td align="left"><br>Q</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALqueue">queue</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Current state of the clause queue
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALquotient">quotient</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
<code class="code">quotient e c</code> tries to divide <code class="code">e</code> by <code class="code">c</code>, returning <code class="code">e/c</code> if
      it is still an integer expression.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="ClauseContext.html#VALraw_lits">raw_lits</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
give access to the underlying literals.
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALreasoner">reasoner</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Meta-level reasoner (inference system)
</div>
</td></tr>
<tr><td><a href="Monome.Int.html#VALreduce_same_factor">reduce_same_factor</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
<code class="code">reduce_same_factor m1 m2 t</code> multiplies <code class="code">m1</code> and <code class="code">m2</code> by
      some constants, so that their coefficient for <code class="code">t</code> is the same.
</div>
</td></tr>
<tr><td><a href="Heuristics.S.html#VALregister">register</a> [<a href="Heuristics.S.html">Heuristics.S</a>]</td>
<td></td></tr>
<tr><td><a href="ArithInt.S.html#VALregister">register</a> [<a href="ArithInt.S.html">ArithInt.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.S.html#VALregister">register</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
Register rules in the environment
</div>
</td></tr>
<tr><td><a href="Superposition.html#VALregister">register</a> [<a href="Superposition.html">Superposition</a>]</td>
<td><div class="info">
Register the superposition module to its Environment's
    mixtbl.
</div>
</td></tr>
<tr><td><a href="Induction_intf.S.html#VALregister">register</a> [<a href="Induction_intf.S.html">Induction_intf.S</a>]</td>
<td><div class="info">
Register the inference rules for inductive reasoning
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALregister">register</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Register inference rules to the environment
</div>
</td></tr>
<tr><td><a href="Selection.html#VALregister">register</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Register new selection function
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALregister">register</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Register an extension to the (current) prover.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALremove">remove</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALremove">remove</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Remove the term
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALremove">remove</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
Remove clauses from the set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_active">remove_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove active clauses
</div>
</td></tr>
<tr><td><a href="Monome.html#VALremove_const">remove_const</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Remove the constant
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_passive">remove_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove passive clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_simpl">remove_simpl</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove simplification clauses
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALrenaming">renaming</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALrenaming_clear">renaming_clear</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Obtain the global renaming.
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALreplace">replace</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
<code class="code">replace a m</code> replaces <code class="code">mf.coeff × mf.term</code> with <code class="code">m</code> where <code class="code">mf</code> is the
      focused monome in <code class="code">a</code>, and return the resulting literal
</div>
</td></tr>
<tr><td><a href="Literals.Pos.html#VALreplace">replace</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
In-place modification of the array, in which the subterm at given
      position is replaced by the <code class="code">by</code> term.
</div>
</td></tr>
<tr><td><a href="Literal.Pos.html#VALreplace">replace</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
Replace subterm, or
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALres">res</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only literals that are eligible for resolution
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALrest">rest</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALrestore">restore</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Restore to a level below in the stack
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALresult">result</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALresults">results</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Sum of all results obtained so far
</div>
</td></tr>
<tr><td><a href="Phases.html#VALreturn">return</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Return a value into the monad
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALreturn">return</a> [<a href="SimplM.html">SimplM</a>]</td>
<td><div class="info">
Alias to <a href="SimplM.html#VALreturn_same"><code class="code">SimplM.return_same</code></a>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALreturn_err">return_err</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALreturn_new">return_new</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALreturn_phase">return_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Finish the given phase
</div>
</td></tr>
<tr><td><a href="Phases.html#VALreturn_phase_err">return_phase_err</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALreturn_same">return_same</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALrewrite">rewrite</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td><div class="info">
List of term rewrite systems
</div>
</td></tr>
<tr><td><a href="Rewrite_rule.html#VALrhs_clause">rhs_clause</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td></td></tr>
<tr><td><a href="Rewrite_rule.html#VALrhs_term">rhs_term</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALroot_save_level">root_save_level</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Pos.html#VALroot_term">root_term</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
Obtain the term at the given position, at the root of the literal.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALroot_terms">root_terms</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
all the terms immediatly under the lit
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALrule">rule</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td><div class="info">
Rule name for Esa/Simplification/Inference steps
</div>
</td></tr>
<tr><td><a href="Rewriting.Key.html#VALrules">rules</a> [<a href="Rewriting.Key.html">Rewriting.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALrun">run</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run m</code> is <code class="code">run_with empty_state m</code>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALrun_parallel">run_parallel</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run_sequentiel l</code> runs each action of the list in succession,
    restarting every time with the initial state (once an action
    has finished, its state is discarded).
</div>
</td></tr>
<tr><td><a href="Phases.html#VALrun_with">run_with</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run_with state m</code> executes the actions in <code class="code">m</code> starting with <code class="code">state</code>,
    returning some value (or error) and the final state.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALsave">save</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Save current state on the stack
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALscale">scale</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Multiply the two literals by some constant so that their focused
      literals have the same coefficient
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALscale">scale</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Scale to the same coefficient
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALscale_power">scale_power</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
For a "divides" literal, bring it to the given power.
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALscan_clause">scan_clause</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
Scan a clause for axiom patterns, and save it
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALscan_statement">scan_statement</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Check whether the statement contains an "AC" attribute, do the proper
      declaration in this case
</div>
</td></tr>
<tr><td><a href="Superposition.html#VALsection">section</a> [<a href="Superposition.html">Superposition</a>]</td>
<td></td></tr>
<tr><td><a href="Rewrite_rule.html#VALsection">section</a> [<a href="Rewrite_rule.html">Rewrite_rule</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALsection">section</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="ProofStep.html#VALsection">section</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Const.html#VALsection">section</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALseed">seed</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALselect">select</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALselect">select</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALselect">select</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Selection.html#VALselect_complex">select_complex</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
x!=y, or ground negative lit, or like select_diff_neg_lit
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_complex_except_RR_horn">select_complex_except_RR_horn</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
if clause is a restricted range horn clause, then select nothing;
    otherwise, like select_complex
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_diff_neg_lit">select_diff_neg_lit</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
arbitrary negative literal with maximal weight difference between sides
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_max_goal">select_max_goal</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Select a maximal negative literal, if any, or nothing
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALselected_lits">selected_lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
get the list of selected literals
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselection_from_string">selection_from_string</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
selection function from string (may fail)
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALselection_fun">selection_fun</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
selection function for clauses
</div>
</td></tr>
<tr><td><a href="Phases.html#VALset">set</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALset">set</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="SClause.html#VALset_flag">set_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
set boolean flag
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALset_flag">set_flag</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
set boolean flag
</div>
</td></tr>
<tr><td><a href="Phases.html#VALset_key">set_key</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALset_ord">set_ord</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALset_printer">set_printer</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
How to print literals?
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALset_profile">set_profile</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALset_selection_fun">set_selection_fun</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALset_sign">set_sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Set the sign of the literal to the given boolean
</div>
</td></tr>
<tr><td><a href="Monome.html#VALset_term">set_term</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Compute_prec.html#VALset_weight_rule">set_weight_rule</a> [<a href="Compute_prec.html">Compute_prec</a>]</td>
<td><div class="info">
Choose the way weights are computed
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALsetup">setup</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
<code class="code">setup ()</code> registers some inference rules to <code class="code">E</code>
</div>
</td></tr>
<tr><td><a href="Ind_types.Make.html#VALsetup">setup</a> [<a href="Ind_types.Make.html">Ind_types.Make</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.S.html#VALsetup">setup</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Register rules in the environment
</div>
</td></tr>
<tr><td><a href="Rewriting.Make.html#VALsetup">setup</a> [<a href="Rewriting.Make.html">Rewriting.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALsetup">setup</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALsetup">setup</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Register on Env
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALsetup_gc">setup_gc</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Phases_impl.html#VALsetup_signal">setup_signal</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALsign">sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Current sign of the literal (positive or negative)
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALsign">sign</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALsign">sign</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Assuming <code class="code">is_constant m</code>, <code class="code">sign m</code> returns the sign of <code class="code">m</code>.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALsign">sign</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALsignature">signature</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALsignature">signature</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALsignature">signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Current signature
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALsimplify">simplify</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Simplify the clause modulo AC
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsimplify">simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Simplify the clause.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsimplify_active_with">simplify_active_with</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Can be called when a simplification relation becomes stronger,
      with the strengthened relation.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALsingleton">singleton</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALsingleton">singleton</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
One term.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALsize">size</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Number of distinct terms.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALsplit">split</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Split a clause into components
</div>
</td></tr>
<tr><td><a href="Monome.html#VALsplit">split</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
<code class="code">split m</code> splits into a monome with positive coefficients, and one
    with negative coefficients.
</div>
</td></tr>
<tr><td><a href="Literal.Pos.html#VALsplit">split</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Monome.Int.Solve.html#VALsplit_solution">split_solution</a> [<a href="Monome.Int.Solve.html">Monome.Int.Solve</a>]</td>
<td><div class="info">
Split the solution into a variable substitution, and a
        list of constraints on non-variable terms
</div>
</td></tr>
<tr><td><a href="Phases.html#VALstart_phase">start_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Start the given phase
</div>
</td></tr>
<tr><td><a href="Clause.html#VALstat_clause_create">stat_clause_create</a> [<a href="Clause.html">Clause</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALstats">stats</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Compute stats
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.html#VALstats">stats</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
Compute statistics
</div>
</td></tr>
<tr><td><a href="ProofStep.html#VALstep">step</a> [<a href="ProofStep.html">ProofStep</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALstep_init">step_init</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
call all functions registered with <a href="Env_intf.S.html#VALadd_step_init"><code class="code">Env_intf.S.add_step_init</code></a>
</div>
</td></tr>
<tr><td><a href="Params.html#VALsteps">steps</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALstring_of_any_phase">string_of_any_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALstring_of_phase">string_of_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALsubsumed_by">subsumed_by</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
List of active clauses subsumed by the given clause
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALsubsumed_by_active_set">subsumed_by_active_set</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
check whether the clause is subsumed by any clause in the set
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALsubsumed_in_active_set">subsumed_in_active_set</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
list of clauses in the active set that are subsumed by the clause
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALsubsumes">subsumes</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
subsumes c1 c2 iff c1 subsumes c2
</div>
</td></tr>
<tr><td><a href="Trail.html#VALsubsumes">subsumes</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
<code class="code">subsumes a b</code> is true iff <code class="code">a</code> is a subset of <code class="code">b</code>
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALsubsumes">subsumes</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Find substitutions such that <code class="code">subst(lit_a)</code> implies <code class="code">lit_b</code>.
</div>
</td></tr>
<tr><td><a href="Literal.html#VALsubsumes">subsumes</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
More general version of <a href="Literal.html#VALmatching"><code class="code">Literal.matching</code></a>, yields <code class="code">subst</code>
    such that <code class="code">subst(lit_a) =&gt; lit_b</code>.
</div>
</td></tr>
<tr><td><a href="Superposition.S.html#VALsubsumes_with">subsumes_with</a> [<a href="Superposition.S.html">Superposition.S</a>]</td>
<td><div class="info">
returns subsuming subst if the first clause subsumes the second one
</div>
</td></tr>
<tr><td><a href="Monome.html#VALsucc">succ</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
+1
</div>
</td></tr>
<tr><td><a href="Monome.Int.Modulo.html#VALsum">sum</a> [<a href="Monome.Int.Modulo.html">Monome.Int.Modulo</a>]</td>
<td><div class="info">
Sum in Z/nZ
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALsum">sum</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALsum">sum</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALsum_list">sum_list</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Sum of a list.
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALsymbols">symbols</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
set of AC symbols
</div>
</td></tr>
<tr><td><a href="Literals.html#VALsymbols">symbols</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Seq.html#VALsymbols">symbols</a> [<a href="Literal.Seq.html">Literal.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALsymbols">symbols</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALsymbols">symbols</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
symbols that occur in the clause
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALsymbols_of_terms">symbols_of_terms</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
set of AC symbols occurring in the given term
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Induction_intf.S.Meta.html#VALt">t</a> [<a href="Induction_intf.S.Meta.html">Induction_intf.S.Meta</a>]</td>
<td><div class="info">
Plugin that encodes the fact that a type is inductive, together
        with the list of its constructor symbols.
</div>
</td></tr>
<tr><td><a href="Literals.Pos.html#VALtail">tail</a> [<a href="Literals.Pos.html">Literals.Pos</a>]</td>
<td><div class="info">
sub-position
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALtake_first">take_first</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Take first element of the queue, or raise Not_found
</div>
</td></tr>
<tr><td><a href="ArithLit.Focus.html#VALterm">term</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Focused term
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALterm">term</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Pos.html#VALterm_pos">term_pos</a> [<a href="Literal.Pos.html">Literal.Pos</a>]</td>
<td><div class="info">
<code class="code">term_pos lit p = snd (cut lit p)</code>, the subterm position.
</div>
</td></tr>
<tr><td><a href="ArithLit.Seq.html#VALterms">terms</a> [<a href="ArithLit.Seq.html">ArithLit.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Seq.html#VALterms">terms</a> [<a href="Monome.Seq.html">Monome.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALterms">terms</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
List of terms that occur in the monome with non-nul coefficients
</div>
</td></tr>
<tr><td><a href="Literals.Seq.html#VALterms">terms</a> [<a href="Literals.Seq.html">Literals.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Seq.html#VALterms">terms</a> [<a href="Literal.Seq.html">Literal.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALterms">terms</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="MetaProverState_intf.S.Result.html#VALtheories">theories</a> [<a href="MetaProverState_intf.S.Result.html">MetaProverState_intf.S.Result</a>]</td>
<td><div class="info">
Detected theories
</div>
</td></tr>
<tr><td><a href="MetaProverState_intf.S.html#VALtheories">theories</a> [<a href="MetaProverState_intf.S.html">MetaProverState_intf.S</a>]</td>
<td><div class="info">
List of theories detected so far
</div>
</td></tr>
<tr><td><a href="Params.html#VALtimeout">timeout</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALto_form">to_form</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td><div class="info">
Conversion into a simple literal
</div>
</td></tr>
<tr><td><a href="Literals.Seq.html#VALto_form">to_form</a> [<a href="Literals.Seq.html">Literals.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALto_form">to_form</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Make a 'or' formula from literals
</div>
</td></tr>
<tr><td><a href="Literal.Conv.html#VALto_form">to_form</a> [<a href="Literal.Conv.html">Literal.Conv</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALto_form">to_form</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.Conv.html#VALto_forms">to_forms</a> [<a href="Literals.Conv.html">Literals.Conv</a>]</td>
<td><div class="info">
To list of formulas
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_forms">to_forms</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Easy iteration on an abstract view of literals
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALto_hooks">to_hooks</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALto_int">to_int</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALto_list">to_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALto_monome">to_monome</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Conversion back to an unfocused monome
</div>
</td></tr>
<tr><td><a href="ArithLit.Seq.html#VALto_multiset">to_multiset</a> [<a href="ArithLit.Seq.html">ArithLit.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALto_multiset">to_multiset</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
Multiset of terms with multiplicity
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_sclause">to_sclause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALto_seq">to_seq</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALto_string">to_string</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALto_string">to_string</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALto_string">to_string</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALto_string">to_string</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALto_string">to_string</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_string">to_string</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Debug printing to a  string
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALto_string">to_string</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Int.html#VALto_term">to_term</a> [<a href="Monome.Int.html">Monome.Int</a>]</td>
<td><div class="info">
convert back to a term
</div>
</td></tr>
<tr><td><a href="SClause.html#VALtrail">trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail">trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Get the clause's trail
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail_l">trail_l</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Merge the trails of several clauses
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail_subsumes">trail_subsumes</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
<code class="code">trail_subsumes c1 c2 = Trail.subsumes (get_trail c1) (get_trail c2)</code>
</div>
</td></tr>
<tr><td><a href="ProofPrint.html#VALtraverse">traverse</a> [<a href="ProofPrint.html">ProofPrint</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALty">ty</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
type of the monome (int or rat)
</div>
</td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Monome.Int.Modulo.html#VALuminus">uminus</a> [<a href="Monome.Int.Modulo.html">Monome.Int.Modulo</a>]</td>
<td><div class="info">
Additive inverse in Z/nZ
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALuminus">uminus</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALuminus">uminus</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALunary_depth">unary_depth</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALunfocus">unfocus</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Conversion back to a literal
</div>
</td></tr>
<tr><td><a href="Literal.View.html#VALunfocus_arith">unfocus_arith</a> [<a href="Literal.View.html">Literal.View</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Focus.html#VALunify">unify</a> [<a href="ArithLit.Focus.html">ArithLit.Focus</a>]</td>
<td><div class="info">
Unify the two focused terms, and possibly other terms of their
      respective focused monomes; yield the new literals accounting for
      the unification along with the unifier
</div>
</td></tr>
<tr><td><a href="ArithLit.html#VALunify">unify</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALunify">unify</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALunify">unify</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Focus.html#VALunify_ff">unify_ff</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Unify two focused monomes.
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALunify_mm">unify_mm</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Unify parts of two monomes <code class="code">m1</code> and <code class="code">m2</code>.
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALunify_self">unify_self</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Extend the substitution to other terms within the focused monome,
      if possible.
</div>
</td></tr>
<tr><td><a href="Monome.Focus.html#VALunify_self_monome">unify_self_monome</a> [<a href="Monome.Focus.html">Monome.Focus</a>]</td>
<td><div class="info">
Unify at least two terms of the monome together
</div>
</td></tr>
<tr><td><a href="Phases.html#VALupdate">update</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">update ~f</code> changes the state using <code class="code">f</code>
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALupdate_flex_state">update_flex_state</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
<code class="code">update_flex_state f</code> changes <code class="code">flex_state ()</code> using <code class="code">f</code>
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALupdate_proof">update_proof</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
<code class="code">update_proof c f</code> creates a new clause that is
      similar to <code class="code">c</code> in all aspects, but with
      the proof <code class="code">f (proof_step c)</code>
</div>
</td></tr>
<tr><td><a href="SClause.html#VALupdate_trail">update_trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALupdate_trail">update_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Change the trail.
</div>
</td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALvaluation">valuation</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Assuming the last call to <a href="Sat_solver_intf.S.html#VALcheck"><code class="code">Sat_solver_intf.S.check</code></a> returned <code class="code">Sat</code>, get the boolean
      valuation for this (positive) literal in the current model.
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALvaluation_level">valuation_level</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Gives the value of a literal in the model, as well as its
      decision level.
</div>
</td></tr>
<tr><td><a href="Monome.html#VALvar_occurs">var_occurs</a> [<a href="Monome.html">Monome</a>]</td>
<td><div class="info">
Does the variable occur in the monome?
</div>
</td></tr>
<tr><td><a href="Literal.html#VALvar_occurs">var_occurs</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.html#VALvariant">variant</a> [<a href="ArithLit.html">ArithLit</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.html#VALvariant">variant</a> [<a href="Monome.html">Monome</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALvariant">variant</a> [<a href="Literals.html">Literals</a>]</td>
<td><div class="info">
Variant checking (alpha-equivalence).
</div>
</td></tr>
<tr><td><a href="Literal.html#VALvariant">variant</a> [<a href="Literal.html">Literal</a>]</td>
<td></td></tr>
<tr><td><a href="ArithLit.Seq.html#VALvars">vars</a> [<a href="ArithLit.Seq.html">ArithLit.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Monome.Seq.html#VALvars">vars</a> [<a href="Monome.Seq.html">Monome.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.Seq.html#VALvars">vars</a> [<a href="Literals.Seq.html">Literals.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literals.html#VALvars">vars</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.Seq.html#VALvars">vars</a> [<a href="Literal.Seq.html">Literal.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALvars">vars</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
gather variables
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALvars">vars</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALversion">version</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Const.html#VALversion">version</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Literals.html#VALweight">weight</a> [<a href="Literals.html">Literals</a>]</td>
<td></td></tr>
<tr><td><a href="Literal.html#VALweight">weight</a> [<a href="Literal.html">Literal</a>]</td>
<td><div class="info">
weight of the lit (sum of weights of terms)
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALweight">weight</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALwith_phase">with_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Start phase, call <code class="code">f ()</code> to get the result, return its result
    using <a href="Phases.html#VALreturn_phase"><code class="code">Phases.return_phase</code></a>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALwith_phase1">with_phase1</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALwith_phase2">with_phase2</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
</table>
</body>
</html>