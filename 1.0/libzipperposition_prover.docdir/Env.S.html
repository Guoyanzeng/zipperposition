<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Env.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="ClauseQueue" rel="Chapter" href="ClauseQueue.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="SClause" rel="Chapter" href="SClause.html">
<link title="Const" rel="Chapter" href="Const.html">
<link title="Extensions" rel="Chapter" href="Extensions.html">
<link title="Literal" rel="Chapter" href="Literal.html">
<link title="Literals" rel="Chapter" href="Literals.html">
<link title="Ctx" rel="Chapter" href="Ctx.html">
<link title="ProofStep" rel="Chapter" href="ProofStep.html">
<link title="ProofPrint" rel="Chapter" href="ProofPrint.html">
<link title="ProofState" rel="Chapter" href="ProofState.html">
<link title="Saturate" rel="Chapter" href="Saturate.html">
<link title="Selection" rel="Chapter" href="Selection.html">
<link title="AC" rel="Chapter" href="AC.html">
<link title="AC_intf" rel="Chapter" href="AC_intf.html">
<link title="SimplM" rel="Chapter" href="SimplM.html">
<link title="Compute_prec" rel="Chapter" href="Compute_prec.html">
<link title="Params" rel="Chapter" href="Params.html">
<link title="Env" rel="Chapter" href="Env.html">
<link title="Monome" rel="Chapter" href="Monome.html">
<link title="ArithLit" rel="Chapter" href="ArithLit.html">
<link title="Signals" rel="Chapter" href="Signals.html">
<link title="Multisets" rel="Chapter" href="Multisets.html">
<link title="Ctx_intf" rel="Chapter" href="Ctx_intf.html">
<link title="Clause_intf" rel="Chapter" href="Clause_intf.html">
<link title="Env_intf" rel="Chapter" href="Env_intf.html">
<link title="ProofState_intf" rel="Chapter" href="ProofState_intf.html">
<link title="BBox" rel="Chapter" href="BBox.html">
<link title="ClauseContext" rel="Chapter" href="ClauseContext.html">
<link title="ClauseQueue_intf" rel="Chapter" href="ClauseQueue_intf.html">
<link title="Bool_lit" rel="Chapter" href="Bool_lit.html">
<link title="Bool_lit_intf" rel="Chapter" href="Bool_lit_intf.html">
<link title="Sat_solver" rel="Chapter" href="Sat_solver.html">
<link title="Sat_solver_intf" rel="Chapter" href="Sat_solver_intf.html">
<link title="Trail" rel="Chapter" href="Trail.html">
<link title="Ind_cst" rel="Chapter" href="Ind_cst.html">
<link title="Phases" rel="Chapter" href="Phases.html">
<link title="Phases_impl" rel="Chapter" href="Phases_impl.html">
<link title="Flex_state" rel="Chapter" href="Flex_state.html">
<link title="Classify_cst" rel="Chapter" href="Classify_cst.html">
<link title="Rewrite_rule" rel="Chapter" href="Rewrite_rule.html">
<link title="Avatar" rel="Chapter" href="Avatar.html">
<link title="Avatar_intf" rel="Chapter" href="Avatar_intf.html">
<link title="Induction" rel="Chapter" href="Induction.html">
<link title="Induction_intf" rel="Chapter" href="Induction_intf.html">
<link title="Superposition" rel="Chapter" href="Superposition.html">
<link title="Rewriting" rel="Chapter" href="Rewriting.html">
<link title="EnumTypes" rel="Chapter" href="EnumTypes.html">
<link title="ArithInt" rel="Chapter" href="ArithInt.html">
<link title="Heuristics" rel="Chapter" href="Heuristics.html">
<link title="Ind_types" rel="Chapter" href="Ind_types.html">
<link title="MetaProverState" rel="Chapter" href="MetaProverState.html">
<link title="MetaProverState_intf" rel="Chapter" href="MetaProverState_intf.html"><link title="Modify the Env" rel="Section" href="#2_ModifytheEnv">
<link title="Use the Env" rel="Section" href="#2_UsetheEnv">
<link title="High level operations" rel="Section" href="#2_Highleveloperations">
<link title="Misc" rel="Section" href="#2_Misc">
<title>Env.S</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Env.html" title="Env">Up</a>
&nbsp;</div>
<h1>Module type <a href="type_Env.S.html">Env.S</a></h1>

<pre><span class="keyword">module type</span> S = <code class="type"><a href="Env_intf.S.html">Env_intf.S</a></code></pre><div class="info modtype top">
<h2 id="2_Signature">Signature</h2><br>
</div>
<hr width="100%">

<pre><span class="keyword">module</span> <a href="Env_intf.S.Ctx.html">Ctx</a>: <code class="type"><a href="Ctx.S.html">Ctx.S</a></code><code class="type"> </code></pre>
<pre><span class="keyword">module</span> <a href="Env_intf.S.C.html">C</a>: <code class="type"><a href="Clause.S.html">Clause.S</a></code><code class="type">  with module <a href="Ctx.html">Ctx</a> = <a href="Ctx.html">Ctx</a></code></pre>
<pre><span class="keyword">module</span> <a href="Env_intf.S.ProofState.html">ProofState</a>: <code class="type"><a href="ProofState.S.html">ProofState.S</a></code><code class="type">  with module C = C and module <a href="Ctx.html">Ctx</a> = <a href="Ctx.html">Ctx</a></code></pre>
<pre><span id="TYPEinf_rule"><span class="keyword">type</span> <code class="type"></code>inf_rule</span> = <code class="type">C.t -> C.t list</code> </pre>
<div class="info ">
An inference returns a list of conclusions<br>
</div>


<pre><span id="TYPEgenerate_rule"><span class="keyword">type</span> <code class="type"></code>generate_rule</span> = <code class="type">unit -> C.t list</code> </pre>
<div class="info ">
Generation of clauses regardless of current clause<br>
</div>


<pre><span id="TYPEbinary_inf_rule"><span class="keyword">type</span> <code class="type"></code>binary_inf_rule</span> = <code class="type"><a href="Env_intf.S.html#TYPEinf_rule">inf_rule</a></code> </pre>


<pre><span id="TYPEunary_inf_rule"><span class="keyword">type</span> <code class="type"></code>unary_inf_rule</span> = <code class="type"><a href="Env_intf.S.html#TYPEinf_rule">inf_rule</a></code> </pre>


<pre><span id="TYPEsimplify_rule"><span class="keyword">type</span> <code class="type"></code>simplify_rule</span> = <code class="type">C.t -> C.t <a href="SimplM.html#TYPEt">SimplM.t</a></code> </pre>
<div class="info ">
Simplify the clause structurally (basic simplifications),
      in the simplification monad.
      <code class="code">(c, `Same)</code> means the clause has not been simplified;
      <code class="code">(c, `New)</code> means the clause has been simplified at least once<br>
</div>


<pre><span id="TYPEactive_simplify_rule"><span class="keyword">type</span> <code class="type"></code>active_simplify_rule</span> = <code class="type"><a href="Env_intf.S.html#TYPEsimplify_rule">simplify_rule</a></code> </pre>


<pre><span id="TYPErw_simplify_rule"><span class="keyword">type</span> <code class="type"></code>rw_simplify_rule</span> = <code class="type"><a href="Env_intf.S.html#TYPEsimplify_rule">simplify_rule</a></code> </pre>


<pre><span id="TYPEbackward_simplify_rule"><span class="keyword">type</span> <code class="type"></code>backward_simplify_rule</span> = <code class="type">C.t -> C.ClauseSet.t</code> </pre>
<div class="info ">
backward simplification by a unit clause. It returns a set of
      active clauses that can potentially be simplified by the given clause.
      <code class="code">backward_simplify c</code> therefore returns a subset of
      <code class="code">ProofState.ActiveSet.clauses ()</code><br>
</div>


<pre><span id="TYPEredundant_rule"><span class="keyword">type</span> <code class="type"></code>redundant_rule</span> = <code class="type">C.t -> bool</code> </pre>
<div class="info ">
check whether the clause is redundant w.r.t the set<br>
</div>


<pre><span id="TYPEbackward_redundant_rule"><span class="keyword">type</span> <code class="type"></code>backward_redundant_rule</span> = <code class="type">C.ClauseSet.t -> C.t -> C.ClauseSet.t</code> </pre>
<div class="info ">
find redundant clauses in <code class="code">ProofState.ActiveSet</code> w.r.t the clause.
       first param is the set of already known redundant clause, the rule
       should add clauses to it<br>
</div>


<pre><span id="TYPEis_trivial_rule"><span class="keyword">type</span> <code class="type"></code>is_trivial_rule</span> = <code class="type">C.t -> bool</code> </pre>
<div class="info ">
Rule that checks whether the clause is trivial (a tautology)<br>
</div>


<pre><span id="TYPEterm_rewrite_rule"><span class="keyword">type</span> <code class="type"></code>term_rewrite_rule</span> = <code class="type">Libzipperposition.FOTerm.t -> Libzipperposition.FOTerm.t option</code> </pre>
<div class="info ">
Rewrite rule on terms<br>
</div>


<pre><span id="TYPElit_rewrite_rule"><span class="keyword">type</span> <code class="type"></code>lit_rewrite_rule</span> = <code class="type"><a href="Literal.html#TYPEt">Literal.t</a> -> <a href="Literal.html#TYPEt">Literal.t</a> option</code> </pre>
<div class="info ">
Rewrite rule on literals<br>
</div>


<pre><span id="TYPEmulti_simpl_rule"><span class="keyword">type</span> <code class="type"></code>multi_simpl_rule</span> = <code class="type">C.t -> C.t list option</code> </pre>
<div class="info ">
(maybe) rewrite a clause to a set of clauses.
      Must return <code class="code">None</code> if the clause is unmodified<br>
</div>


<pre><code><span id="TYPEconversion_result"><span class="keyword">type</span> <code class="type">'a</code> conversion_result</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconversion_result.CR_skip"><span class="constructor">CR_skip</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
rule didn't fire<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconversion_result.CR_add"><span class="constructor">CR_add</span></span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
add this to the result<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconversion_result.CR_return"><span class="constructor">CR_return</span></span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
shortcut the remaining rules, return this<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="TYPEclause_conversion_rule"><span class="keyword">type</span> <code class="type"></code>clause_conversion_rule</span> = <code class="type">Libzipperposition.Statement.clause_t -><br>       C.t list <a href="Env_intf.S.html#TYPEconversion_result">conversion_result</a></code> </pre>
<div class="info ">
A hook to convert a particular statement into a list
      of clauses<br>
</div>

<br>
<h2 id="2_ModifytheEnv">Modify the Env</h2><br>

<pre><span id="VALadd_passive"><span class="keyword">val</span> add_passive</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Add passive clauses<br>
</div>

<pre><span id="VALadd_active"><span class="keyword">val</span> add_active</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Add active clauses<br>
</div>

<pre><span id="VALadd_simpl"><span class="keyword">val</span> add_simpl</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Add simplification clauses<br>
</div>

<pre><span id="VALremove_passive"><span class="keyword">val</span> remove_passive</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Remove passive clauses<br>
</div>

<pre><span id="VALremove_active"><span class="keyword">val</span> remove_active</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Remove active clauses<br>
</div>

<pre><span id="VALremove_simpl"><span class="keyword">val</span> remove_simpl</span> : <code class="type">C.t Sequence.t -> unit</code></pre><div class="info ">
Remove simplification clauses<br>
</div>

<pre><span id="VALget_passive"><span class="keyword">val</span> get_passive</span> : <code class="type">unit -> C.t Sequence.t</code></pre><div class="info ">
Passive clauses<br>
</div>

<pre><span id="VALget_active"><span class="keyword">val</span> get_active</span> : <code class="type">unit -> C.t Sequence.t</code></pre><div class="info ">
Active clauses<br>
</div>

<pre><span id="VALadd_binary_inf"><span class="keyword">val</span> add_binary_inf</span> : <code class="type">string -> <a href="Env_intf.S.html#TYPEbinary_inf_rule">binary_inf_rule</a> -> unit</code></pre><div class="info ">
Add a binary inference rule<br>
</div>

<pre><span id="VALadd_unary_inf"><span class="keyword">val</span> add_unary_inf</span> : <code class="type">string -> <a href="Env_intf.S.html#TYPEunary_inf_rule">unary_inf_rule</a> -> unit</code></pre><div class="info ">
Add a unary inference rule<br>
</div>

<pre><span id="VALadd_rw_simplify"><span class="keyword">val</span> add_rw_simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPErw_simplify_rule">rw_simplify_rule</a> -> unit</code></pre><div class="info ">
Add forward rewriting rule<br>
</div>

<pre><span id="VALadd_active_simplify"><span class="keyword">val</span> add_active_simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPEactive_simplify_rule">active_simplify_rule</a> -> unit</code></pre><div class="info ">
Add simplification w.r.t active set<br>
</div>

<pre><span id="VALadd_backward_simplify"><span class="keyword">val</span> add_backward_simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPEbackward_simplify_rule">backward_simplify_rule</a> -> unit</code></pre><div class="info ">
Add simplification of the active set<br>
</div>

<pre><span id="VALadd_redundant"><span class="keyword">val</span> add_redundant</span> : <code class="type"><a href="Env_intf.S.html#TYPEredundant_rule">redundant_rule</a> -> unit</code></pre><div class="info ">
Add redundancy criterion w.r.t. the active set<br>
</div>

<pre><span id="VALadd_backward_redundant"><span class="keyword">val</span> add_backward_redundant</span> : <code class="type"><a href="Env_intf.S.html#TYPEbackward_redundant_rule">backward_redundant_rule</a> -> unit</code></pre><div class="info ">
Add rule that finds redundant clauses within active set<br>
</div>

<pre><span id="VALadd_simplify"><span class="keyword">val</span> add_simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPEsimplify_rule">simplify_rule</a> -> unit</code></pre><div class="info ">
Add basic simplification rule<br>
</div>

<pre><span id="VALadd_multi_simpl_rule"><span class="keyword">val</span> add_multi_simpl_rule</span> : <code class="type"><a href="Env_intf.S.html#TYPEmulti_simpl_rule">multi_simpl_rule</a> -> unit</code></pre><div class="info ">
Add a multi-clause simplification rule<br>
</div>

<pre><span id="VALadd_is_trivial"><span class="keyword">val</span> add_is_trivial</span> : <code class="type"><a href="Env_intf.S.html#TYPEis_trivial_rule">is_trivial_rule</a> -> unit</code></pre><div class="info ">
Add tautology detection rule<br>
</div>

<pre><span id="VALadd_rewrite_rule"><span class="keyword">val</span> add_rewrite_rule</span> : <code class="type">string -> <a href="Env_intf.S.html#TYPEterm_rewrite_rule">term_rewrite_rule</a> -> unit</code></pre><div class="info ">
Add a term rewrite rule<br>
</div>

<pre><span id="VALadd_lit_rule"><span class="keyword">val</span> add_lit_rule</span> : <code class="type">string -> <a href="Env_intf.S.html#TYPElit_rewrite_rule">lit_rewrite_rule</a> -> unit</code></pre><div class="info ">
Add a literal rewrite rule<br>
</div>

<pre><span id="VALadd_generate"><span class="keyword">val</span> add_generate</span> : <code class="type">string -> <a href="Env_intf.S.html#TYPEgenerate_rule">generate_rule</a> -> unit</code></pre>
<pre><span id="VALcr_skip"><span class="keyword">val</span> cr_skip</span> : <code class="type">'a <a href="Env_intf.S.html#TYPEconversion_result">conversion_result</a></code></pre>
<pre><span id="VALcr_return"><span class="keyword">val</span> cr_return</span> : <code class="type">'a -> 'a <a href="Env_intf.S.html#TYPEconversion_result">conversion_result</a></code></pre>
<pre><span id="VALcr_add"><span class="keyword">val</span> cr_add</span> : <code class="type">'a -> 'a <a href="Env_intf.S.html#TYPEconversion_result">conversion_result</a></code></pre>
<pre><span id="VALadd_clause_conversion"><span class="keyword">val</span> add_clause_conversion</span> : <code class="type"><a href="Env_intf.S.html#TYPEclause_conversion_rule">clause_conversion_rule</a> -> unit</code></pre>
<pre><span id="VALadd_step_init"><span class="keyword">val</span> add_step_init</span> : <code class="type">(unit -> unit) -> unit</code></pre><div class="info ">
add a function to call before each saturation step<br>
</div>
<br>
<h2 id="2_UsetheEnv">Use the Env</h2><br>

<pre><span id="VALmulti_simplify"><span class="keyword">val</span> multi_simplify</span> : <code class="type">C.t -> C.t list option</code></pre><div class="info ">
Can we simplify the clause into a List of simplified clauses?<br>
</div>

<pre><span id="VALparams"><span class="keyword">val</span> params</span> : <code class="type"><a href="Params.html#TYPEt">Params.t</a></code></pre>
<pre><span id="VALget_empty_clauses"><span class="keyword">val</span> get_empty_clauses</span> : <code class="type">unit -> C.ClauseSet.t</code></pre><div class="info ">
Set of known empty clauses<br>
</div>

<pre><span id="VALget_some_empty_clause"><span class="keyword">val</span> get_some_empty_clause</span> : <code class="type">unit -> C.t option</code></pre><div class="info ">
Some empty clause, if present, otherwise None<br>
</div>

<pre><span id="VALhas_empty_clause"><span class="keyword">val</span> has_empty_clause</span> : <code class="type">unit -> bool</code></pre><div class="info ">
Is there an empty clause?<br>
</div>

<pre><span id="VALon_start"><span class="keyword">val</span> on_start</span> : <code class="type">unit Signal.t</code></pre><div class="info ">
Triggered before starting saturation<br>
</div>

<pre><span id="VALon_input_statement"><span class="keyword">val</span> on_input_statement</span> : <code class="type">Libzipperposition.Statement.clause_t Signal.t</code></pre><div class="info ">
Triggered on every input statement<br>
</div>

<pre><span id="VALconvert_input_statements"><span class="keyword">val</span> convert_input_statements</span> : <code class="type">Libzipperposition.Statement.clause_t CCVector.ro_vector -><br>       C.t CCVector.ro_vector</code></pre><div class="info ">
Convert raw input statements into clauses, triggering
      <a href="Env_intf.S.html#VALon_input_statement"><code class="code">Env_intf.S.on_input_statement</code></a><br>
</div>

<pre><span id="VALon_empty_clause"><span class="keyword">val</span> on_empty_clause</span> : <code class="type">C.t Signal.t</code></pre><div class="info ">
Signal triggered when an empty clause is found<br>
</div>

<pre><span id="VALord"><span class="keyword">val</span> ord</span> : <code class="type">unit -> Libzipperposition.Ordering.t</code></pre>
<pre><span id="VALprecedence"><span class="keyword">val</span> precedence</span> : <code class="type">unit -> Libzipperposition.Precedence.t</code></pre>
<pre><span id="VALsignature"><span class="keyword">val</span> signature</span> : <code class="type">unit -> Libzipperposition.Signature.t</code></pre>
<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type">unit CCFormat.printer</code></pre>
<pre><span id="VALpp_full"><span class="keyword">val</span> pp_full</span> : <code class="type">unit CCFormat.printer</code></pre><br>
<h2 id="2_Highleveloperations">High level operations</h2><br>

<pre><span id="TYPEstats"><span class="keyword">type</span> <code class="type"></code>stats</span> = <code class="type">int * int * int</code> </pre>
<div class="info ">
statistics on clauses : num active, num passive, num simplification<br>
</div>


<pre><span id="VALstats"><span class="keyword">val</span> stats</span> : <code class="type">unit -> <a href="Env_intf.S.html#TYPEstats">stats</a></code></pre><div class="info ">
Compute stats<br>
</div>

<pre><span id="VALnext_passive"><span class="keyword">val</span> next_passive</span> : <code class="type">unit -> C.t option</code></pre><div class="info ">
Extract next passive clause<br>
</div>

<pre><span id="VALdo_binary_inferences"><span class="keyword">val</span> do_binary_inferences</span> : <code class="type">C.t -> C.t Sequence.t</code></pre><div class="info ">
do binary inferences that involve the given clause<br>
</div>

<pre><span id="VALdo_unary_inferences"><span class="keyword">val</span> do_unary_inferences</span> : <code class="type">C.t -> C.t Sequence.t</code></pre><div class="info ">
do unary inferences for the given clause<br>
</div>

<pre><span id="VALdo_generate"><span class="keyword">val</span> do_generate</span> : <code class="type">unit -> C.t Sequence.t</code></pre><div class="info ">
do generating inferences<br>
</div>

<pre><span id="VALis_trivial"><span class="keyword">val</span> is_trivial</span> : <code class="type">C.t -> bool</code></pre><div class="info ">
Check whether the clause is trivial<br>
</div>

<pre><span id="VALis_active"><span class="keyword">val</span> is_active</span> : <code class="type">C.t -> bool</code></pre><div class="info ">
Is the clause in the active set<br>
</div>

<pre><span id="VALis_passive"><span class="keyword">val</span> is_passive</span> : <code class="type">C.t -> bool</code></pre><div class="info ">
Is the clause a passive clause?<br>
</div>

<pre><span id="VALsimplify"><span class="keyword">val</span> simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPEsimplify_rule">simplify_rule</a></code></pre><div class="info ">
Simplify the clause.<br>
</div>

<pre><span id="VALbackward_simplify"><span class="keyword">val</span> backward_simplify</span> : <code class="type">C.t -> C.ClauseSet.t * C.t Sequence.t</code></pre><div class="info ">
Perform backward simplification with the given clause. It returns the
      CSet of clauses that become redundant, and the sequence of those
      very same clauses after simplification.<br>
</div>

<pre><span id="VALsimplify_active_with"><span class="keyword">val</span> simplify_active_with</span> : <code class="type">(C.t -> C.t list option) -> unit</code></pre><div class="info ">
Can be called when a simplification relation becomes stronger,
      with the strengthened relation.
      (e.g. new axioms should be declared because a theory was detected).
      This will go through the whole active set, trying to simplify clauses
      with the given function. Simplified clauses will be put back in the
      passive set.<br>
</div>

<pre><span id="VALforward_simplify"><span class="keyword">val</span> forward_simplify</span> : <code class="type"><a href="Env_intf.S.html#TYPEsimplify_rule">simplify_rule</a></code></pre><div class="info ">
Simplify the clause w.r.t to the active set and experts<br>
</div>

<pre><span id="VALgenerate"><span class="keyword">val</span> generate</span> : <code class="type">C.t -> C.t Sequence.t</code></pre><div class="info ">
Perform all generating inferences<br>
</div>

<pre><span id="VALis_redundant"><span class="keyword">val</span> is_redundant</span> : <code class="type">C.t -> bool</code></pre><div class="info ">
Is the given clause redundant w.r.t the active set?<br>
</div>

<pre><span id="VALsubsumed_by"><span class="keyword">val</span> subsumed_by</span> : <code class="type">C.t -> C.ClauseSet.t</code></pre><div class="info ">
List of active clauses subsumed by the given clause<br>
</div>

<pre><span id="VALall_simplify"><span class="keyword">val</span> all_simplify</span> : <code class="type">C.t -> C.t list <a href="SimplM.html#TYPEt">SimplM.t</a></code></pre><div class="info ">
Use all simplification rules to convert a clause into a set
      of maximally simplified clause (or <code class="code">[]</code> if they are all trivial).<br>
</div>

<pre><span id="VALstep_init"><span class="keyword">val</span> step_init</span> : <code class="type">unit -> unit</code></pre><div class="info ">
call all functions registered with <a href="Env_intf.S.html#VALadd_step_init"><code class="code">Env_intf.S.add_step_init</code></a><br>
</div>
<br>
<h2 id="2_Misc">Misc</h2><br>

<pre><span id="VALflex_state"><span class="keyword">val</span> flex_state</span> : <code class="type">unit -> <a href="Flex_state.html#TYPEt">Flex_state.t</a></code></pre><div class="info ">
State inherited from configuration<br>
</div>

<pre><span id="VALupdate_flex_state"><span class="keyword">val</span> update_flex_state</span> : <code class="type">(<a href="Flex_state.html#TYPEt">Flex_state.t</a> -> <a href="Flex_state.html#TYPEt">Flex_state.t</a>) -> unit</code></pre><div class="info ">
<code class="code">update_flex_state f</code> changes <code class="code">flex_state ()</code> using <code class="code">f</code><br>
</div>

<pre><span id="VALflex_add"><span class="keyword">val</span> flex_add</span> : <code class="type">'a <a href="Flex_state.html#TYPEkey">Flex_state.key</a> -> 'a -> unit</code></pre><div class="info ">
add <code class="code">k -&gt; v</code> to the flex state<br>
</div>

<pre><span id="VALflex_get"><span class="keyword">val</span> flex_get</span> : <code class="type">'a <a href="Flex_state.html#TYPEkey">Flex_state.key</a> -> 'a</code></pre><div class="info ">
<code class="code">flex_get k</code> is the same as <code class="code">Flex_state.get_exn k (flex_state ())</code>.<br>
<b>Raises</b> <code>Not_found</code> if the key is not present<br>
</div>
</body></html>