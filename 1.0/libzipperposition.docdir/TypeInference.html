<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Unif_intf.html">
<link rel="next" href="Options.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="InnerTerm" rel="Chapter" href="InnerTerm.html">
<link title="FOTerm" rel="Chapter" href="FOTerm.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="Util" rel="Chapter" href="Util.html">
<link title="STerm" rel="Chapter" href="STerm.html">
<link title="Interfaces" rel="Chapter" href="Interfaces.html">
<link title="DBEnv" rel="Chapter" href="DBEnv.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="HVar" rel="Chapter" href="HVar.html">
<link title="Substs" rel="Chapter" href="Substs.html">
<link title="Unif" rel="Chapter" href="Unif.html">
<link title="Signature" rel="Chapter" href="Signature.html">
<link title="Scoped" rel="Chapter" href="Scoped.html">
<link title="Unif_intf" rel="Chapter" href="Unif_intf.html">
<link title="TypeInference" rel="Chapter" href="TypeInference.html">
<link title="Options" rel="Chapter" href="Options.html">
<link title="Comparison" rel="Chapter" href="Comparison.html">
<link title="Precedence" rel="Chapter" href="Precedence.html">
<link title="Builtin" rel="Chapter" href="Builtin.html">
<link title="Ordering" rel="Chapter" href="Ordering.html">
<link title="Skolem" rel="Chapter" href="Skolem.html">
<link title="Cnf" rel="Chapter" href="Cnf.html">
<link title="ID" rel="Chapter" href="ID.html">
<link title="IDOrBuiltin" rel="Chapter" href="IDOrBuiltin.html">
<link title="SLiteral" rel="Chapter" href="SLiteral.html">
<link title="Index" rel="Chapter" href="Index.html">
<link title="Index_intf" rel="Chapter" href="Index_intf.html">
<link title="Dtree" rel="Chapter" href="Dtree.html">
<link title="Fingerprint" rel="Chapter" href="Fingerprint.html">
<link title="NPDtree" rel="Chapter" href="NPDtree.html">
<link title="Binder" rel="Chapter" href="Binder.html">
<link title="Congruence" rel="Chapter" href="Congruence.html">
<link title="FeatureVector" rel="Chapter" href="FeatureVector.html">
<link title="UntypedAST" rel="Chapter" href="UntypedAST.html">
<link title="Ind_ty" rel="Chapter" href="Ind_ty.html">
<link title="TypedSTerm" rel="Chapter" href="TypedSTerm.html">
<link title="Statement" rel="Chapter" href="Statement.html">
<link title="StatementSrc" rel="Chapter" href="StatementSrc.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="ParseLocation" rel="Chapter" href="ParseLocation.html">
<link title="Multiset" rel="Chapter" href="Multiset.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="IArray" rel="Chapter" href="IArray.html">
<link title="AllocCache" rel="Chapter" href="AllocCache.html">
<link title="Multiset_intf" rel="Chapter" href="Multiset_intf.html"><link title="Types for Builtins" rel="Section" href="#2_TypesforBuiltins">
<link title="Typing context" rel="Section" href="#2_Typingcontext">
<link title="Hindley-Milner Type Inference" rel="Section" href="#2_HindleyMilnerTypeInference">
<link title="Statements" rel="Section" href="#2_Statements">
<link title="Constraining types" rel="Subsection" href="#3_Constrainingtypes">
<title>TypeInference</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Unif_intf.html" title="Unif_intf">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Options.html" title="Options">Next</a>
</div>
<h1>Module <a href="type_TypeInference.html">TypeInference</a></h1>

<pre><span class="keyword">module</span> TypeInference: <code class="code"><span class="keyword">sig</span></code> <a href="TypeInference.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<h1 id="1_TypeInference">Type Inference</h1>
<p>

    This module is used for two things that overlap:<ul>
<li>inferring the types of symbols that have not been declared (e.g. in
    "fof" or "cnf" TPTP statements) so as to enrich a <a href="Signature.html"><code class="code"><span class="constructor">Signature</span></code></a></li>
<li>converting <i>untyped</i> terms or formulas into <i>typed</i> formulas, by inferring
    the exact type of each subterm (and possibly inferring type parameters).</li>
</ul>

    In this context, <b>generalizing</b> type variables means that if some ID.t
    whose type was unknown and its type still contains variables after the
    type inference, those variables are quantified instead of being bound to
    a default type (typically <code class="code">.<span class="constructor">Type</span>.i</code>).
<p>

    For instance: say <code class="code">f</code> is not declared and occurs in the term <code class="code">f(f(nil))</code>
    with the declared constructor <code class="code">nil : list(<span class="constructor">A</span>)</code>. The inferred type for
    <code class="code">f</code> should be something like <code class="code">list(<span class="constructor">B</span>) <span class="keywordsign">-&gt;</span> list(<span class="constructor">B</span>)</code>.<ul>
<li>If we generalize, we declare that <code class="code">f : list(<span class="constructor">A</span>) <span class="keywordsign">-&gt;</span> list(<span class="constructor">A</span>)</code> (for all <code class="code"><span class="constructor">A</span></code>).</li>
<li>If we don't, we declare that <code class="code">f : list($i) <span class="keywordsign">-&gt;</span> list($i)</code>.</li>
</ul>

    Here we use a single scope when we unify and substitute type variables,
    the scope 0.
<p>

    Many functions will use an Error monad to make errors explicit. The error
    type is <a href="TypeInference.html#TYPEor_error"><code class="code"><span class="constructor">TypeInference</span>.or_error</code></a>. The module <code class="code"><span class="constructor">CCError</span></code> in containers can be used
    to deal with errors (including monadic operators).<br>
</div>
<hr width="100%">

<pre><span id="TYPEor_error"><span class="keyword">type</span> <code class="type">'a</code> or_error</span> = <code class="type">[ `Error of string | `Ok of 'a ]</code> </pre>


<pre><span id="TYPEtype_"><span class="keyword">type</span> <code class="type"></code>type_</span> = <code class="type"><a href="TypedSTerm.html#TYPEt">TypedSTerm.t</a></code> </pre>


<pre><span id="TYPEuntyped"><span class="keyword">type</span> <code class="type"></code>untyped</span> = <code class="type"><a href="STerm.html#TYPEt">STerm.t</a></code> </pre>
<div class="info ">
untyped term<br>
</div>


<pre><span id="TYPEtyped"><span class="keyword">type</span> <code class="type"></code>typed</span> = <code class="type"><a href="TypedSTerm.html#TYPEt">TypedSTerm.t</a></code> </pre>
<div class="info ">
typed term<br>
</div>


<pre><span id="TYPEloc"><span class="keyword">type</span> <code class="type"></code>loc</span> = <code class="type"><a href="ParseLocation.html#TYPEt">ParseLocation.t</a></code> </pre>


<pre><span id="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type">string</code></pre>

<pre><span id="VALsection"><span class="keyword">val</span> section</span> : <code class="type"><a href="Util.Section.html#TYPEt">Util.Section.t</a></code></pre><br>
<h2 id="2_TypesforBuiltins">Types for Builtins</h2><br>

<pre><span class="keyword">module</span> <a href="TypeInference.TyBuiltin.html">TyBuiltin</a>: <code class="code"><span class="keyword">sig</span></code> <a href="TypeInference.TyBuiltin.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Typingcontext">Typing context</h2>
<p>

    This module provides a typing context, with an applicative interface.
    The context is used to map terms to types locally during type
    inference. It also keeps and updates a signature when symbols' types
    are inferred.
<p>

    This module is quite low-level, and shouldn't be used in simple cases
    (see the following modules)<br>

<pre><span class="keyword">module</span> <a href="TypeInference.Ctx.html">Ctx</a>: <code class="code"><span class="keyword">sig</span></code> <a href="TypeInference.Ctx.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALunify"><span class="keyword">val</span> unify</span> : <code class="type">?loc:<a href="TypeInference.html#TYPEloc">loc</a> -> <a href="TypeInference.html#TYPEtype_">type_</a> -> <a href="TypeInference.html#TYPEtype_">type_</a> -> unit</code></pre><br>
<h2 id="2_HindleyMilnerTypeInference">Hindley-Milner Type Inference</h2>
<p>

    This module, abstract in the exact kind of term it types, takes as input
    a signature and an <b>untyped term</b>, and updates the typing context
    so that the <b>untyped term</b> can be converted into a <b>typed term</b>.<br>

<pre><span id="VALinfer_ty_exn"><span class="keyword">val</span> infer_ty_exn</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtype_">type_</a></code></pre><div class="info ">
Type conversion from <a href="TypeInference.html#TYPEuntyped"><code class="code"><span class="constructor">TypeInference</span>.untyped</code></a>.<br>
</div>

<pre><span id="VALinfer_ty"><span class="keyword">val</span> infer_ty</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtype_">type_</a> <a href="TypeInference.html#TYPEor_error">or_error</a></code></pre><div class="info ">
Type conversion from <a href="TypeInference.html#TYPEuntyped"><code class="code"><span class="constructor">TypeInference</span>.untyped</code></a>.<br>
</div>

<pre><span id="VALinfer_exn"><span class="keyword">val</span> infer_exn</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtyped">typed</a></code></pre><div class="info ">
Infer the type of this term under the given signature. This updates
    the context's typing environment!<br>
<b>Raises</b> <code>Error</code> if the types are inconsistent<br>
</div>

<pre><span id="VALinfer"><span class="keyword">val</span> infer</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtyped">typed</a> <a href="TypeInference.html#TYPEor_error">or_error</a></code></pre><div class="info ">
Safe version of <a href="TypeInference.html#VALinfer_exn"><code class="code"><span class="constructor">TypeInference</span>.infer_exn</code></a>. It returns <code class="code"><span class="keywordsign">`</span><span class="constructor">Error</span> s</code> rather
    than raising <a href="TypeInference.html#EXCEPTIONError"><code class="code"><span class="constructor">TypeInference</span>.<span class="constructor">Error</span></code></a> if the typechecking fails.<br>
</div>

<pre><span id="VALinfer_prop_exn"><span class="keyword">val</span> infer_prop_exn</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtyped">typed</a></code></pre><div class="info ">
Same as <a href="TypeInference.html#VALinfer_exn"><code class="code"><span class="constructor">TypeInference</span>.infer_exn</code></a> but forces the type of its result
    to be <a href="TypedSTerm.html#VALprop"><code class="code"><span class="constructor">TypedSTerm</span>.prop</code></a><br>
</div>

<pre><span id="VALinfer_clause_exn"><span class="keyword">val</span> infer_clause_exn</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> list -> <a href="TypeInference.html#TYPEtyped">typed</a> list</code></pre><div class="info ">
Convert a clause. Free variables in each of the list's elements
    are shared<br>
</div>
<br>
<h3 id="3_Constrainingtypes">Constraining types</h3>
<p>

    This section is mostly useful for inferring a signature without
    converting untyped_terms into typed_terms.<br>

<pre><span id="VALconstrain_term_term_exn"><span class="keyword">val</span> constrain_term_term_exn</span> : <code class="type">?loc:<a href="TypeInference.html#TYPEloc">loc</a> -><br>       <a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> unit</code></pre><div class="info ">
Force the two terms to have the same type in this context<br>
<b>Raises</b> <code>Error</code> if an inconsistency is detected<br>
</div>

<pre><span id="VALconstrain_term_type_exn"><span class="keyword">val</span> constrain_term_type_exn</span> : <code class="type">?loc:<a href="TypeInference.html#TYPEloc">loc</a> -><br>       <a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtype_">type_</a> -> unit</code></pre><div class="info ">
Force the term's type and the given type to be the same.<br>
<b>Raises</b> <code>Error</code> if an inconsistency is detected<br>
</div>

<pre><span id="VALconstrain_term_term"><span class="keyword">val</span> constrain_term_term</span> : <code class="type">?loc:<a href="TypeInference.html#TYPEloc">loc</a> -><br>       <a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEuntyped">untyped</a> -> unit <a href="TypeInference.html#TYPEor_error">or_error</a></code></pre><div class="info ">
Safe version of <a href="TypeInference.html#VALconstrain_term_term_exn"><code class="code"><span class="constructor">TypeInference</span>.constrain_term_term_exn</code></a><br>
</div>

<pre><span id="VALconstrain_term_type"><span class="keyword">val</span> constrain_term_type</span> : <code class="type">?loc:<a href="TypeInference.html#TYPEloc">loc</a> -><br>       <a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="TypeInference.html#TYPEuntyped">untyped</a> -> <a href="TypeInference.html#TYPEtype_">type_</a> -> unit <a href="TypeInference.html#TYPEor_error">or_error</a></code></pre><div class="info ">
Safe version of <a href="TypeInference.html#VALconstrain_term_type_exn"><code class="code"><span class="constructor">TypeInference</span>.constrain_term_type_exn</code></a><br>
</div>
<br>
<h2 id="2_Statements">Statements</h2><br>

<pre><span id="TYPEtyped_statement"><span class="keyword">type</span> <code class="type"></code>typed_statement</span> = <code class="type">(<a href="TypeInference.html#TYPEtyped">typed</a>, <a href="TypeInference.html#TYPEtyped">typed</a>, <a href="TypeInference.html#TYPEtype_">type_</a>,<br>        <a href="UntypedAST.html#TYPEattrs">UntypedAST.attrs</a>)<br>       <a href="Statement.html#TYPEt">Statement.t</a></code> </pre>


<pre><span id="VALinfer_statement_exn"><span class="keyword">val</span> infer_statement_exn</span> : <code class="type"><a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="UntypedAST.html#TYPEstatement">UntypedAST.statement</a> -><br>       <a href="TypeInference.html#TYPEtyped_statement">typed_statement</a> * <a href="TypeInference.html#TYPEtyped_statement">typed_statement</a> list</code></pre><div class="info ">
<code class="code">infer_statement ctx ~f st</code> checks and convert <code class="code">st</code> into a
    typed statements, and a list of auxiliary type declarations for symbols
    that were inferred implicitely.<br>
</div>

<pre><span id="VALinfer_statements_exn"><span class="keyword">val</span> infer_statements_exn</span> : <code class="type">?ctx:<a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="UntypedAST.html#TYPEstatement">UntypedAST.statement</a> Sequence.t -><br>       <a href="TypeInference.html#TYPEtyped_statement">typed_statement</a> CCVector.ro_vector</code></pre><div class="info ">
Infer all statements<br>
</div>

<pre><span id="VALinfer_statements"><span class="keyword">val</span> infer_statements</span> : <code class="type">?ctx:<a href="TypeInference.Ctx.html#TYPEt">Ctx.t</a> -><br>       <a href="UntypedAST.html#TYPEstatement">UntypedAST.statement</a> Sequence.t -><br>       <a href="TypeInference.html#TYPEtyped_statement">typed_statement</a> CCVector.ro_vector <a href="TypeInference.html#TYPEor_error">or_error</a></code></pre></body></html>