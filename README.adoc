= Zipperposition
:toc: macro
:source-highlighter: pygments

- Automated theorem prover for first-order logic with equality and theories.
- Logic toolkit (`logtk`), designed primarily
  for first-order automated reasoning. It aims
  at providing basic types and algorithms (terms, unification, orderings,
  indexing, etc.) that can be factored out of several applications.

toc::[]

== Short summary

Zipperposition is intended to be a superposition prover for full first
order logic, plus some extensions (datatypes, recursive functions, arithmetic).
The accent is on flexibility, modularity and simplicity rather than
performance, to allow quick experimenting on automated theorem proving. It
generates TSTP traces or graphviz files for nice graphical display.

Zipperposition supports several input formats:

- TSTP (fof, cnf, tff)
- https://tip-org.github.io/[TIP]
- its own native input, extension `.zf` (see directory `examples/`)

Zipperposition is written in the functional and imperative language
https://ocaml.org[OCaml]. The name is a bad play on the words "zipper" (a
functional data structure) and "superposition" (the calculus used by the
prover), although the current implementation is written in quite an imperative style.
Superposition-based theorem proving is an active field of research, so
there is a lot of literature about it; for this implementation my main references
are:

* the chapter _paramodulation-based theorem proving_ of the _handbook of automated reasoning_,
* the paper _E: a brainiac theorem prover_ that describes the http://eprover.org[E prover] by S.Schulz,
* the paper _Superposition with equivalence reasoning and delayed clause normal form transformation_ by H.Ganzinger and J.Stuber

**Disclaimer**: Note that the prover is currently a prototype and is
likely not complete. Please don't use it to drive your personal
nuclear power plant, nor as a trusted tool for critical applications.

== License

This project is licensed under the BSD2 license. See the `LICENSE` file.

== Build

=== Via opam

The recommended way to install Zipperposition is through http://opam.ocaml.org/[opam].
You need to have GMP (with headers) installed (it's not handled by opam).  Once
you installed GMP and opam, type:

----
$ opam install zipperposition
----

To upgrade to more recent versions:

----
$ opam update

$ opam upgrade
----

If you want to try the development (unstable) version, which has more
dependencies (in particular Oasis for the build), try:

    $ opam pin add zipperposition -k git https://github.com/c-cube/zipperposition.git#dev

=== Manually

If you really need to, you can download a release on the
following https://github.com/c-cube/zipperposition/releases[github page for releases].

Look in the file `opam` to see which dependencies you need to install.
They include `menhir`, `zarith`, `containers`,
`oclock`, https://github.com/Gbury/mSAT[msat] and `sequence`, but
maybe also other libraries. Consider using opam directly if possible.

----
$ ./configure

$ make install
----

Additional sub-libraries can be built if their respective dependencies
are met, and the appropriate `./configure --enable-foobar` flag was set.

If http://cristal.inria.fr/~fpottier/menhir/[menhir] is installed, the
parsers library `Logtk_parsers` can be built with

----
$ ./configure --enable-parsers
----

If you have installed https://github.com/c-cube/qcheck/[qcheck], for instance
via `opam install qcheck`, you can enable the property-based testing and
random term generators with

----
$ ./configure --enable-qcheck --enable-tests
$ make tests
----

== Use

Typical usage:

----
$ zipperposition --help
$ zipperposition problem_file [options]
$ zipperposition --arith examples/ARI114=1.p
$ zipperposition --dot /tmp/foo.dot examples/ind/nat1.zf
----

to run the prover. Help is available with the option `--help`.
For instance,

----
$ zipperposition examples/pelletier_problems/pb47.p --ord rpo6 --timeout 30
----

Several tools are shipped with Zipperposition, including a CNF converter, a type-checker,
etc. They are built if the flag `--enable-tools` is set. Documentation
will be built provided `--enable-docs` is set.

After the configuration is done, to build the library, documentation and tools
(given the appropriate flags are set), type in a terminal located in the root
directory of the project:

----
$ make
----

If you use `ocamlfind` (which is strongly recommended),
installation/uninstallation are just:

----
$ make install
$ make uninstall
----

=== Native Syntax

The native syntax, with file extension `.zf`, resembles a simple fragment of
ML with explicit polymorphism. Every symbol must be declared, using
the builtin type `prop` for propositions. A type is declared
like this: `val i : type.` and a parametrized type: `val array: type -> type.`

----
val i : type.
val a : i.

val f : i -> i. # a function
val p : i -> i -> prop. # a binary predicate
----

Then, axioms and the goal:

----
assert forall x y. p x y => p y x.
assert p a (f a).

goal exists (x:i). p (f x) x.
----

We can run the prover link:doc/example.zf[on a file containing these declarations].
It will display a proof very quickly:

----
$ ./zipperposition.native example.zf

% done 3 iterations
% SZS status Theorem for 'example.zf'
% SZS output start Refutation
* ⊥/7 by simp simplify with [⊥]/5
* [⊥]/5 by
  inf s_sup- with {X2[1] → a[0]}
    with [p (f a) a]/4, forall (X2:i). [¬p (f X2) X2]/2

* forall (X2:i). [¬p (f X2) X2]/2 by
  esa cnf with ¬ (∃ x/13:i. (p (f x/13) x/13))

* [p (f a) a]/4 by simp simplify with [p (f a) a ∨ ⊥]/3
* [p (f a) a ∨ ⊥]/3 by
  inf s_sup- with {X0[0] → f a[1], X1[0] → a[1]}
    with [p a (f a)]/1, forall (X0:i) (X1:i). [p X0 X1 ∨ ¬p X1 X0]/0

* ¬ (∃ x/13:i. (p (f x/13) x/13)) by
  esa neg_goal negate goal to find a refutation
    with ∃ x/13:i. (p (f x/13) x/13)

* ∃ x/13:i. (p (f x/13) x/13) by goal 'example.zf'
* forall (X0:i) (X1:i). [p X0 X1 ∨ ¬p X1 X0]/0 by
  esa cnf with ∀ x/9:i y/11:i. ((p x/9 y/11) ⇒ (p y/11 x/9))

* [p a (f a)]/1 by esa cnf with p a (f a)
* p a (f a) by 'example.zf'
* ∀ x/9:i y/11:i. ((p x/9 y/11) ⇒ (p y/11 x/9)) by 'example.zf'

% SZS output end Refutation
----

Each `*` -prefixed item in the list is an inference step. The top step is
the empty clause: zipperposition works by negating the goal before looking
for proving `false`. Indeed, proving `a ⇒ b` is equivalent to deducing
`false` from `a ∧ ¬b`.

A handy way of displaying the proof is to use http://graphviz.org/[graphviz]:

----
$ ./zipperposition.native --dot /tmp/example.dot example.zf
$ dot -Txlib /tmp/example.dot
----

One can generate an image from the `.dot` file:

----
$ dot -Tsvg /tmp/example.dot > some_picture.svg
----

image::doc/example_proof.svg[alt="simple proof graph",link="doc/example_proof.svg"]


=== Library

Zipperposition's library provides several useful
parts for logic-related implementations:

- a library packed in a module `Logtk`, with terms, formulas, etc.;
- a library packed in a module `Logtk_parsers`, with parsers for input formats;
- small tools (see directory `src/tools/`) to illustrate how to use the library
    and provide basic services (type-checking, reduction to CNF, etc.);

== Documentation

See http://c-cube.github.io/zipperposition/[this page].

There are some examples of how to use the code in `src/tools/`
and `src/demo/`.

