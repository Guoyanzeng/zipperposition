0.002[zip] terminate phase parse_cli
0.002[zip] start phase load_extensions
0.003[zip] register extension `superposition`...
0.003[zip] register extension `ac`...
0.003[zip] register extension `heuristics`...
0.003[zip] register extension `avatar`...
0.003[zip] register extension `induction_simple`...
0.003[zip] register extension `rewriting`...
0.003[zip] register extension `arith_int`...
0.003[zip] register extension `arith_rat`...
0.003[zip] register extension `ind_types`...
0.003[zip] terminate phase load_extensions
0.003[zip] start phase parse_prelude
0.003[zip] terminate phase parse_prelude
0.003[zip] start phase start_file
0.003[zip]
    ### process file `/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p` ###
0.003[zip] terminate phase start_file
0.003[zip] start phase parse_file
0.003[] search `Axioms/LCL008^0.ax`
    as `/home/petar/Documents/tptp/Problems/LCL/Axioms/LCL008^0.ax`
0.003[] search `Axioms/LCL008^0.ax`
    as `/home/petar/Documents/tptp/Problems/Axioms/LCL008^0.ax`
0.003[] search `Axioms/LCL008^0.ax`
    as `/home/petar/Documents/tptp/Axioms/LCL008^0.ax`
0.004[zip] terminate phase parse_file
0.004[zip] start phase typing
0.004[ty-infer]
    infer types for statement `val [name current_world] current_world : ι.`
0.004[ty-infer] declare current_world: ι
0.004[ty-infer]
    infer types for statement `val [name prop_a] prop_a : ι → prop.`
0.005[ty-infer] declare prop_a: ι → prop
0.005[ty-infer]
    infer types for statement `val [name prop_b] prop_b : ι → prop.`
0.005[ty-infer] declare prop_b: ι → prop
0.005[ty-infer]
    infer types for statement `val [name prop_c] prop_c : ι → prop.`
0.005[ty-infer] declare prop_c: ι → prop
0.005[ty-infer]
    infer types for statement `val [name mfalse_decl] mfalse : ι → prop.`
0.005[ty-infer] declare mfalse: ι → prop
0.005[ty-infer]
    infer types for statement
      `assert [name mfalse] mfalse = (λ X:ι. false).`
0.005[ty-infer] infer type of `mfalse = (λ X:ι. false)`
0.005[typedSTerm] apply `ι → prop` to []
0.005[ty-infer] typing of `mfalse` yields `mfalse` : `ι → prop`
0.005[ty-infer] typing of `false` yields `false` : `prop`
0.005[ty-infer]
    typing of `λ X:ι. false` yields `λ X/10. false` : `ι → prop`
0.006[ty-infer] unify types `ι → prop` and `ι → prop`
0.006[ty-infer]
    typing of `mfalse = (λ X:ι. false)`
    yields `mfalse = (λ X/10. false)` : `prop`
0.006[ty-infer] unify types `prop` and `prop`
0.006[ty-infer]
    infer types for statement `val [name mtrue_decl] mtrue : ι → prop.`
0.006[ty-infer] declare mtrue: ι → prop
0.006[ty-infer]
    infer types for statement `assert [name mtrue] mtrue = (λ X:ι. true).`
0.006[ty-infer] infer type of `mtrue = (λ X:ι. true)`
0.006[typedSTerm] apply `ι → prop` to []
0.006[ty-infer] typing of `mtrue` yields `mtrue` : `ι → prop`
0.006[ty-infer] typing of `true` yields `true` : `prop`
0.006[ty-infer]
    typing of `λ X:ι. true` yields `λ X/12. true` : `ι → prop`
0.006[ty-infer] unify types `ι → prop` and `ι → prop`
0.006[ty-infer]
    typing of `mtrue = (λ X:ι. true)`
    yields `mtrue = (λ X/12. true)` : `prop`
0.006[ty-infer] unify types `prop` and `prop`
0.006[ty-infer]
    infer types for statement
      `val [name mnot_decl] mnot : (ι → prop) → (ι → prop).`
0.006[ty-infer] declare mnot: (ι → prop) → ι → prop
0.006[ty-infer]
    infer types for statement
      `assert [name mnot] mnot = (λ X:ι → prop U:ι. ¬ (X U)).`
0.006[ty-infer] infer type of `mnot = (λ X:ι → prop U:ι. ¬ (X U))`
0.007[typedSTerm] apply `(ι → prop) → ι → prop` to []
0.007[ty-infer]
    typing of `mnot` yields `mnot` : `(ι → prop) → ι → prop`
0.007[ty-infer] typing of `U` yields `U/15` : `ι`
0.007[ty-infer] apply X:ι → prop to [U/15]:[ι]
0.007[typedSTerm] apply `ι → prop` to [U/15]
0.007[ty-infer] typing of `X U` yields `X/14 U/15` : `prop`
0.007[ty-infer] unify types `prop` and `prop`
0.007[ty-infer] typing of `¬ (X U)` yields `¬ (X/14 U/15)` : `prop`
0.007[ty-infer]
    typing of `λ X:ι → prop U:ι. ¬ (X U)`
    yields `λ X/14:(ι → prop) U/15. (¬ (X/14 U/15))`
             : `(ι → prop) → ι → prop`
0.007[ty-infer]
    unify types
      `(ι → prop) → ι → prop`
      and `(ι → prop) → ι → prop`
0.007[ty-infer]
    typing of `mnot = (λ X:ι → prop U:ι. ¬ (X U))`
    yields `mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)))` : `prop`
0.007[ty-infer] unify types `prop` and `prop`
0.007[ty-infer]
    infer types for statement
      `val [name mor_decl] mor :
         (ι → prop) → ((ι → prop) → (ι → prop)).`
0.007[ty-infer] declare mor: (ι → prop) → (ι → prop) → ι → prop
0.007[ty-infer]
    infer types for statement
      `assert [name mor]
         mor = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∨ (Y U)).`
0.008[ty-infer]
    infer type of
      `mor = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∨ (Y U))`
0.008[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to []
0.008[ty-infer]
    typing of `mor`
    yields `mor` : `(ι → prop) → (ι → prop) → ι → prop`
0.008[ty-infer] typing of `U` yields `U/19` : `ι`
0.008[ty-infer] apply X:ι → prop to [U/19]:[ι]
0.008[typedSTerm] apply `ι → prop` to [U/19]
0.008[ty-infer] typing of `X U` yields `X/17 U/19` : `prop`
0.008[ty-infer] unify types `prop` and `prop`
0.008[ty-infer] typing of `U` yields `U/19` : `ι`
0.010[ty-infer] apply Y:ι → prop to [U/19]:[ι]
0.010[typedSTerm] apply `ι → prop` to [U/19]
0.010[ty-infer] typing of `Y U` yields `Y/18 U/19` : `prop`
0.010[ty-infer] unify types `prop` and `prop`
0.010[ty-infer]
    typing of `(X U) ∨ (Y U)` yields `(Y/18 U/19) ∨ (X/17 U/19)` : `prop`
0.010[ty-infer]
    typing of `λ X:ι → prop Y:ι → prop U:ι. (X U) ∨ (Y U)`
    yields `λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
              ((Y/18 U/19) ∨ (X/17 U/19))`
             : `(ι → prop) → (ι → prop) → ι → prop`
0.010[ty-infer]
    unify types
      `(ι → prop) → (ι → prop) → ι → prop`
      and `(ι → prop) → (ι → prop) → ι → prop`
0.010[ty-infer]
    typing of `mor = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∨ (Y U))`
    yields `mor =
            (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
               ((Y/18 U/19) ∨ (X/17 U/19)))`
             : `prop`
0.010[ty-infer] unify types `prop` and `prop`
0.010[ty-infer]
    infer types for statement
      `val [name mand_decl] mand :
         (ι → prop) → ((ι → prop) → (ι → prop)).`
0.011[ty-infer] declare mand: (ι → prop) → (ι → prop) → ι → prop
0.011[ty-infer]
    infer types for statement
      `assert [name mand]
         mand = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∧ (Y U)).`
0.011[ty-infer]
    infer type of
      `mand = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∧ (Y U))`
0.011[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to []
0.011[ty-infer]
    typing of `mand`
    yields `mand` : `(ι → prop) → (ι → prop) → ι → prop`
0.011[ty-infer] typing of `U` yields `U/23` : `ι`
0.011[ty-infer] apply X:ι → prop to [U/23]:[ι]
0.011[typedSTerm] apply `ι → prop` to [U/23]
0.011[ty-infer] typing of `X U` yields `X/21 U/23` : `prop`
0.011[ty-infer] unify types `prop` and `prop`
0.011[ty-infer] typing of `U` yields `U/23` : `ι`
0.011[ty-infer] apply Y:ι → prop to [U/23]:[ι]
0.011[typedSTerm] apply `ι → prop` to [U/23]
0.011[ty-infer] typing of `Y U` yields `Y/22 U/23` : `prop`
0.011[ty-infer] unify types `prop` and `prop`
0.012[ty-infer]
    typing of `(X U) ∧ (Y U)` yields `(Y/22 U/23) ∧ (X/21 U/23)` : `prop`
0.012[ty-infer]
    typing of `λ X:ι → prop Y:ι → prop U:ι. (X U) ∧ (Y U)`
    yields `λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
              ((Y/22 U/23) ∧ (X/21 U/23))`
             : `(ι → prop) → (ι → prop) → ι → prop`
0.012[ty-infer]
    unify types
      `(ι → prop) → (ι → prop) → ι → prop`
      and `(ι → prop) → (ι → prop) → ι → prop`
0.012[ty-infer]
    typing of `mand = (λ X:ι → prop Y:ι → prop U:ι. (X U) ∧ (Y U))`
    yields `mand =
            (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
               ((Y/22 U/23) ∧ (X/21 U/23)))`
             : `prop`
0.012[ty-infer] unify types `prop` and `prop`
0.012[ty-infer]
    infer types for statement
      `val [name mimpl_decl] mimpl :
         (ι → prop) → ((ι → prop) → (ι → prop)).`
0.014[ty-infer] declare mimpl:
    (ι → prop) → (ι → prop) → ι → prop
0.014[ty-infer]
    infer types for statement
      `assert [name mimpl]
         mimpl = (λ U:ι → prop V:ι → prop. mor (mnot U) V).`
0.014[ty-infer]
    infer type of `mimpl = (λ U:ι → prop V:ι → prop. mor (mnot U) V)`
0.014[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to []
0.014[ty-infer]
    typing of `mimpl`
    yields `mimpl` : `(ι → prop) → (ι → prop) → ι → prop`
0.014[ty-infer] typing of `U` yields `U/25` : `ι → prop`
0.015[ty-infer]
    apply mnot:(ι → prop) → ι → prop to [U/25]:[ι → prop]
0.015[typedSTerm] apply `(ι → prop) → ι → prop` to [U/25]
0.015[ty-infer] typing of `mnot U` yields `mnot U/25` : `ι → prop`
0.015[ty-infer] typing of `V` yields `V/26` : `ι → prop`
0.015[ty-infer]
    apply mor:(ι → prop) → (ι → prop) → ι → prop
      to [mnot U/25, V/26]:[ι → prop, ι → prop]
0.015[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop`
    to [mnot U/25, V/26]
0.015[ty-infer]
    typing of `mor (mnot U) V` yields `mor (mnot U/25) V/26` : `ι → prop`
0.015[ty-infer]
    typing of `λ U:ι → prop V:ι → prop. mor (mnot U) V`
    yields `λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26)`
             : `(ι → prop) → (ι → prop) → ι → prop`
0.015[ty-infer]
    unify types
      `(ι → prop) → (ι → prop) → ι → prop`
      and `(ι → prop) → (ι → prop) → ι → prop`
0.016[ty-infer]
    typing of `mimpl = (λ U:ι → prop V:ι → prop. mor (mnot U) V)`
    yields `mimpl =
            (λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26))`
             : `prop`
0.016[ty-infer] unify types `prop` and `prop`
0.016[ty-infer]
    infer types for statement
      `val [name miff_decl] miff :
         (ι → prop) → ((ι → prop) → (ι → prop)).`
0.016[ty-infer] declare miff: (ι → prop) → (ι → prop) → ι → prop
0.016[ty-infer]
    infer types for statement
      `assert [name miff]
         miff =
         (λ U:ι → prop V:ι → prop. mand (mimpl U V) (mimpl V U)).`
0.016[ty-infer]
    infer type of
      `miff = (λ U:ι → prop V:ι → prop. mand (mimpl U V) (mimpl V U))`
0.016[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to []
0.016[ty-infer]
    typing of `miff`
    yields `miff` : `(ι → prop) → (ι → prop) → ι → prop`
0.016[ty-infer] typing of `U` yields `U/28` : `ι → prop`
0.016[ty-infer] typing of `V` yields `V/29` : `ι → prop`
0.016[ty-infer]
    apply mimpl:(ι → prop) → (ι → prop) → ι → prop
      to [U/28, V/29]:[ι → prop, ι → prop]
0.017[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to [U/28, V/29]
0.017[ty-infer]
    typing of `mimpl U V` yields `mimpl U/28 V/29` : `ι → prop`
0.017[ty-infer] typing of `V` yields `V/29` : `ι → prop`
0.017[ty-infer] typing of `U` yields `U/28` : `ι → prop`
0.017[ty-infer]
    apply mimpl:(ι → prop) → (ι → prop) → ι → prop
      to [V/29, U/28]:[ι → prop, ι → prop]
0.017[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop` to [V/29, U/28]
0.017[ty-infer]
    typing of `mimpl V U` yields `mimpl V/29 U/28` : `ι → prop`
0.017[ty-infer]
    apply mand:(ι → prop) → (ι → prop) → ι → prop
      to [mimpl U/28 V/29, mimpl V/29 U/28]:[ι → prop, ι → prop]
0.018[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop`
    to [mimpl U/28 V/29, mimpl V/29 U/28]
0.018[ty-infer]
    typing of `mand (mimpl U V) (mimpl V U)`
    yields `mand (mimpl U/28 V/29) (mimpl V/29 U/28)` : `ι → prop`
0.018[ty-infer]
    typing of `λ U:ι → prop V:ι → prop. mand (mimpl U V) (mimpl V U)`
    yields `λ U/28:(ι → prop) V/29:(ι → prop).
              (mand (mimpl U/28 V/29) (mimpl V/29 U/28))`
             : `(ι → prop) → (ι → prop) → ι → prop`
0.018[ty-infer]
    unify types
      `(ι → prop) → (ι → prop) → ι → prop`
      and `(ι → prop) → (ι → prop) → ι → prop`
0.018[ty-infer]
    typing of `miff =
               (λ U:ι → prop V:ι → prop. mand (mimpl U V) (mimpl V U))`
    yields `miff =
            (λ U/28:(ι → prop) V/29:(ι → prop).
               (mand (mimpl U/28 V/29) (mimpl V/29 U/28)))`
             : `prop`
0.019[ty-infer] unify types `prop` and `prop`
0.019[ty-infer]
    infer types for statement
      `val [name mbox_decl] mbox :
         (ι → (ι → prop)) → ((ι → prop) → (ι → prop)).`
0.019[ty-infer] declare mbox:
    (ι → ι → prop) → (ι → prop) → ι → prop
0.019[ty-infer]
    infer types for statement
      `assert [name mbox]
         mbox =
         (λ R:ι → (ι → prop) P:ι → prop X:ι.
            ∀ Y:ι. (R X Y) ⇒ (P Y)).`
0.019[ty-infer]
    infer type of
      `mbox =
       (λ R:ι → (ι → prop) P:ι → prop X:ι.
          ∀ Y:ι. (R X Y) ⇒ (P Y))`
0.019[typedSTerm]
    apply `(ι → ι → prop) → (ι → prop) → ι → prop` to []
0.019[ty-infer]
    typing of `mbox`
    yields `mbox` : `(ι → ι → prop) → (ι → prop) → ι → prop`
0.019[ty-infer] typing of `X` yields `X/33` : `ι`
0.019[ty-infer] typing of `Y` yields `Y/34` : `ι`
0.019[ty-infer] apply R:ι → ι → prop to [X/33, Y/34]:[ι, ι]
0.020[typedSTerm] apply `ι → ι → prop` to [X/33, Y/34]
0.020[ty-infer] typing of `R X Y` yields `R/31 X/33 Y/34` : `prop`
0.020[ty-infer] unify types `prop` and `prop`
0.020[ty-infer] typing of `Y` yields `Y/34` : `ι`
0.020[ty-infer] apply P:ι → prop to [Y/34]:[ι]
0.020[typedSTerm] apply `ι → prop` to [Y/34]
0.020[ty-infer] typing of `P Y` yields `P/32 Y/34` : `prop`
0.020[ty-infer] unify types `prop` and `prop`
0.020[ty-infer]
    typing of `(R X Y) ⇒ (P Y)`
    yields `(R/31 X/33 Y/34) ⇒ (P/32 Y/34)` : `prop`
0.020[ty-infer] unify types `prop` and `prop`
0.020[ty-infer]
    typing of `∀ Y:ι. (R X Y) ⇒ (P Y)`
    yields `∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))` : `prop`
0.020[ty-infer]
    typing of `λ R:ι → (ι → prop) P:ι → prop X:ι.
                 ∀ Y:ι. (R X Y) ⇒ (P Y)`
    yields `λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
              (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34)))`
             : `(ι → ι → prop) → (ι → prop) → ι → prop`
0.021[ty-infer]
    unify types
      `(ι → ι → prop) → (ι → prop) → ι → prop`
      and `(ι → ι → prop) → (ι → prop) → ι → prop`
0.021[ty-infer]
    typing of `mbox =
               (λ R:ι → (ι → prop) P:ι → prop X:ι.
                  ∀ Y:ι. (R X Y) ⇒ (P Y))`
    yields `mbox =
            (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
               (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))))`
             : `prop`
0.021[ty-infer] unify types `prop` and `prop`
0.021[ty-infer]
    infer types for statement
      `val [name mdia_decl] mdia :
         (ι → (ι → prop)) → ((ι → prop) → (ι → prop)).`
0.021[ty-infer] declare mdia:
    (ι → ι → prop) → (ι → prop) → ι → prop
0.021[ty-infer]
    infer types for statement
      `assert [name mdia]
         mdia =
         (λ R:ι → (ι → prop) P:ι → prop X:ι.
            ∃ Y:ι. (R X Y) ∧ (P Y)).`
0.021[ty-infer]
    infer type of
      `mdia =
       (λ R:ι → (ι → prop) P:ι → prop X:ι.
          ∃ Y:ι. (R X Y) ∧ (P Y))`
0.021[typedSTerm]
    apply `(ι → ι → prop) → (ι → prop) → ι → prop` to []
0.021[ty-infer]
    typing of `mdia`
    yields `mdia` : `(ι → ι → prop) → (ι → prop) → ι → prop`
0.021[ty-infer] typing of `X` yields `X/38` : `ι`
0.021[ty-infer] typing of `Y` yields `Y/39` : `ι`
0.021[ty-infer] apply R:ι → ι → prop to [X/38, Y/39]:[ι, ι]
0.021[typedSTerm] apply `ι → ι → prop` to [X/38, Y/39]
0.021[ty-infer] typing of `R X Y` yields `R/36 X/38 Y/39` : `prop`
0.021[ty-infer] unify types `prop` and `prop`
0.022[ty-infer] typing of `Y` yields `Y/39` : `ι`
0.022[ty-infer] apply P:ι → prop to [Y/39]:[ι]
0.022[typedSTerm] apply `ι → prop` to [Y/39]
0.022[ty-infer] typing of `P Y` yields `P/37 Y/39` : `prop`
0.022[ty-infer] unify types `prop` and `prop`
0.022[ty-infer]
    typing of `(R X Y) ∧ (P Y)`
    yields `(P/37 Y/39) ∧ (R/36 X/38 Y/39)` : `prop`
0.022[ty-infer] unify types `prop` and `prop`
0.022[ty-infer]
    typing of `∃ Y:ι. (R X Y) ∧ (P Y)`
    yields `∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39))` : `prop`
0.022[ty-infer]
    typing of `λ R:ι → (ι → prop) P:ι → prop X:ι.
                 ∃ Y:ι. (R X Y) ∧ (P Y)`
    yields `λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
              (∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39)))`
             : `(ι → ι → prop) → (ι → prop) → ι → prop`
0.022[ty-infer]
    unify types
      `(ι → ι → prop) → (ι → prop) → ι → prop`
      and `(ι → ι → prop) → (ι → prop) → ι → prop`
0.023[ty-infer]
    typing of `mdia =
               (λ R:ι → (ι → prop) P:ι → prop X:ι.
                  ∃ Y:ι. (R X Y) ∧ (P Y))`
    yields `mdia =
            (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
               (∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39))))`
             : `prop`
0.023[ty-infer] unify types `prop` and `prop`
0.023[ty-infer]
    infer types for statement
      `val [name individuals_decl] individuals : type.`
0.023[ty-infer] declare individuals: type
0.023[ty-infer]
    infer types for statement
      `val [name mall_decl] mall :
         (individuals → (ι → prop)) → (ι → prop).`
0.023[ty-infer] unify types `type` and `type`
0.023[ty-infer] declare mall: (individuals → ι → prop) → ι → prop
0.023[ty-infer]
    infer types for statement
      `assert [name mall]
         mall =
         (λ P:individuals → (ι → prop) W:ι. ∀ X:individuals. P X W).`
0.024[ty-infer]
    infer type of
      `mall =
       (λ P:individuals → (ι → prop) W:ι. ∀ X:individuals. P X W)`
0.024[typedSTerm] apply `(individuals → ι → prop) → ι → prop` to []
0.024[ty-infer]
    typing of `mall`
    yields `mall` : `(individuals → ι → prop) → ι → prop`
0.024[ty-infer] unify types `type` and `type`
0.024[ty-infer] unify types `type` and `type`
0.024[ty-infer] typing of `X` yields `X/44` : `individuals`
0.024[ty-infer] typing of `W` yields `W/43` : `ι`
0.024[ty-infer]
    apply P:individuals → ι → prop to [X/44, W/43]:[individuals, ι]
0.024[typedSTerm] apply `individuals → ι → prop` to [X/44, W/43]
0.024[ty-infer] typing of `P X W` yields `P/42 X/44 W/43` : `prop`
0.025[ty-infer] unify types `prop` and `prop`
0.025[ty-infer]
    typing of `∀ X:individuals. P X W`
    yields `∀ X/44:individuals. (P/42 X/44 W/43)` : `prop`
0.025[ty-infer]
    typing of `λ P:individuals → (ι → prop) W:ι.
                 ∀ X:individuals. P X W`
    yields `λ P/42:(individuals → ι → prop) W/43.
              (∀ X/44:individuals. (P/42 X/44 W/43))`
             : `(individuals → ι → prop) → ι → prop`
0.025[ty-infer]
    unify types
      `(individuals → ι → prop) → ι → prop`
      and `(individuals → ι → prop) → ι → prop`
0.025[ty-infer]
    typing of `mall =
               (λ P:individuals → (ι → prop) W:ι.
                  ∀ X:individuals. P X W)`
    yields `mall =
            (λ P/42:(individuals → ι → prop) W/43.
               (∀ X/44:individuals. (P/42 X/44 W/43)))`
             : `prop`
0.025[ty-infer] unify types `prop` and `prop`
0.025[ty-infer]
    infer types for statement
      `val [name mexists_decl] mexists :
         (individuals → (ι → prop)) → (ι → prop).`
0.026[ty-infer] unify types `type` and `type`
0.026[ty-infer] declare mexists:
    (individuals → ι → prop) → ι → prop
0.026[ty-infer]
    infer types for statement
      `assert [name mexists]
         mexists =
         (λ P:individuals → (ι → prop) W:ι. ∃ X:individuals. P X W).`
0.026[ty-infer]
    infer type of
      `mexists =
       (λ P:individuals → (ι → prop) W:ι. ∃ X:individuals. P X W)`
0.026[typedSTerm] apply `(individuals → ι → prop) → ι → prop` to []
0.026[ty-infer]
    typing of `mexists`
    yields `mexists` : `(individuals → ι → prop) → ι → prop`
0.026[ty-infer] unify types `type` and `type`
0.026[ty-infer] unify types `type` and `type`
0.026[ty-infer] typing of `X` yields `X/48` : `individuals`
0.026[ty-infer] typing of `W` yields `W/47` : `ι`
0.026[ty-infer]
    apply P:individuals → ι → prop to [X/48, W/47]:[individuals, ι]
0.027[typedSTerm] apply `individuals → ι → prop` to [X/48, W/47]
0.027[ty-infer] typing of `P X W` yields `P/46 X/48 W/47` : `prop`
0.027[ty-infer] unify types `prop` and `prop`
0.027[ty-infer]
    typing of `∃ X:individuals. P X W`
    yields `∃ X/48:individuals. (P/46 X/48 W/47)` : `prop`
0.027[ty-infer]
    typing of `λ P:individuals → (ι → prop) W:ι.
                 ∃ X:individuals. P X W`
    yields `λ P/46:(individuals → ι → prop) W/47.
              (∃ X/48:individuals. (P/46 X/48 W/47))`
             : `(individuals → ι → prop) → ι → prop`
0.027[ty-infer]
    unify types
      `(individuals → ι → prop) → ι → prop`
      and `(individuals → ι → prop) → ι → prop`
0.027[ty-infer]
    typing of `mexists =
               (λ P:individuals → (ι → prop) W:ι.
                  ∃ X:individuals. P X W)`
    yields `mexists =
            (λ P/46:(individuals → ι → prop) W/47.
               (∃ X/48:individuals. (P/46 X/48 W/47)))`
             : `prop`
0.028[ty-infer] unify types `prop` and `prop`
0.028[ty-infer]
    infer types for statement
      `val [name mvalid_decl] mvalid : (ι → prop) → prop.`
0.028[ty-infer] declare mvalid: (ι → prop) → prop
0.028[ty-infer]
    infer types for statement
      `assert [name mvalid] mvalid = (λ P:ι → prop. ∀ W:ι. P W).`
0.028[ty-infer] infer type of `mvalid = (λ P:ι → prop. ∀ W:ι. P W)`
0.028[typedSTerm] apply `(ι → prop) → prop` to []
0.028[ty-infer] typing of `mvalid` yields `mvalid` : `(ι → prop) → prop`
0.028[ty-infer] typing of `W` yields `W/51` : `ι`
0.028[ty-infer] apply P:ι → prop to [W/51]:[ι]
0.028[typedSTerm] apply `ι → prop` to [W/51]
0.028[ty-infer] typing of `P W` yields `P/50 W/51` : `prop`
0.028[ty-infer] unify types `prop` and `prop`
0.028[ty-infer]
    typing of `∀ W:ι. P W` yields `∀ W/51. (P/50 W/51)` : `prop`
0.029[ty-infer]
    typing of `λ P:ι → prop. ∀ W:ι. P W`
    yields `λ P/50:(ι → prop). (∀ W/51. (P/50 W/51))`
             : `(ι → prop) → prop`
0.029[ty-infer]
    unify types `(ι → prop) → prop` and `(ι → prop) → prop`
0.029[ty-infer]
    typing of `mvalid = (λ P:ι → prop. ∀ W:ι. P W)`
    yields `mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)))`
             : `prop`
0.029[ty-infer] unify types `prop` and `prop`
0.029[ty-infer]
    infer types for statement
      `val [name msatisfiable_decl] msatisfiable : (ι → prop) → prop.`
0.029[ty-infer] declare msatisfiable: (ι → prop) → prop
0.029[ty-infer]
    infer types for statement
      `assert [name msatisfiable]
         msatisfiable = (λ P:ι → prop. ∃ W:ι. P W).`
0.029[ty-infer]
    infer type of `msatisfiable = (λ P:ι → prop. ∃ W:ι. P W)`
0.029[typedSTerm] apply `(ι → prop) → prop` to []
0.029[ty-infer]
    typing of `msatisfiable` yields `msatisfiable` : `(ι → prop) → prop`
0.029[ty-infer] typing of `W` yields `W/54` : `ι`
0.029[ty-infer] apply P:ι → prop to [W/54]:[ι]
0.030[typedSTerm] apply `ι → prop` to [W/54]
0.030[ty-infer] typing of `P W` yields `P/53 W/54` : `prop`
0.030[ty-infer] unify types `prop` and `prop`
0.030[ty-infer]
    typing of `∃ W:ι. P W` yields `∃ W/54. (P/53 W/54)` : `prop`
0.030[ty-infer]
    typing of `λ P:ι → prop. ∃ W:ι. P W`
    yields `λ P/53:(ι → prop). (∃ W/54. (P/53 W/54))`
             : `(ι → prop) → prop`
0.030[ty-infer]
    unify types `(ι → prop) → prop` and `(ι → prop) → prop`
0.030[ty-infer]
    typing of `msatisfiable = (λ P:ι → prop. ∃ W:ι. P W)`
    yields `msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)))`
             : `prop`
0.030[ty-infer] unify types `prop` and `prop`
0.030[ty-infer]
    infer types for statement
      `val [name mcountersatisfiable_decl] mcountersatisfiable :
         (ι → prop) → prop.`
0.030[ty-infer] declare mcountersatisfiable: (ι → prop) → prop
0.030[ty-infer]
    infer types for statement
      `assert [name mcountersatisfiable]
         mcountersatisfiable = (λ P:ι → prop. ∃ W:ι. ¬ (P W)).`
0.031[ty-infer]
    infer type of
      `mcountersatisfiable = (λ P:ι → prop. ∃ W:ι. ¬ (P W))`
0.031[typedSTerm] apply `(ι → prop) → prop` to []
0.031[ty-infer]
    typing of `mcountersatisfiable`
    yields `mcountersatisfiable` : `(ι → prop) → prop`
0.031[ty-infer] typing of `W` yields `W/57` : `ι`
0.031[ty-infer] apply P:ι → prop to [W/57]:[ι]
0.031[typedSTerm] apply `ι → prop` to [W/57]
0.031[ty-infer] typing of `P W` yields `P/56 W/57` : `prop`
0.031[ty-infer] unify types `prop` and `prop`
0.031[ty-infer] typing of `¬ (P W)` yields `¬ (P/56 W/57)` : `prop`
0.031[ty-infer] unify types `prop` and `prop`
0.031[ty-infer]
    typing of `∃ W:ι. ¬ (P W)`
    yields `∃ W/57. (¬ (P/56 W/57))` : `prop`
0.031[ty-infer]
    typing of `λ P:ι → prop. ∃ W:ι. ¬ (P W)`
    yields `λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57)))`
             : `(ι → prop) → prop`
0.032[ty-infer]
    unify types `(ι → prop) → prop` and `(ι → prop) → prop`
0.032[ty-infer]
    typing of `mcountersatisfiable = (λ P:ι → prop. ∃ W:ι. ¬ (P W))`
    yields `mcountersatisfiable =
            (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))))` : `
             prop`
0.032[ty-infer] unify types `prop` and `prop`
0.032[ty-infer]
    infer types for statement
      `val [name minvalid_decl] minvalid : (ι → prop) → prop.`
0.032[ty-infer] declare minvalid: (ι → prop) → prop
0.032[ty-infer]
    infer types for statement
      `assert [name minvalid]
         minvalid = (λ P:ι → prop. ∀ W:ι. ¬ (P W)).`
0.032[ty-infer]
    infer type of `minvalid = (λ P:ι → prop. ∀ W:ι. ¬ (P W))`
0.033[typedSTerm] apply `(ι → prop) → prop` to []
0.033[ty-infer]
    typing of `minvalid` yields `minvalid` : `(ι → prop) → prop`
0.033[ty-infer] typing of `W` yields `W/60` : `ι`
0.033[ty-infer] apply P:ι → prop to [W/60]:[ι]
0.033[typedSTerm] apply `ι → prop` to [W/60]
0.033[ty-infer] typing of `P W` yields `P/59 W/60` : `prop`
0.033[ty-infer] unify types `prop` and `prop`
0.033[ty-infer] typing of `¬ (P W)` yields `¬ (P/59 W/60)` : `prop`
0.033[ty-infer] unify types `prop` and `prop`
0.033[ty-infer]
    typing of `∀ W:ι. ¬ (P W)`
    yields `∀ W/60. (¬ (P/59 W/60))` : `prop`
0.033[ty-infer]
    typing of `λ P:ι → prop. ∀ W:ι. ¬ (P W)`
    yields `λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60)))`
             : `(ι → prop) → prop`
0.034[ty-infer]
    unify types `(ι → prop) → prop` and `(ι → prop) → prop`
0.034[ty-infer]
    typing of `minvalid = (λ P:ι → prop. ∀ W:ι. ¬ (P W))`
    yields `minvalid = (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))))`
             : `prop`
0.034[ty-infer] unify types `prop` and `prop`
0.034[ty-infer]
    infer types for statement
      `goal [name thm]
         ∃ R:ι → (ι → prop).
           ∀ A:ι → prop. mvalid (mimpl (mbox R A) A).`
0.034[ty-infer]
    infer type of
      `∃ R:ι → (ι → prop).
         ∀ A:ι → prop. mvalid (mimpl (mbox R A) A)`
0.034[ty-infer] typing of `R` yields `R/61` : `ι → ι → prop`
0.034[ty-infer] typing of `A` yields `A/62` : `ι → prop`
0.034[ty-infer]
    apply mbox:(ι → ι → prop) → (ι → prop) → ι → prop
      to [R/61, A/62]:[ι → ι → prop, ι → prop]
0.035[typedSTerm]
    apply `(ι → ι → prop) → (ι → prop) → ι → prop`
    to [R/61, A/62]
0.035[ty-infer] typing of `mbox R A` yields `mbox R/61 A/62` : `ι → prop`
0.035[ty-infer] typing of `A` yields `A/62` : `ι → prop`
0.035[ty-infer]
    apply mimpl:(ι → prop) → (ι → prop) → ι → prop
      to [mbox R/61 A/62, A/62]:[ι → prop, ι → prop]
0.035[typedSTerm]
    apply `(ι → prop) → (ι → prop) → ι → prop`
    to [mbox R/61 A/62, A/62]
0.035[ty-infer]
    typing of `mimpl (mbox R A) A`
    yields `mimpl (mbox R/61 A/62) A/62` : `ι → prop`
0.035[ty-infer]
    apply mvalid:(ι → prop) → prop
      to [mimpl (mbox R/61 A/62) A/62]:[ι → prop]
0.035[typedSTerm]
    apply `(ι → prop) → prop` to [mimpl (mbox R/61 A/62) A/62]
0.035[ty-infer]
    typing of `mvalid (mimpl (mbox R A) A)`
    yields `mvalid (mimpl (mbox R/61 A/62) A/62)` : `prop`
0.036[ty-infer] unify types `prop` and `prop`
0.036[ty-infer]
    typing of `∀ A:ι → prop. mvalid (mimpl (mbox R A) A)`
    yields `∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62))`
             : `prop`
0.036[ty-infer] unify types `prop` and `prop`
0.036[ty-infer]
    typing of `∃ R:ι → (ι → prop).
                 ∀ A:ι → prop. mvalid (mimpl (mbox R A) A)`
    yields `∃ R/61:(ι → ι → prop).
              (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62)))`
             : `prop`
0.036[ty-infer] unify types `prop` and `prop`
0.036[zip]
    typed statements
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "current_world"] current_world :
        ι., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_a"] prop_a :
        ι → prop., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_b"] prop_b :
        ι → prop., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_c"] prop_c :
        ι → prop., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mfalse_decl"] mfalse :
        ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mfalse"]
        mfalse = (λ X/10. false)., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mtrue_decl"] mtrue :
        ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mtrue"]
        mtrue = (λ X/12. true)., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mnot_decl"] mnot :
        (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mnot"]
        mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mor_decl"] mor :
        (ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mor"]
        mor =
        (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
           ((Y/18 U/19) ∨ (X/17 U/19)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mand_decl"] mand :
        (ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mand"]
        mand =
        (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
           ((Y/22 U/23) ∧ (X/21 U/23)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mimpl_decl"] mimpl :
        (ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mimpl"]
        mimpl =
        (λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "miff_decl"] miff :
        (ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "miff"]
        miff =
        (λ U/28:(ι → prop) V/29:(ι → prop).
           (mand (mimpl U/28 V/29) (mimpl V/29 U/28)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mbox_decl"] mbox :
        (ι → ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mbox"]
        mbox =
        (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
           (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mdia_decl"] mdia :
        (ι → ι → prop) → (ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mdia"]
        mdia =
        (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
           (∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39))))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "individuals_decl"] individuals :
        type., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mall_decl"] mall :
        (individuals → ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mall"]
        mall =
        (λ P/42:(individuals → ι → prop) W/43.
           (∀ X/44:individuals. (P/42 X/44 W/43)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mexists_decl"] mexists :
        (individuals → ι → prop) → ι → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mexists"]
        mexists =
        (λ P/46:(individuals → ι → prop) W/47.
           (∃ X/48:individuals. (P/46 X/48 W/47)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mvalid_decl"] mvalid :
        (ι → prop) → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "mvalid"]
        mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "msatisfiable_decl"] msatisfiable :
        (ι → prop) → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "msatisfiable"]
        msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mcountersatisfiable_decl"] mcountersatisfiable :
        (ι → prop) → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "mcountersatisfiable"]
        mcountersatisfiable =
        (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))))., 
      val
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
         "minvalid_decl"] minvalid :
        (ι → prop) → prop., 
      assert
        [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "minvalid"]
        minvalid = (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))))., 
      goal [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "thm"]
        ∃ R/61:(ι → ι → prop).
          (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62))).
0.040[zip.int-arith] decision to register arith: false
0.040[zip.rat-arith] decision to register rat-arith: false
0.040[zip] terminate phase typing
0.040[zip] parsed 36 declarations (some goal(s))
0.040[zip] start phase cnf
0.040[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "current_world"] current_world :
               ι.`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "current_world"] current_world :
              ι.`
0.040[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "prop_a"] prop_a :
               (ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "prop_a"] prop_a :
              (ι → prop).`
0.040[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "prop_b"] prop_b :
               (ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "prop_b"] prop_b :
              (ι → prop).`
0.040[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "prop_c"] prop_c :
               (ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "prop_c"] prop_c :
              (ι → prop).`
0.041[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mfalse_decl"] mfalse :
               (ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mfalse_decl"] mfalse :
              (ι → prop).`
0.041[cnf] flatten_rec `mfalse = (λ X/10. false)` vars: ()
0.041[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mfalse"]
               mfalse = (λ X/10. false).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mfalse"]
              mfalse = (λ X/10. false).`
0.041[cnf] simplify and rename `mfalse = (λ X/10. false)`
0.041[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mtrue_decl"] mtrue :
               (ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mtrue_decl"] mtrue :
              (ι → prop).`
0.041[cnf] flatten_rec `mtrue = (λ X/12. true)` vars: ()
0.041[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mtrue"]
               mtrue = (λ X/12. true).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mtrue"]
              mtrue = (λ X/12. true).`
0.042[cnf] simplify and rename `mtrue = (λ X/12. true)`
0.042[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mnot_decl"] mnot :
               ((ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mnot_decl"] mnot :
              ((ι → prop) → ι → prop).`
0.042[cnf]
    flatten_rec `mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)))`
      vars: ()
0.042[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mnot"]
               mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mnot"]
              mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15))).`
0.042[cnf]
    simplify and rename
      `mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)))`
0.042[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mor_decl"] mor :
               ((ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mor_decl"] mor :
              ((ι → prop) → (ι → prop) → ι → prop).`
0.043[cnf]
    flatten_rec
      `mor =
       (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
          ((Y/18 U/19) ∨ (X/17 U/19)))`
      vars: ()
0.043[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mor"]
               mor =
               (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
                  ((Y/18 U/19) ∨ (X/17 U/19))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mor"]
              mor =
              (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
                 ((X/17 U/19) ∨ (Y/18 U/19))).`
0.043[cnf]
    simplify and rename
      `mor =
       (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
          ((X/17 U/19) ∨ (Y/18 U/19)))`
0.043[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mand_decl"] mand :
               ((ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mand_decl"] mand :
              ((ι → prop) → (ι → prop) → ι → prop).`
0.043[cnf]
    flatten_rec
      `mand =
       (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
          ((Y/22 U/23) ∧ (X/21 U/23)))`
      vars: ()
0.044[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mand"]
               mand =
               (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
                  ((Y/22 U/23) ∧ (X/21 U/23))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mand"]
              mand =
              (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
                 ((X/21 U/23) ∧ (Y/22 U/23))).`
0.044[cnf]
    simplify and rename
      `mand =
       (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
          ((X/21 U/23) ∧ (Y/22 U/23)))`
0.044[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mimpl_decl"] mimpl :
               ((ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mimpl_decl"] mimpl :
              ((ι → prop) → (ι → prop) → ι → prop).`
0.044[cnf]
    flatten_rec
      `mimpl =
       (λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26))`
      vars: ()
0.045[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mimpl"]
               mimpl =
               (λ U/25:(ι → prop) V/26:(ι → prop).
                  (mor (mnot U/25) V/26)).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mimpl"]
              mimpl =
              (λ U/25:(ι → prop) V/26:(ι → prop).
                 (mor (mnot U/25) V/26)).`
0.045[cnf]
    simplify and rename
      `mimpl =
       (λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26))`
0.045[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "miff_decl"] miff :
               ((ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "miff_decl"] miff :
              ((ι → prop) → (ι → prop) → ι → prop).`
0.045[cnf]
    flatten_rec
      `miff =
       (λ U/28:(ι → prop) V/29:(ι → prop).
          (mand (mimpl U/28 V/29) (mimpl V/29 U/28)))`
      vars: ()
0.046[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "miff"]
               miff =
               (λ U/28:(ι → prop) V/29:(ι → prop).
                  (mand (mimpl U/28 V/29) (mimpl V/29 U/28))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "miff"]
              miff =
              (λ U/28:(ι → prop) V/29:(ι → prop).
                 (mand (mimpl U/28 V/29) (mimpl V/29 U/28))).`
0.046[cnf]
    simplify and rename
      `miff =
       (λ U/28:(ι → prop) V/29:(ι → prop).
          (mand (mimpl U/28 V/29) (mimpl V/29 U/28)))`
0.046[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mbox_decl"] mbox :
               ((ι → ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mbox_decl"] mbox :
              ((ι → ι → prop) → (ι → prop) → ι → prop).`
0.046[cnf]
    flatten_rec
      `mbox =
       (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
          (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))))`
      vars: ()
0.046[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mbox"]
               mbox =
               (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
                  (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34)))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mbox"]
              mbox =
              (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
                 (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34)))).`
0.047[cnf]
    simplify and rename
      `mbox =
       (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
          (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))))`
0.047[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mdia_decl"] mdia :
               ((ι → ι → prop) → (ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mdia_decl"] mdia :
              ((ι → ι → prop) → (ι → prop) → ι → prop).`
0.047[cnf]
    flatten_rec
      `mdia =
       (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
          (∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39))))`
      vars: ()
0.047[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mdia"]
               mdia =
               (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
                  (∃ Y/39. ((P/37 Y/39) ∧ (R/36 X/38 Y/39)))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mdia"]
              mdia =
              (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
                 (∃ Y/39. ((R/36 X/38 Y/39) ∧ (P/37 Y/39)))).`
0.048[cnf]
    simplify and rename
      `mdia =
       (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
          (∃ Y/39. ((R/36 X/38 Y/39) ∧ (P/37 Y/39))))`
0.048[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "individuals_decl"] individuals :
               type.`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "individuals_decl"] individuals :
              type.`
0.048[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mall_decl"] mall :
               ((individuals → ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mall_decl"] mall :
              ((individuals → ι → prop) → ι → prop).`
0.048[cnf]
    flatten_rec
      `mall =
       (λ P/42:(individuals → ι → prop) W/43.
          (∀ X/44:individuals. (P/42 X/44 W/43)))`
      vars: ()
0.048[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mall"]
               mall =
               (λ P/42:(individuals → ι → prop) W/43.
                  (∀ X/44:individuals. (P/42 X/44 W/43))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mall"]
              mall =
              (λ P/42:(individuals → ι → prop) W/43.
                 (∀ X/44:individuals. (P/42 X/44 W/43))).`
0.049[cnf]
    simplify and rename
      `mall =
       (λ P/42:(individuals → ι → prop) W/43.
          (∀ X/44:individuals. (P/42 X/44 W/43)))`
0.049[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mexists_decl"] mexists :
               ((individuals → ι → prop) → ι → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mexists_decl"] mexists :
              ((individuals → ι → prop) → ι → prop).`
0.049[cnf]
    flatten_rec
      `mexists =
       (λ P/46:(individuals → ι → prop) W/47.
          (∃ X/48:individuals. (P/46 X/48 W/47)))`
      vars: ()
0.049[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mexists"]
               mexists =
               (λ P/46:(individuals → ι → prop) W/47.
                  (∃ X/48:individuals. (P/46 X/48 W/47))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mexists"]
              mexists =
              (λ P/46:(individuals → ι → prop) W/47.
                 (∃ X/48:individuals. (P/46 X/48 W/47))).`
0.050[cnf]
    simplify and rename
      `mexists =
       (λ P/46:(individuals → ι → prop) W/47.
          (∃ X/48:individuals. (P/46 X/48 W/47)))`
0.050[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mvalid_decl"] mvalid :
               ((ι → prop) → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mvalid_decl"] mvalid :
              ((ι → prop) → prop).`
0.050[cnf]
    flatten_rec `mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)))`
      vars: ()
0.050[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mvalid"]
               mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mvalid"]
              mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51))).`
0.050[cnf]
    simplify and rename
      `mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)))`
0.050[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "msatisfiable_decl"] msatisfiable :
               ((ι → prop) → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "msatisfiable_decl"] msatisfiable :
              ((ι → prop) → prop).`
0.050[cnf]
    flatten_rec
      `msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)))`
      vars: ()
0.051[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "msatisfiable"]
               msatisfiable =
               (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "msatisfiable"]
              msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54))).`
0.051[cnf]
    simplify and rename
      `msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)))`
0.051[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mcountersatisfiable_decl"] mcountersatisfiable :
               ((ι → prop) → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mcountersatisfiable_decl"] mcountersatisfiable :
              ((ι → prop) → prop).`
0.051[cnf]
    flatten_rec
      `mcountersatisfiable =
       (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))))`
      vars: ()
0.051[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "mcountersatisfiable"]
               mcountersatisfiable =
               (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57)))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "mcountersatisfiable"]
              mcountersatisfiable =
              (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57)))).`
0.051[cnf]
    simplify and rename
      `mcountersatisfiable =
       (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))))`
0.052[cnf]
    flatten `val
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "minvalid_decl"] minvalid :
               ((ι → prop) → prop).`
      into `val
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "minvalid_decl"] minvalid :
              ((ι → prop) → prop).`
0.052[cnf]
    flatten_rec
      `minvalid = (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))))`
      vars: ()
0.052[cnf]
    flatten `assert
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "minvalid"]
               minvalid =
               (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60)))).`
      into `assert
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "minvalid"]
              minvalid =
              (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60)))).`
0.052[cnf]
    simplify and rename
      `minvalid = (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))))`
0.052[cnf]
    flatten_rec
      `∃ R/61:(ι → ι → prop).
         (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62)))`
      vars: ()
0.052[cnf]
    flatten `goal
               [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
                "thm"]
               ∃ R/61:(ι → ι → prop).
                 (∀ A/62:(ι → prop).
                    (mvalid (mimpl (mbox R/61 A/62) A/62))).`
      into `goal
              [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
               "thm"]
              ∃ R/61:(ι → ι → prop).
                (∀ A/62:(ι → prop).
                   (mvalid (mimpl (mbox R/61 A/62) A/62))).`
0.053[cnf]
    simplify and rename
      `∃ R/61:(ι → ι → prop).
         (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62)))`
0.053[cnf] reduce `mfalse = (λ X/10. false)` to CNF
0.053[cnf] reduce `mtrue = (λ X/12. true)` to CNF
0.053[cnf]
    reduce `mnot = (λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)))` to CNF
0.053[cnf]
    reduce
      `mor =
       (λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
          ((X/17 U/19) ∨ (Y/18 U/19)))`
      to CNF
0.053[cnf]
    reduce
      `mand =
       (λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
          ((X/21 U/23) ∧ (Y/22 U/23)))`
      to CNF
0.054[cnf]
    reduce
      `mimpl =
       (λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26))`
      to CNF
0.054[cnf]
    reduce
      `miff =
       (λ U/28:(ι → prop) V/29:(ι → prop).
          (mand (mimpl U/28 V/29) (mimpl V/29 U/28)))`
      to CNF
0.054[cnf]
    reduce
      `mbox =
       (λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
          (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))))`
      to CNF
0.054[cnf]
    reduce
      `mdia =
       (λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
          (∃ Y/39. ((R/36 X/38 Y/39) ∧ (P/37 Y/39))))`
      to CNF
0.055[cnf]
    reduce
      `mall =
       (λ P/42:(individuals → ι → prop) W/43.
          (∀ X/44:individuals. (P/42 X/44 W/43)))`
      to CNF
0.055[cnf]
    reduce
      `mexists =
       (λ P/46:(individuals → ι → prop) W/47.
          (∃ X/48:individuals. (P/46 X/48 W/47)))`
      to CNF
0.055[cnf]
    reduce `mvalid = (λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)))` to CNF
0.055[cnf]
    reduce `msatisfiable = (λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)))`
      to CNF
0.055[cnf]
    reduce
      `mcountersatisfiable =
       (λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))))`
      to CNF
0.056[cnf]
    reduce `minvalid = (λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))))`
      to CNF
0.056[cnf]
    reduce
      `¬ (∃ R/61:(ι → ι → prop).
             (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62))))`
      to CNF
0.056[cnf]
    nnf of
      `¬ (∃ R/61:(ι → ι → prop).
             (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62))))`
0.056[cnf]
    nnf of
      `¬ (∀ A/62:(ι → prop). (mvalid (mimpl (mbox R/61 A/62) A/62)))`
0.056[cnf] nnf of `¬ (mvalid (mimpl (mbox R/61 A/62) A/62))`
0.056[cnf]
    ... NNF:
      `∀ R/61:(ι → ι → prop).
         (∃ A/62:(ι → prop). (¬ (mvalid (mimpl (mbox R/61 A/62) A/62))))`
0.056[cnf]
    ... miniscoped:
      `∀ R/61:(ι → ι → prop).
         (∃ A/62:(ι → prop). (¬ (mvalid (mimpl (mbox R/61 A/62) A/62))))`
0.057[cnf] rename `R/61` to `R/63` :subst {}
0.057[skolem]
    creating skolem for
      `∃ A/62:(ι → prop). (¬ (mvalid (mimpl (mbox R/61 A/62) A/62)))`
      with tyvars=[], vars=[R/63], subst={R/61 → R/63}
0.057[skolem]
    new skolem symbol `sk_A` with type `(ι → ι → prop) → ι → prop`
0.057[cnf] bind `A/62` to `sk_A R/63` :subst {R/61 → R/63}
0.057[cnf]
    ... skolemized: `¬ (mvalid (mimpl (mbox R/63 (sk_A R/63)) (sk_A R/63)))`
0.057[cnf] ... CNF: `¬ mvalid (mimpl (mbox R/63 (sk_A R/63)) (sk_A R/63))`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "current_world"] current_world :
         ι.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "current_world"] current_world :
         ι.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "current_world"] current_world :
            ι.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_a"] prop_a :
         ι → prop.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_a"] prop_a :
         ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "prop_a"] prop_a :
            ι → prop.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_b"] prop_b :
         ι → prop.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_b"] prop_b :
         ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "prop_b"] prop_b :
            ι → prop.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_c"] prop_c :
         ι → prop.`
0.058[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" "prop_c"] prop_c :
         ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "prop_c"] prop_c :
            ι → prop.`
0.059[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mfalse_decl"] mfalse :
         ι → prop.`
0.059[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mfalse_decl"] mfalse :
         ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mfalse_decl"] mfalse :
            ι → prop.`
0.059[cnf] convert `assert mfalse = λ X/10. false.`
0.059[cnf]
    convert `assert mfalse = λ X/10. false.`
    into `assert mfalse = λ (Y0:ι). false.`
0.059[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mtrue_decl"] mtrue :
         ι → prop.`
0.059[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mtrue_decl"] mtrue :
         ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mtrue_decl"] mtrue :
            ι → prop.`
0.059[cnf] convert `assert mtrue = λ X/12. true.`
0.059[cnf]
    convert `assert mtrue = λ X/12. true.`
    into `assert mtrue = λ (Y0:ι). true.`
0.059[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mnot_decl"] mnot :
         (ι → prop) → ι → prop.`
0.060[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mnot_decl"] mnot :
         (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mnot_decl"] mnot :
            (ι → prop) → ι → prop.`
0.060[cnf]
    convert `assert mnot = λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)).`
0.060[cnf]
    convert `assert mnot = λ X/14:(ι → prop) U/15. (¬ (X/14 U/15)).`
    into `assert mnot = λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1).`
0.060[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mor_decl"] mor :
         (ι → prop) → (ι → prop) → ι → prop.`
0.060[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mor_decl"] mor :
         (ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mor_decl"] mor :
            (ι → prop) → (ι → prop) → ι → prop.`
0.062[cnf]
    convert
      `assert
         mor =
         λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
           ((X/17 U/19) ∨ (Y/18 U/19)).`
0.062[cnf]
    convert
      `assert
         mor =
         λ X/17:(ι → prop) Y/18:(ι → prop) U/19.
           ((X/17 U/19) ∨ (Y/18 U/19)).`
    into `assert
            mor =
            λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((Y0 Y2 ∨ Y1 Y2)).`
0.062[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mand_decl"] mand :
         (ι → prop) → (ι → prop) → ι → prop.`
0.062[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mand_decl"] mand :
         (ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mand_decl"] mand :
            (ι → prop) → (ι → prop) → ι → prop.`
0.063[cnf]
    convert
      `assert
         mand =
         λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
           ((X/21 U/23) ∧ (Y/22 U/23)).`
0.063[cnf]
    convert
      `assert
         mand =
         λ X/21:(ι → prop) Y/22:(ι → prop) U/23.
           ((X/21 U/23) ∧ (Y/22 U/23)).`
    into `assert
            mand =
            λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((Y0 Y2 ∧ Y1 Y2)).`
0.063[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mimpl_decl"] mimpl :
         (ι → prop) → (ι → prop) → ι → prop.`
0.063[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mimpl_decl"] mimpl :
         (ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mimpl_decl"] mimpl :
            (ι → prop) → (ι → prop) → ι → prop.`
0.063[cnf]
    convert
      `assert
         mimpl =
         λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26).`
0.064[cnf]
    convert
      `assert
         mimpl =
         λ U/25:(ι → prop) V/26:(ι → prop). (mor (mnot U/25) V/26).`
    into `assert
            mimpl = λ (Y0:ι → prop) (Y1:ι → prop). (mor (mnot Y0) Y1).`
0.064[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "miff_decl"] miff :
         (ι → prop) → (ι → prop) → ι → prop.`
0.064[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "miff_decl"] miff :
         (ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "miff_decl"] miff :
            (ι → prop) → (ι → prop) → ι → prop.`
0.064[cnf]
    convert
      `assert
         miff =
         λ U/28:(ι → prop) V/29:(ι → prop).
           (mand (mimpl U/28 V/29) (mimpl V/29 U/28)).`
0.065[cnf]
    convert
      `assert
         miff =
         λ U/28:(ι → prop) V/29:(ι → prop).
           (mand (mimpl U/28 V/29) (mimpl V/29 U/28)).`
    into `assert
            miff =
            λ (Y0:ι → prop) (Y1:ι → prop).
             (mand (mimpl Y0 Y1) (mimpl Y1 Y0)).`
0.065[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mbox_decl"] mbox :
         (ι → ι → prop) → (ι → prop) → ι → prop.`
0.065[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mbox_decl"] mbox :
         (ι → ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mbox_decl"] mbox :
            (ι → ι → prop) → (ι → prop) → ι → prop.`
0.065[cnf]
    convert
      `assert
         mbox =
         λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
           (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))).`
0.066[cnf]
    convert
      `assert
         mbox =
         λ R/31:(ι → ι → prop) P/32:(ι → prop) X/33.
           (∀ Y/34. ((R/31 X/33 Y/34) ⇒ (P/32 Y/34))).`
    into `assert
            mbox =
            λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
             (·∀ (Y0 Y2 X0 ⇒ Y1 X0)).`
0.066[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mdia_decl"] mdia :
         (ι → ι → prop) → (ι → prop) → ι → prop.`
0.066[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mdia_decl"] mdia :
         (ι → ι → prop) → (ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mdia_decl"] mdia :
            (ι → ι → prop) → (ι → prop) → ι → prop.`
0.066[cnf]
    convert
      `assert
         mdia =
         λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
           (∃ Y/39. ((R/36 X/38 Y/39) ∧ (P/37 Y/39))).`
0.067[cnf]
    convert
      `assert
         mdia =
         λ R/36:(ι → ι → prop) P/37:(ι → prop) X/38.
           (∃ Y/39. ((R/36 X/38 Y/39) ∧ (P/37 Y/39))).`
    into `assert
            mdia =
            λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
             (·∃ (Y0 Y2 X1 ∧ Y1 X1)).`
0.067[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "individuals_decl"] individuals :
         type.`
0.067[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "individuals_decl"] individuals :
         type.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "individuals_decl"] individuals :
            type.`
0.067[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mall_decl"] mall :
         (individuals → ι → prop) → ι → prop.`
0.067[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mall_decl"] mall :
         (individuals → ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mall_decl"] mall :
            (individuals → ι → prop) → ι → prop.`
0.067[cnf]
    convert
      `assert
         mall =
         λ P/42:(individuals → ι → prop) W/43.
           (∀ X/44:individuals. (P/42 X/44 W/43)).`
0.067[cnf]
    convert
      `assert
         mall =
         λ P/42:(individuals → ι → prop) W/43.
           (∀ X/44:individuals. (P/42 X/44 W/43)).`
    into `assert
            mall =
            λ (Y0:individuals → ι → prop) (Y1:ι). (·∀ Y0 X2 Y1).`
0.068[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mexists_decl"] mexists :
         (individuals → ι → prop) → ι → prop.`
0.068[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mexists_decl"] mexists :
         (individuals → ι → prop) → ι → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mexists_decl"] mexists :
            (individuals → ι → prop) → ι → prop.`
0.068[cnf]
    convert
      `assert
         mexists =
         λ P/46:(individuals → ι → prop) W/47.
           (∃ X/48:individuals. (P/46 X/48 W/47)).`
0.068[cnf]
    convert
      `assert
         mexists =
         λ P/46:(individuals → ι → prop) W/47.
           (∃ X/48:individuals. (P/46 X/48 W/47)).`
    into `assert
            mexists =
            λ (Y0:individuals → ι → prop) (Y1:ι). (·∃ Y0 X3 Y1).`
0.068[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mvalid_decl"] mvalid :
         (ι → prop) → prop.`
0.068[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mvalid_decl"] mvalid :
         (ι → prop) → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mvalid_decl"] mvalid :
            (ι → prop) → prop.`
0.068[cnf]
    convert `assert mvalid = λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)).`
0.069[cnf]
    convert `assert mvalid = λ P/50:(ι → prop). (∀ W/51. (P/50 W/51)).`
    into `assert mvalid = λ (Y0:ι → prop). (·∀ Y0 X4).`
0.069[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "msatisfiable_decl"] msatisfiable :
         (ι → prop) → prop.`
0.069[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "msatisfiable_decl"] msatisfiable :
         (ι → prop) → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "msatisfiable_decl"] msatisfiable :
            (ι → prop) → prop.`
0.069[cnf]
    convert
      `assert msatisfiable = λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)).`
0.069[cnf]
    convert
      `assert msatisfiable = λ P/53:(ι → prop). (∃ W/54. (P/53 W/54)).`
    into `assert msatisfiable = λ (Y0:ι → prop). (·∃ Y0 X5).`
0.069[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mcountersatisfiable_decl"] mcountersatisfiable :
         (ι → prop) → prop.`
0.070[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "mcountersatisfiable_decl"] mcountersatisfiable :
         (ι → prop) → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "mcountersatisfiable_decl"] mcountersatisfiable :
            (ι → prop) → prop.`
0.070[cnf]
    convert
      `assert
         mcountersatisfiable =
         λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))).`
0.070[cnf]
    convert
      `assert
         mcountersatisfiable =
         λ P/56:(ι → prop). (∃ W/57. (¬ (P/56 W/57))).`
    into `assert mcountersatisfiable = λ (Y0:ι → prop). (·∃ ¬ Y0 X6).`
0.070[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "minvalid_decl"] minvalid :
         (ι → prop) → prop.`
0.070[cnf]
    convert
      `val
         [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
          "minvalid_decl"] minvalid :
         (ι → prop) → prop.`
    into `val
            [file "/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p" 
             "minvalid_decl"] minvalid :
            (ι → prop) → prop.`
0.070[cnf]
    convert
      `assert minvalid = λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))).`
0.071[cnf]
    convert
      `assert minvalid = λ P/59:(ι → prop). (∀ W/60. (¬ (P/59 W/60))).`
    into `assert minvalid = λ (Y0:ι → prop). (·∀ ¬ Y0 X7).`
0.071[cnf]
    convert `val [internal] sk_A : (ι → ι → prop) → ι → prop.`
0.071[cnf]
    convert `val [internal] sk_A : (ι → ι → prop) → ι → prop.`
    into `val [internal] sk_A : (ι → ι → prop) → ι → prop.`
0.071[cnf]
    convert
      `negated_goal
         ¬ mvalid (mimpl (mbox R/63 (sk_A R/63)) (sk_A R/63))
         # skolems: [(sk_A:(ι → ι → prop) → ι → prop)].`
0.071[cnf]
    convert
      `negated_goal
         ¬ mvalid (mimpl (mbox R/63 (sk_A R/63)) (sk_A R/63))
         # skolems: [(sk_A:(ι → ι → prop) → ι → prop)].`
    into `negated_goal
            ¬ mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))
            # skolems: [(sk_A:(ι → ι → prop) → ι → prop)].`
0.072[zip.ho] problem is HO
0.072[rewrite] Making rule for mfalse
0.072[zip.ho]  Adding constant def rule: `(mfalse := λ (Y0:ι). false [T])`
0.072[rewrite]
    declare mfalse as defined constant
      :rules {(mfalse := λ (Y0:ι). false [T])}
0.072[rewrite] Making rule for mtrue
0.072[zip.ho]  Adding constant def rule: `(mtrue := λ (Y0:ι). true [T])`
0.072[rewrite]
    declare mtrue as defined constant
      :rules {(mtrue := λ (Y0:ι). true [T])}
0.072[rewrite] Making rule for mnot
0.072[zip.ho]
     Adding constant def rule: `(mnot :=
                                   λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1) [T])`
0.073[rewrite]
    declare mnot as defined constant
      :rules {(mnot := λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1) [T])}
0.073[rewrite] Making rule for mor
0.073[zip.ho]
     Adding constant def rule: `(mor :=
                                   λ
                                    (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                                    ((Y0 Y2 ∨ Y1 Y2)) [T])`
0.073[rewrite]
    declare mor as defined constant
      :rules {(mor :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∨ Y1 Y2)) [T])}
0.074[rewrite] Making rule for mand
0.074[zip.ho]
     Adding constant def rule: `(mand :=
                                   λ
                                    (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                                    ((Y0 Y2 ∧ Y1 Y2)) [T])`
0.074[rewrite]
    declare mand as defined constant
      :rules {(mand :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∧ Y1 Y2)) [T])}
0.074[rewrite]
    (rewrite `mnot F-11`
       :using `mnot := λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)` :with `
       {}`[1] :rest [F-11])
0.074[rewrite]
    (rewrite `mor ((λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)) F-11) F-12 X-13`
       :using `mor :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1]
       :rest [(λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)) F-11,F-12,X-13])
0.075[rewrite] Making rule for mimpl
0.075[zip.ho]
     Adding constant def rule: `(mimpl :=
                                   λ
                                    (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                                    ((¬ Y0 Y2 ∨ Y1 Y2)) [T])`
0.075[rewrite]
    declare mimpl as defined constant
      :rules {(mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)) [T])}
0.075[rewrite]
    (rewrite `mimpl F-15 F-14`
       :using `mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1] :rest [F-15,F-14])
0.075[rewrite]
    (rewrite `mimpl F-14 F-15`
       :using `mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1] :rest [F-14,F-15])
0.075[rewrite]
    (rewrite `mand
               ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)))
                 F-14 F-15) 
               ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)))
                 F-15 F-14) 
               X-16`
       :using `mand :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∧ Y1 Y2))`
       :with `{}`[1]
       :rest [(λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2)))
               F-14 F-15,
              (λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2)))
               F-15 F-14,
              X-16])
0.076[rewrite] Making rule for miff
0.076[zip.ho]
     Adding constant def rule: `(miff :=
                                   λ
                                    (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                                    (((¬ Y0 Y2 ∨ Y1 Y2) ∧
                                       (¬ Y1 Y2 ∨ Y0 Y2))) [T])`
0.076[rewrite]
    declare miff as defined constant
      :rules {(miff :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2))) [T])}
0.076[rewrite] Making rule for mbox
0.076[zip.ho]
     Adding constant def rule: `(mbox :=
                                   λ
                                    (Y0:ι → ι → prop) (Y1:ι → prop) 
                                    (Y2:ι). (·∀ (Y0 Y2 X0 ⇒ Y1 X0)) [T])`
0.076[rewrite]
    declare mbox as defined constant
      :rules {(mbox :=
                 λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X0 ⇒ Y1 X0)) [T])}
0.076[rewrite] Making rule for mdia
0.076[zip.ho]
     Adding constant def rule: `(mdia :=
                                   λ
                                    (Y0:ι → ι → prop) (Y1:ι → prop) 
                                    (Y2:ι). (·∃ (Y0 Y2 X1 ∧ Y1 X1)) [T])`
0.076[rewrite]
    declare mdia as defined constant
      :rules {(mdia :=
                 λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∃ (Y0 Y2 X1 ∧ Y1 X1)) [T])}
0.076[rewrite] Making rule for mall
0.076[zip.ho]
     Adding constant def rule: `(mall :=
                                   λ
                                    (Y0:individuals → ι → prop) (Y1:ι).
                                    (·∀ Y0 X2 Y1) [T])`
0.076[rewrite]
    declare mall as defined constant
      :rules {(mall :=
                 λ (Y0:individuals → ι → prop) (Y1:ι).
                  (·∀ Y0 X2 Y1) [T])}
0.077[rewrite] Making rule for mexists
0.077[zip.ho]
     Adding constant def rule: `(mexists :=
                                   λ
                                    (Y0:individuals → ι → prop) (Y1:ι).
                                    (·∃ Y0 X3 Y1) [T])`
0.077[rewrite]
    declare mexists as defined constant
      :rules {(mexists :=
                 λ (Y0:individuals → ι → prop) (Y1:ι).
                  (·∃ Y0 X3 Y1) [T])}
0.077[rewrite] Making rule for mvalid
0.077[zip.ho]
     Adding constant def rule: `(mvalid := λ (Y0:ι → prop). (·∀ Y0 X4) [T])`
0.077[rewrite]
    declare mvalid as defined constant
      :rules {(mvalid := λ (Y0:ι → prop). (·∀ Y0 X4) [T])}
0.077[rewrite] Making rule for msatisfiable
0.077[zip.ho]
     Adding constant def rule: `(msatisfiable :=
                                   λ (Y0:ι → prop). (·∃ Y0 X5) [T])`
0.077[rewrite]
    declare msatisfiable as defined constant
      :rules {(msatisfiable := λ (Y0:ι → prop). (·∃ Y0 X5) [T])}
0.077[rewrite] Making rule for mcountersatisfiable
0.077[zip.ho]
     Adding constant def rule: `(mcountersatisfiable :=
                                   λ (Y0:ι → prop). (·∃ ¬ Y0 X6) [T])`
0.077[rewrite]
    declare mcountersatisfiable as defined constant
      :rules {(mcountersatisfiable := λ (Y0:ι → prop). (·∃ ¬ Y0 X6) [T])}
0.077[rewrite] Making rule for minvalid
0.078[zip.ho]
     Adding constant def rule: `(minvalid :=
                                   λ (Y0:ι → prop). (·∀ ¬ Y0 X7) [T])`
0.078[rewrite]
    declare minvalid as defined constant
      :rules {(minvalid := λ (Y0:ι → prop). (·∀ ¬ Y0 X7) [T])}
0.078[zip] terminate phase cnf
0.078[zip] start phase compute_prec
0.078[compute_prec] 2 precedence constraint(s)
0.078[zip] terminate phase compute_prec
0.078[zip]
    precedence:
      [sk_A < current_world < individuals < prop_a < prop_b < prop_c < 
         mimpl < mand < mbox < mnot < mor < mvalid < mall < 
         mcountersatisfiable < mdia < mexists < mfalse < miff < minvalid < 
         msatisfiable < mtrue]
0.078[zip] start phase compute_ord_select
0.078[zip] ordering kbo
0.078[zip] selection function: default
0.078[zip] terminate phase compute_ord_select
0.078[zip] start phase make_ctx
0.079[zip] terminate phase make_ctx
0.079[zip] start phase make_env
0.079[] create new SAT solver
0.079[] enable Avatar
0.079[zip] register extension Avatar (split: false)
0.079[zip.msat] check_real
0.079[zip.heuristics] register heuristics...
0.079[zip.ho] setup HO rules
0.079[zip] completeness is lost
0.079[ind_ty] setup inductive types calculus
0.079[rewrite] register Rewriting to Env...
0.079[zip.env] [ Adding rule rewrite_defs to env ]
0.079[zip.env] trigger on_input_statement
0.080[zip.env]
    clauses:
      [mimpl = λ (Y0:ι → prop) (Y1:ι → prop). (mor (mnot Y0) Y1)*]/9 
      [miff
        = λ (Y0:ι → prop) (Y1:ι → prop).
           (mand (mimpl Y0 Y1) (mimpl Y1 Y0))*]/10 
      forall (F8:ι → ι → prop).
      [¬mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))*]/11
    sos: 
0.080[zip] terminate phase make_env
0.080[zip] start phase pre_saturate
0.080[zip] terminate phase pre_saturate
0.080[zip] start phase saturate
0.080[zip] run for 300.000 s
[K[0.08s]  0 steps0.080[zip.env] rewrite clause `[Τ*]/6`...
0.080[zip.sup] @[neg_reflect did not simplify the clause @]
0.080[zip.env] rewrite clause `[Τ*]/6`...
0.080[zip.sup] [Τ*]/6 is a tautology
0.081[zip.saturate] given clause [Τ*]/6 is redundant
[K[0.08s]  1 steps0.081[zip.env] rewrite clause `[Τ*]/7`...
0.081[zip.sup] @[neg_reflect did not simplify the clause @]
0.081[zip.env] rewrite clause `[Τ*]/7`...
0.081[zip.sup] [Τ*]/7 is a tautology
0.081[zip.saturate] given clause [Τ*]/7 is redundant
[K[0.08s]  2 steps0.082[zip.env]
    rewrite clause
      `forall (F8:ι → ι → prop).
       [¬mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))*]/11`...
0.082[rewrite]
    (rewrite `mbox F8 (sk_A F8)`
       :using `mbox :=
                 λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83))`
       :with `{}`[1] :rest [F8,sk_A F8])
0.082[rewrite]
    (rewrite `mimpl
               ((λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)))
                 F8 (sk_A F8)) 
               (sk_A F8)`
       :using `mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1]
       :rest [(λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)))
               F8 (sk_A F8),
              sk_A F8])
0.083[rewrite]
    (rewrite `mvalid
               ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)))
                 ((λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                    (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)))
                   F8 (sk_A F8)) 
                 (sk_A F8))`
       :using `mvalid := λ (Y0:ι → prop). (·∀ Y0 X-84)` :with `
       {}`[1]
       :rest [(λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2)))
               ((λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)))
                 F8 (sk_A F8)) 
               (sk_A F8)])
0.084[rewrite]
     simpl rewrite `mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))`
      :into `(λ (Y0:ι → prop). (·∀ Y0 X-84))
              ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                 ((¬ Y0 Y2 ∨ Y1 Y2)))
                ((λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                   (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)))
                  F8 (sk_A F8)) 
                (sk_A F8))`
      :using {(mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))
               :with {}[1]), 
              (mbox :=
                 λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83))
               :with {}[1]), 
              (mvalid := λ (Y0:ι → prop). (·∀ Y0 X-84) :with {}[1])}
0.085[zip.env]
    rewrite `mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))`
      into `·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)`
      :proof ((mvalid := λ (Y0:ι → prop). (·∀ Y0 X-84) [T]), 
              (mbox :=
                 λ (Y0:ι → ι → prop) (Y1:ι → prop) (Y2:ι).
                  (·∀ (Y0 Y2 X-83 ⇒ Y1 X-83)) [T]), 
              (mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)) [T]))
0.086[zip.env]
    term rewritten clause `forall (F8:ι → ι → prop).
                           [¬mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))*]/11`
    into `forall X-84 X-83 (F8:ι → ι → prop).
          [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)*]/12`
0.086[zip.sup] @[neg_reflect did not simplify the clause @]
0.086[zip.env]
    rewrite clause
      `forall X-84 X-83 (F8:ι → ι → prop).
       [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)*]/12`...
0.086[zip.env]
    clause `forall (F8:ι → ι → prop).
            [¬mvalid (mimpl (mbox F8 (sk_A F8)) (sk_A F8))*]/11`
    simplified into `forall X-84 X-83 (F8:ι → ι → prop).
                     [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨
                                sk_A F8 X-84)*]/12`
0.087[zip.env]
    rewrite clause
      `forall X-84 X-83 (F8:ι → ι → prop).
       [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)*]/12`...
0.087[zip.sup] @[neg_reflect did not simplify the clause @]
0.087[zip.env]
    rewrite clause
      `forall X-84 X-83 (F8:ι → ι → prop).
       [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)*]/12`...
0.087[zip.env]
    rewrite clause
      `forall X-84 X-83 (F8:ι → ι → prop).
       [¬·∀ (¬ ·∀ (F8 X-84 X-83 ⇒ sk_A F8 X-83) ∨ sk_A F8 X-84)*]/12`...
0.088[cnf]
    flatten_rec
      `(¬ (∀ X-84/78.
              ((¬ (∀ X-83/79.
                      ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))))
               ∨ (sk_A X8/80 X-84/78))))`
      vars: (X8/80)
0.088[cnf]
    flatten `assert
               ∀ X8/80:(ι → ι → prop).
                 ((¬ (∀ X-84/78.
                         ((¬ (∀ X-83/79.
                                 ((X8/80 X-84/78 X-83/79) ⇒
                                  (sk_A X8/80 X-83/79))))
                          ∨ (sk_A X8/80 X-84/78))))).`
      into `assert
              ∀ X8/80:(ι → ι → prop).
                (¬ (∀ X-84/78.
                       ((sk_A X8/80 X-84/78)
                        ∨ (¬ (∀ X-83/79.
                                   ((X8/80 X-84/78 X-83/79) ⇒
                                    (sk_A X8/80 X-83/79))))))).`
0.088[cnf]
    simplify and rename
      `∀ X8/80:(ι → ι → prop).
         (¬ (∀ X-84/78.
                ((sk_A X8/80 X-84/78)
                 ∨ (¬ (∀ X-83/79.
                            ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79)))))))`
0.089[cnf]
    reduce
      `∀ X8/80:(ι → ι → prop).
         (¬ (∀ X-84/78.
                ((¬ (∀ X-83/79.
                        ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))))
                 ∨ (sk_A X8/80 X-84/78))))`
      to CNF
0.089[cnf]
    nnf of
      `∀ X8/80:(ι → ι → prop).
         (¬ (∀ X-84/78.
                ((¬ (∀ X-83/79.
                        ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))))
                 ∨ (sk_A X8/80 X-84/78))))`
0.089[cnf]
    nnf of
      `¬ (∀ X-84/78.
             ((¬ (∀ X-83/79.
                     ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))))
              ∨ (sk_A X8/80 X-84/78)))`
0.089[cnf]
    nnf of
      `¬ ((¬ (∀ X-83/79.
                  ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))))
           ∨ (sk_A X8/80 X-84/78))`
0.089[cnf]
    nnf of `∀ X-83/79. ((X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79))`
0.089[cnf] nnf of `(X8/80 X-84/78 X-83/79) ⇒ (sk_A X8/80 X-83/79)`
0.089[cnf] nnf of `(sk_A X8/80 X-83/79) ∨ (¬ (X8/80 X-84/78 X-83/79))`
0.090[cnf] nnf of `sk_A X8/80 X-83/79`
0.090[cnf] nnf of `¬ (X8/80 X-84/78 X-83/79)`
0.090[cnf] nnf of `¬ (sk_A X8/80 X-84/78)`
0.090[cnf]
    ... NNF:
      `∀ X8/80:(ι → ι → prop).
         (∃ X-84/78.
            ((¬ (sk_A X8/80 X-84/78))
             ∧ (∀ X-83/79.
                    ((¬ (X8/80 X-84/78 X-83/79)) ∨ (sk_A X8/80 X-83/79)))))`
0.090[cnf]
    ... miniscoped:
      `∀ X8/80:(ι → ι → prop).
         (∃ X-84/78.
            ((∀ X-83/79.
                ((sk_A X8/80 X-83/79) ∨ (¬ (X8/80 X-84/78 X-83/79))))
             ∧ (¬ (sk_A X8/80 X-84/78))))`
0.090[cnf] rename `X8/80` to `X8/81` :subst {}
0.090[skolem]
    creating skolem for
      `∃ X-84/78.
         ((∀ X-83/79.
             ((sk_A X8/80 X-83/79) ∨ (¬ (X8/80 X-84/78 X-83/79))))
          ∧ (¬ (sk_A X8/80 X-84/78)))`
      with tyvars=[], vars=[X8/81], subst={X8/80 → X8/81}
0.090[skolem]
    new skolem symbol `sk_X-84` with type `(ι → ι → prop) → ι`
0.090[cnf] bind `X-84/78` to `sk_X-84 X8/81` :subst {X8/80 → X8/81}
0.090[cnf]
    rename `X-83/79` to `X-83/83`
      :subst {X-84/78 → sk_X-84 X8/81, X8/80 → X8/81}
0.090[cnf]
    ... skolemized:
      `(¬ (sk_A X8/81 (sk_X-84 X8/81)))
       ∧ ((¬ (X8/81 (sk_X-84 X8/81) X-83/83)) ∨ (sk_A X8/81 X-83/83))`
0.091[cnf]
    ... CNF:
      `¬ sk_A X8/81 (sk_X-84 X8/81), 
       sk_A X8/81 X-83/83 ∨ ¬ X8/81 (sk_X-84 X8/81) X-83/83`
0.091[cnf] convert `val [internal] sk_X-84 : (ι → ι → prop) → ι.`
0.091[cnf]
    convert `val [internal] sk_X-84 : (ι → ι → prop) → ι.`
    into `val [internal] sk_X-84 : (ι → ι → prop) → ι.`
0.091[cnf] convert `assert ¬ sk_A X8/81 (sk_X-84 X8/81).`
0.091[cnf]
    convert `assert ¬ sk_A X8/81 (sk_X-84 X8/81).`
    into `assert ¬ sk_A F0 (sk_X-84 F0).`
0.091[cnf]
    convert `assert sk_A X8/81 X-83/83 ∨ ¬ X8/81 (sk_X-84 X8/81) X-83/83.`
0.091[cnf]
    convert `assert sk_A X8/81 X-83/83 ∨ ¬ X8/81 (sk_X-84 X8/81) X-83/83.`
    into `assert sk_A F0 X1 ∨ ¬ F0 (sk_X-84 F0) X1.`
0.091[zip.env] trigger on_input_statement
0.091[zip.env]
    clauses:
      forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13 
      forall (F0:ι → ι → prop) X1.
      [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14
    sos: 
0.091[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`...
0.091[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.091[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`...
0.092[zip.sup] @[neg_reflect did not simplify the clause @]
0.092[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`...
0.092[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`...
0.092[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.092[zip.sup] @[neg_reflect did not simplify the clause @]
0.092[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.092[unif] protected with set *
0.092[unif] protected with set *
0.092[unif] protected with set *
0.092[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.092[zip.saturate] ### step     2 ###
0.092[zip.saturate]
    given (2 steps, penalty 1):
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`
0.093[zip.env]
    do binary inferences with current active set:
      `{forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13}`
0.093[zip.env] apply binary rule superposition_active
0.093[zip.sup] ... cancel, will yield a tautology
0.093[zip.sup] ... cancel, will yield a tautology
0.093[zip.env] apply binary rule superposition_passive
0.093[zip.sup] ... cancel, will yield a tautology
0.093[zip.sup] ... cancel, will yield a tautology
0.093[zip.env] apply binary rule ctx_narrow
0.093[zip.env] apply binary rule narrow_term_defs
0.093[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13`...
0.093[zip.env] do unary inferences
0.093[zip.env] apply unary rule equality_resolution
0.093[zip.env] apply unary rule equality_factoring
0.093[zip.env] apply unary rule narrow_lit_defs
0.093[zip.env] apply unary rule ind_types.exhaustiveness
0.093[zip.env] apply unary rule ind_types.acyclicity
0.093[zip.env] apply unary rule ho_prim_enum
0.093[zip.env] apply unary rule neg_ext
0.093[zip.env] apply unary rule ho_ext_pos
0.093[zip.env] apply unary rule ho_complete_eq
0.093[zip.env] apply unary rule avatar_check_empty
0.093[zip.env] apply generating rule avatar.lemmas (full: false)
0.093[zip.env] apply generating rule avatar_check_sat (full: false)
0.093[zip.avatar] SAT-solver reports "SAT"
0.093[zip.saturate] inferred new clauses: []
[K[0.09s]  3 steps0.093[zip.env] rewrite clause `forall P0. [(true ∧ P0) = P0*]/0`...
0.093[zip.sup] @[neg_reflect did not simplify the clause @]
0.093[zip.env] rewrite clause `forall P0. [(true ∧ P0) = P0*]/0`...
0.093[zip.env] rewrite clause `forall P0. [(true ∧ P0) = P0*]/0`...
0.094[cnf] flatten_rec `((true ∧ X0/112) ≡ X0/112)` vars: (X0/112)
0.094[cnf]
    flatten `assert ∀ X0/112:prop. (((true ∧ X0/112) ≡ X0/112)).`
      into `assert ∀ X0/112:prop. ((X0/112) ≡ X0/112).`
0.094[cnf] simplify and rename `∀ X0/112:prop. ((X0/112) ≡ X0/112)`
0.094[cnf] reduce `∀ X0/112:prop. (X0/112 ≡ X0/112)` to CNF
0.094[cnf] nnf of `∀ X0/112:prop. (X0/112 ≡ X0/112)`
0.094[cnf] nnf of `X0/112 ≡ X0/112`
0.094[cnf] nnf of `(X0/112 ⇒ X0/112) ∧ (X0/112 ⇒ X0/112)`
0.094[cnf] nnf of `X0/112 ⇒ X0/112`
0.094[cnf] nnf of `X0/112 ∨ (¬ X0/112)`
0.094[cnf] nnf of `X0/112`
0.094[cnf] nnf of `¬ X0/112`
0.094[cnf] nnf of `X0/112 ⇒ X0/112`
0.094[cnf] nnf of `X0/112 ∨ (¬ X0/112)`
0.094[cnf] nnf of `X0/112`
0.094[cnf] nnf of `¬ X0/112`
0.094[cnf]
    ... NNF:
      `∀ X0/112:prop.
         (((¬ X0/112) ∨ X0/112) ∧ ((¬ X0/112) ∨ X0/112))`
0.094[cnf]
    ... miniscoped:
      `(∀ X0/112:prop. (X0/112 ∨ (¬ X0/112)))
       ∧ (∀ X0/112:prop. (X0/112 ∨ (¬ X0/112)))`
0.094[cnf] rename `X0/112` to `X0/113` :subst {}
0.094[cnf] rename `X0/112` to `X0/114` :subst {}
0.094[cnf]
    ... skolemized: `((¬ X0/114) ∨ X0/114) ∧ ((¬ X0/113) ∨ X0/113)`
0.094[cnf] ... CNF: `X0/114 ∨ ¬ X0/114, X0/113 ∨ ¬ X0/113`
0.094[cnf] convert `assert X0/114 ∨ ¬ X0/114.`
0.094[cnf] convert `assert X0/114 ∨ ¬ X0/114.` into `assert P0 ∨ ¬ P0.`
0.094[cnf] convert `assert X0/113 ∨ ¬ X0/113.`
0.094[cnf] convert `assert X0/113 ∨ ¬ X0/113.` into `assert P1 ∨ ¬ P1.`
0.094[zip.env] trigger on_input_statement
0.094[zip.env]
    clauses: forall P0. [P0* ∨ ¬P0*]/15 
             forall P1. [P1* ∨ ¬P1*]/16
    sos: 
0.094[zip.sup]
    forall P0. [P0* ∨ ¬P0*]/15 basic_simplifies into [Τ*]/17
    with {P0[0] → false[0]}
0.094[zip.env] rewrite clause `[Τ*]/17`...
0.094[zip.env] rewrite clause `[Τ*]/17`...
0.094[zip.sup]
    forall P1. [P1* ∨ ¬P1*]/16 basic_simplifies into [Τ*]/18
    with {P1[0] → false[0]}
0.094[zip.env] rewrite clause `[Τ*]/18`...
0.094[zip.env] rewrite clause `[Τ*]/18`...
0.094[zip.env] rewrite clause `[Τ*]/17`...
0.094[zip.sup] @[neg_reflect did not simplify the clause @]
0.094[zip.env] rewrite clause `[Τ*]/17`...
0.094[zip.sup] [Τ*]/17 is a tautology
0.094[zip.env] rewrite clause `[Τ*]/18`...
0.094[zip.sup] @[neg_reflect did not simplify the clause @]
0.094[zip.env] rewrite clause `[Τ*]/18`...
0.094[zip.sup] [Τ*]/18 is a tautology
0.094[zip.saturate]
    given clause forall P0. [(true ∧ P0) = P0*]/0 is redundant
[K[0.09s]  4 steps0.094[zip.env] rewrite clause `forall P0. [¬(false ∧ P0)*]/1`...
0.094[zip.sup] @[neg_reflect did not simplify the clause @]
0.094[zip.env] rewrite clause `forall P0. [¬(false ∧ P0)*]/1`...
0.095[zip.env] rewrite clause `forall P0. [¬(false ∧ P0)*]/1`...
0.095[cnf] flatten_rec `(¬ (false ∧ X0/115))` vars: (X0/115)
0.095[cnf]
    flatten `assert ∀ X0/115:prop. ((¬ (false ∧ X0/115))).`
      into `assert ∀ X0/115:prop. (¬ (X0/115 ∧ false)).`
0.095[cnf] simplify and rename `∀ X0/115:prop. (¬ (X0/115 ∧ false))`
0.095[cnf] reduce `∀ X0/115:prop. (¬ (false ∧ X0/115))` to CNF
0.095[cnf] nnf of `∀ X0/115:prop. (¬ (false ∧ X0/115))`
0.095[cnf] nnf of `¬ (false ∧ X0/115)`
0.095[cnf] nnf of `true`
0.095[cnf] nnf of `¬ X0/115`
0.095[cnf] ... NNF: `∀ X0/115:prop. ((¬ X0/115) ∨ true)`
0.095[cnf] ... miniscoped: `true ∨ (∀ X0/115:prop. (¬ X0/115))`
0.095[cnf] rename `X0/115` to `X0/116` :subst {}
0.095[cnf] ... skolemized: `(¬ X0/116) ∨ true`
0.095[cnf] ... CNF: `true ∨ ¬ X0/116`
0.095[cnf] convert `assert true ∨ ¬ X0/116.`
0.095[cnf] convert `assert true ∨ ¬ X0/116.` into `assert true ∨ ¬ P0.`
0.095[zip.env] trigger on_input_statement
0.095[zip.env] clauses: forall P0. [Τ ∨ ¬P0*]/19
               sos: 
0.095[zip.env] rewrite clause `forall P0. [Τ ∨ ¬P0*]/19`...
0.095[zip.env] rewrite clause `forall P0. [Τ ∨ ¬P0*]/19`...
0.095[zip.sup] @[neg_reflect did not simplify the clause @]
0.095[zip.env] rewrite clause `forall P0. [Τ ∨ ¬P0*]/19`...
0.095[zip.sup] forall P0. [Τ ∨ ¬P0*]/19 is a tautology
0.095[zip.saturate]
    given clause forall P0. [¬(false ∧ P0)*]/1 is redundant
[K[0.10s]  5 steps0.095[zip.env] rewrite clause `forall P0. [(true ∨ P0)*]/2`...
0.095[zip.sup] @[neg_reflect did not simplify the clause @]
0.095[zip.env] rewrite clause `forall P0. [(true ∨ P0)*]/2`...
0.095[zip.env] rewrite clause `forall P0. [(true ∨ P0)*]/2`...
0.095[cnf] flatten_rec `(true ∨ X0/117)` vars: (X0/117)
0.095[cnf]
    flatten `assert ∀ X0/117:prop. ((true ∨ X0/117)).`
      into `assert ∀ X0/117:prop. (X0/117 ∨ true).`
0.095[cnf] simplify and rename `∀ X0/117:prop. (X0/117 ∨ true)`
0.095[cnf] reduce `∀ X0/117:prop. (true ∨ X0/117)` to CNF
0.095[cnf] nnf of `∀ X0/117:prop. (true ∨ X0/117)`
0.095[cnf] nnf of `true ∨ X0/117`
0.095[cnf] nnf of `true`
0.095[cnf] nnf of `X0/117`
0.095[cnf] ... NNF: `∀ X0/117:prop. (X0/117 ∨ true)`
0.095[cnf] ... miniscoped: `true ∨ (∀ X0/117:prop. X0/117)`
0.095[cnf] rename `X0/117` to `X0/118` :subst {}
0.095[cnf] ... skolemized: `X0/118 ∨ true`
0.095[cnf] ... CNF: `true ∨ X0/118`
0.095[cnf] convert `assert true ∨ X0/118.`
0.095[cnf] convert `assert true ∨ X0/118.` into `assert true ∨ P0.`
0.095[zip.env] trigger on_input_statement
0.095[zip.env] clauses: forall P0. [Τ ∨ P0*]/20
               sos: 
0.095[zip.sup]
    forall P0. [Τ ∨ P0*]/20 basic_simplifies into [Τ*]/21
    with {P0[0] → false[0]}
0.095[zip.env] rewrite clause `[Τ*]/21`...
0.096[zip.env] rewrite clause `[Τ*]/21`...
0.096[zip.env] rewrite clause `[Τ*]/21`...
0.096[zip.sup] @[neg_reflect did not simplify the clause @]
0.096[zip.env] rewrite clause `[Τ*]/21`...
0.096[zip.sup] [Τ*]/21 is a tautology
0.096[zip.saturate] given clause forall P0. [(true ∨ P0)*]/2 is redundant
[K[0.10s]  6 steps0.096[zip.env] rewrite clause `forall P0. [(false ∨ P0) = P0*]/3`...
0.096[zip.sup] @[neg_reflect did not simplify the clause @]
0.096[zip.env] rewrite clause `forall P0. [(false ∨ P0) = P0*]/3`...
0.096[zip.env] rewrite clause `forall P0. [(false ∨ P0) = P0*]/3`...
0.096[cnf] flatten_rec `((false ∨ X0/119) ≡ X0/119)` vars: (X0/119)
0.096[cnf]
    flatten `assert ∀ X0/119:prop. (((false ∨ X0/119) ≡ X0/119)).`
      into `assert ∀ X0/119:prop. ((X0/119) ≡ X0/119).`
0.096[cnf] simplify and rename `∀ X0/119:prop. ((X0/119) ≡ X0/119)`
0.096[cnf] reduce `∀ X0/119:prop. (X0/119 ≡ X0/119)` to CNF
0.096[cnf] nnf of `∀ X0/119:prop. (X0/119 ≡ X0/119)`
0.096[cnf] nnf of `X0/119 ≡ X0/119`
0.096[cnf] nnf of `(X0/119 ⇒ X0/119) ∧ (X0/119 ⇒ X0/119)`
0.096[cnf] nnf of `X0/119 ⇒ X0/119`
0.096[cnf] nnf of `X0/119 ∨ (¬ X0/119)`
0.096[cnf] nnf of `X0/119`
0.096[cnf] nnf of `¬ X0/119`
0.096[cnf] nnf of `X0/119 ⇒ X0/119`
0.096[cnf] nnf of `X0/119 ∨ (¬ X0/119)`
0.096[cnf] nnf of `X0/119`
0.096[cnf] nnf of `¬ X0/119`
0.096[cnf]
    ... NNF:
      `∀ X0/119:prop.
         (((¬ X0/119) ∨ X0/119) ∧ ((¬ X0/119) ∨ X0/119))`
0.096[cnf]
    ... miniscoped:
      `(∀ X0/119:prop. (X0/119 ∨ (¬ X0/119)))
       ∧ (∀ X0/119:prop. (X0/119 ∨ (¬ X0/119)))`
0.096[cnf] rename `X0/119` to `X0/120` :subst {}
0.096[cnf] rename `X0/119` to `X0/121` :subst {}
0.096[cnf]
    ... skolemized: `((¬ X0/121) ∨ X0/121) ∧ ((¬ X0/120) ∨ X0/120)`
0.096[cnf] ... CNF: `X0/121 ∨ ¬ X0/121, X0/120 ∨ ¬ X0/120`
0.096[cnf] convert `assert X0/121 ∨ ¬ X0/121.`
0.096[cnf] convert `assert X0/121 ∨ ¬ X0/121.` into `assert P0 ∨ ¬ P0.`
0.096[cnf] convert `assert X0/120 ∨ ¬ X0/120.`
0.096[cnf] convert `assert X0/120 ∨ ¬ X0/120.` into `assert P1 ∨ ¬ P1.`
0.096[zip.env] trigger on_input_statement
0.096[zip.env]
    clauses: forall P0. [P0* ∨ ¬P0*]/22 
             forall P1. [P1* ∨ ¬P1*]/23
    sos: 
0.096[zip.sup]
    forall P0. [P0* ∨ ¬P0*]/22 basic_simplifies into [Τ*]/24
    with {P0[0] → false[0]}
0.096[zip.env] rewrite clause `[Τ*]/24`...
0.096[zip.env] rewrite clause `[Τ*]/24`...
0.096[zip.sup]
    forall P1. [P1* ∨ ¬P1*]/23 basic_simplifies into [Τ*]/25
    with {P1[0] → false[0]}
0.096[zip.env] rewrite clause `[Τ*]/25`...
0.096[zip.env] rewrite clause `[Τ*]/25`...
0.096[zip.env] rewrite clause `[Τ*]/24`...
0.096[zip.sup] @[neg_reflect did not simplify the clause @]
0.097[zip.env] rewrite clause `[Τ*]/24`...
0.097[zip.sup] [Τ*]/24 is a tautology
0.097[zip.env] rewrite clause `[Τ*]/25`...
0.097[zip.sup] @[neg_reflect did not simplify the clause @]
0.097[zip.env] rewrite clause `[Τ*]/25`...
0.097[zip.sup] [Τ*]/25 is a tautology
0.097[zip.saturate]
    given clause forall P0. [(false ∨ P0) = P0*]/3 is redundant
[K[0.10s]  7 steps0.097[zip.env] rewrite clause `forall P0. [(true ⇒ P0) = P0*]/4`...
0.097[zip.sup] @[neg_reflect did not simplify the clause @]
0.097[zip.env] rewrite clause `forall P0. [(true ⇒ P0) = P0*]/4`...
0.097[zip.env] rewrite clause `forall P0. [(true ⇒ P0) = P0*]/4`...
0.097[cnf] flatten_rec `((true ⇒ X0/122) ≡ X0/122)` vars: (X0/122)
0.097[cnf]
    flatten `assert ∀ X0/122:prop. (((true ⇒ X0/122) ≡ X0/122)).`
      into `assert ∀ X0/122:prop. ((true ⇒ X0/122) ≡ X0/122).`
0.097[cnf]
    simplify and rename `∀ X0/122:prop. ((true ⇒ X0/122) ≡ X0/122)`
0.097[cnf] reduce `∀ X0/122:prop. ((true ⇒ X0/122) ≡ X0/122)` to CNF
0.097[cnf] nnf of `∀ X0/122:prop. ((true ⇒ X0/122) ≡ X0/122)`
0.097[cnf] nnf of `(true ⇒ X0/122) ≡ X0/122`
0.097[cnf]
    nnf of
      `(X0/122 ⇒ (true ⇒ X0/122)) ∧ ((true ⇒ X0/122) ⇒ X0/122)`
0.097[cnf] nnf of `X0/122 ⇒ (true ⇒ X0/122)`
0.097[cnf] nnf of `(true ⇒ X0/122) ∨ (¬ X0/122)`
0.097[cnf] nnf of `true ⇒ X0/122`
0.097[cnf] nnf of `X0/122`
0.097[cnf] nnf of `X0/122`
0.097[cnf] nnf of `¬ X0/122`
0.097[cnf] nnf of `(true ⇒ X0/122) ⇒ X0/122`
0.097[cnf] nnf of `X0/122 ∨ (¬ (true ⇒ X0/122))`
0.097[cnf] nnf of `X0/122`
0.097[cnf] nnf of `¬ (true ⇒ X0/122)`
0.097[cnf] nnf of `(¬ X0/122)`
0.097[cnf] nnf of `¬ X0/122`
0.097[cnf]
    ... NNF:
      `∀ X0/122:prop.
         (((¬ X0/122) ∨ X0/122) ∧ ((¬ X0/122) ∨ X0/122))`
0.097[cnf]
    ... miniscoped:
      `(∀ X0/122:prop. (X0/122 ∨ (¬ X0/122)))
       ∧ (∀ X0/122:prop. (X0/122 ∨ (¬ X0/122)))`
0.097[cnf] rename `X0/122` to `X0/123` :subst {}
0.097[cnf] rename `X0/122` to `X0/124` :subst {}
0.097[cnf]
    ... skolemized: `((¬ X0/124) ∨ X0/124) ∧ ((¬ X0/123) ∨ X0/123)`
0.097[cnf] ... CNF: `X0/124 ∨ ¬ X0/124, X0/123 ∨ ¬ X0/123`
0.097[cnf] convert `assert X0/124 ∨ ¬ X0/124.`
0.098[cnf] convert `assert X0/124 ∨ ¬ X0/124.` into `assert P0 ∨ ¬ P0.`
0.098[cnf] convert `assert X0/123 ∨ ¬ X0/123.`
0.098[cnf] convert `assert X0/123 ∨ ¬ X0/123.` into `assert P1 ∨ ¬ P1.`
0.098[zip.env] trigger on_input_statement
0.098[zip.env]
    clauses: forall P0. [P0* ∨ ¬P0*]/26 
             forall P1. [P1* ∨ ¬P1*]/27
    sos: 
0.098[zip.sup]
    forall P0. [P0* ∨ ¬P0*]/26 basic_simplifies into [Τ*]/28
    with {P0[0] → false[0]}
0.098[zip.env] rewrite clause `[Τ*]/28`...
0.098[zip.env] rewrite clause `[Τ*]/28`...
0.098[zip.sup]
    forall P1. [P1* ∨ ¬P1*]/27 basic_simplifies into [Τ*]/29
    with {P1[0] → false[0]}
0.098[zip.env] rewrite clause `[Τ*]/29`...
0.098[zip.env] rewrite clause `[Τ*]/29`...
0.098[zip.env] rewrite clause `[Τ*]/28`...
0.098[zip.sup] @[neg_reflect did not simplify the clause @]
0.098[zip.env] rewrite clause `[Τ*]/28`...
0.098[zip.sup] [Τ*]/28 is a tautology
0.098[zip.env] rewrite clause `[Τ*]/29`...
0.098[zip.sup] @[neg_reflect did not simplify the clause @]
0.098[zip.env] rewrite clause `[Τ*]/29`...
0.098[zip.sup] [Τ*]/29 is a tautology
0.098[zip.saturate]
    given clause forall P0. [(true ⇒ P0) = P0*]/4 is redundant
[K[0.10s]  8 steps0.098[zip.env] rewrite clause `forall P0. [(false ⇒ P0)*]/5`...
0.098[zip.sup] @[neg_reflect did not simplify the clause @]
0.098[zip.env] rewrite clause `forall P0. [(false ⇒ P0)*]/5`...
0.099[zip.env] rewrite clause `forall P0. [(false ⇒ P0)*]/5`...
0.099[cnf] flatten_rec `(false ⇒ X0/125)` vars: (X0/125)
0.099[cnf]
    flatten `assert ∀ X0/125:prop. ((false ⇒ X0/125)).`
      into `assert ∀ X0/125:prop. (false ⇒ X0/125).`
0.099[cnf] simplify and rename `∀ X0/125:prop. (false ⇒ X0/125)`
0.099[cnf] reduce `∀ X0/125:prop. (false ⇒ X0/125)` to CNF
0.099[cnf] nnf of `∀ X0/125:prop. (false ⇒ X0/125)`
0.099[cnf] nnf of `false ⇒ X0/125`
0.099[cnf] nnf of `X0/125 ∨ true`
0.099[cnf] nnf of `X0/125`
0.099[cnf] nnf of `true`
0.099[cnf] ... NNF: `∀ X0/125:prop. (true ∨ X0/125)`
0.099[cnf] ... miniscoped: `true ∨ (∀ X0/125:prop. X0/125)`
0.099[cnf] rename `X0/125` to `X0/126` :subst {}
0.099[cnf] ... skolemized: `X0/126 ∨ true`
0.099[cnf] ... CNF: `true ∨ X0/126`
0.099[cnf] convert `assert true ∨ X0/126.`
0.099[cnf] convert `assert true ∨ X0/126.` into `assert true ∨ P0.`
0.099[zip.env] trigger on_input_statement
0.099[zip.env] clauses: forall P0. [Τ ∨ P0*]/30
               sos: 
0.099[zip.sup]
    forall P0. [Τ ∨ P0*]/30 basic_simplifies into [Τ*]/31
    with {P0[0] → false[0]}
0.099[zip.env] rewrite clause `[Τ*]/31`...
0.099[zip.env] rewrite clause `[Τ*]/31`...
0.099[zip.env] rewrite clause `[Τ*]/31`...
0.099[zip.sup] @[neg_reflect did not simplify the clause @]
0.099[zip.env] rewrite clause `[Τ*]/31`...
0.099[zip.sup] [Τ*]/31 is a tautology
0.099[zip.saturate] given clause forall P0. [(false ⇒ P0)*]/5 is redundant
[K[0.10s]  9 steps0.099[zip.env]
    lambda rewritten clause `[mimpl
                               = λ (Y0:ι → prop) (Y1:ι → prop).
                                  (mor (mnot Y0) Y1)*]/9`
    into `[mimpl = λ (Y0:ι → prop). (mor (mnot Y0))*]/32`
0.099[zip.env]
    rewrite clause `[mimpl = λ (Y0:ι → prop). (mor (mnot Y0))*]/32`...
0.099[rewrite]
    rewrite `mimpl`
      using `mimpl :=
               λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2))`
0.099[rewrite]
     simpl rewrite `mimpl`
      :into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
              ((¬ Y0 Y2 ∨ Y1 Y2))`
      :using {(mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))
               :with {}[1])}
0.099[zip.env]
    rewrite `mimpl`
      into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
             ((¬ Y0 Y2 ∨ Y1 Y2))`
      :proof ((mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)) [T]))
0.100[rewrite]
    (rewrite `mnot Y-1`
       :using `mnot := λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)` :with `
       {}`[1] :rest [Y-1])
0.100[rewrite]
    (rewrite `mor ((λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)) Y-1)`
       :using `mor :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1] :rest [(λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1)) Y-1])
0.100[rewrite]
     simpl rewrite `λ (Y0:ι → prop). (mor (mnot Y0))`
      :into `λ (Y0:ι → prop).
              ((λ (Y1:ι → prop) (Y2:ι → prop) (Y3:ι).
                 ((Y1 Y3 ∨ Y2 Y3)))
                ((λ (Y1:ι → prop) (Y2:ι). (¬ Y1 Y2)) Y0))`
      :using {(mnot := λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1) :with {}[1]), 
              (mor :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∨ Y1 Y2))
               :with {}[1])}
0.100[zip.env]
    rewrite `λ (Y0:ι → prop). (mor (mnot Y0))`
      into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
             ((¬ Y0 Y2 ∨ Y1 Y2))`
      :proof ((mor :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∨ Y1 Y2)) [T]), 
              (mnot := λ (Y0:ι → prop) (Y1:ι). (¬ Y0 Y1) [T]))
0.100[zip.env]
    term rewritten clause `[mimpl = λ (Y0:ι → prop). (mor (mnot Y0))*]/32`
    into `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            ((¬ Y0 Y2 ∨ Y1 Y2))
            = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
               ((¬ Y0 Y2 ∨ Y1 Y2))*]/33`
0.100[zip.sup] @[neg_reflect did not simplify the clause @]
0.100[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((¬ Y0 Y2 ∨ Y1 Y2))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            ((¬ Y0 Y2 ∨ Y1 Y2))*]/33`...
0.100[zip.env]
    clause `[mimpl = λ (Y0:ι → prop) (Y1:ι → prop). (mor (mnot Y0) Y1)*]/9`
    simplified into `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                       ((¬ Y0 Y2 ∨ Y1 Y2))
                       = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                          ((¬ Y0 Y2 ∨ Y1 Y2))*]/33`
0.100[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((¬ Y0 Y2 ∨ Y1 Y2))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            ((¬ Y0 Y2 ∨ Y1 Y2))*]/33`...
0.100[zip.sup] @[neg_reflect did not simplify the clause @]
0.100[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((¬ Y0 Y2 ∨ Y1 Y2))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            ((¬ Y0 Y2 ∨ Y1 Y2))*]/33`...
0.101[zip.sup]
    [λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((¬ Y0 Y2 ∨ Y1 Y2))
      = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι). ((¬ Y0 Y2 ∨ Y1 Y2))*]/33
    is a tautology
0.101[zip.saturate]
    given clause [mimpl
                   = λ (Y0:ι → prop) (Y1:ι → prop). (mor (mnot Y0) Y1)*]/9
      is redundant
[K[0.10s]  10 steps0.101[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.101[zip.sup] @[neg_reflect did not simplify the clause @]
0.101[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.101[unif] protected with set *
0.101[unif] protected with set *
0.101[unif] protected with set *
0.101[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.101[zip.saturate] ### step    10 ###
0.101[zip.saturate]
    given (10 steps, penalty 1):
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`
0.102[zip.env]
    do binary inferences with current active set:
      `{forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13,
        forall (F0:ι → ι → prop) X1.
        [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14}`
0.102[zip.env] apply binary rule superposition_active
0.104[zip.sup] ... cancel, will yield a tautology
0.104[zip.sup] ... cancel, will yield a tautology
0.104[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] s=sk_A F0 X1
         t=true, t'=true)
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         passive_lit=¬sk_A F0 (sk_X-84 F0) p=0.←.ε)
      with subst={X1[0] → sk_X-84 F0[1], F0[1] → F0[0]}.

0.104[zip.sup]
    Res: forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34.

0.104[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] s=sk_A F0 X1
         t=true, t'=true)
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         passive_lit=¬sk_A F0 (sk_X-84 F0) p=0.←.ε)
      with subst={F0[0] → F1[2], 
                  X1[0] → X2[2], 
                  F0[1] → F0[2], 
                  F0[2] → F3[2], 
                  F1[2] → F3[2], 
                  X2[2] → sk_X-84 F3[2]}.

0.105[zip.sup]
    Res: forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35.

0.105[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.105[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
         [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
          sk_A F2 X3*]/36.

0.105[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.106[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
         [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
          sk_A F2 X3*]/37.

0.109[zip.sup] ... cancel, will yield a tautology
0.112[zip.env] apply binary rule superposition_passive
0.114[zip.sup] ... cancel, will yield a tautology
0.114[zip.sup] ... cancel, will yield a tautology
0.114[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         s=sk_A F0 (sk_X-84 F0) t=false, t'=false)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] passive_lit=sk_A F0 X1
         p=0.←.ε)
      with subst={X1[0] → sk_X-84 F0[1], F0[1] → F0[0]}.

0.115[zip.sup]
    Res: forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38.

0.115[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         s=sk_A F0 (sk_X-84 F0) t=false, t'=false)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0] passive_lit=sk_A F0 X1
         p=0.←.ε)
      with subst={F0[0] → F1[2], 
                  X1[0] → X2[2], 
                  F0[1] → F0[2], 
                  F0[2] → F3[2], 
                  F1[2] → F3[2], 
                  X2[2] → sk_X-84 F3[2]}.

0.115[zip.sup]
    Res: forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39.

0.118[zip.sup] ... cancel, will yield a tautology
0.123[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.124[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
         [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
          sk_A F2 X3*]/40.

0.124[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[0]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.124[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
         [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
          sk_A F2 X3*]/41.

0.124[zip.env] apply binary rule ctx_narrow
0.124[zip.env] apply binary rule narrow_term_defs
0.124[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14`...
0.124[zip.env] do unary inferences
0.124[zip.env] apply unary rule equality_resolution
0.124[zip.env] apply unary rule equality_factoring
0.127[zip.env] apply unary rule narrow_lit_defs
0.127[zip.env] apply unary rule ind_types.exhaustiveness
0.127[zip.env] apply unary rule ind_types.acyclicity
0.127[zip.env] apply unary rule ho_prim_enum
0.127[zip.ho]
    (ho.refine
       :clause forall (F0:ι → ι → prop) X1.
               [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14
       :terms {F0})
0.127[zip.ho]
    (ho.refine
       :from forall (F0:ι → ι → prop) X1.
             [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14
       :subst {F0[0] → λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F4 Y0 Y1))[0]}
       :yields forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
               [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0 ∨ 
                ¬(λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))
                   (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0*]/42)
0.127[zip.env] apply unary rule neg_ext
0.127[zip.env] apply unary rule ho_ext_pos
0.127[zip.env] apply unary rule ho_complete_eq
0.127[zip.env] apply unary rule avatar_check_empty
0.127[zip.env]
    lambda rewritten clause `forall X0 A1 (F2:ι → ι → A1) 
                                    (F3:ι → ι → A1).
                             [sk_A
                               (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) 
                               X0 ∨ 
                              ¬(λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))
                                 (sk_X-84
                                   (λ (Y0:ι) (Y1:ι).
                                     ((F3 Y0 Y1 = F2 Y0 Y1)))) 
                                 X0*]/42`
    into `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
          [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
           ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
               F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`
0.128[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.128[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.128[zip.env] apply generating rule avatar.lemmas (full: false)
0.128[zip.env] apply generating rule avatar_check_sat (full: false)
0.128[zip.avatar] SAT-solver reports "SAT"
0.128[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.128[zip.sup] @[neg_reflect did not simplify the clause @]
0.128[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39`...
0.129[zip.sup] @[neg_reflect did not simplify the clause @]
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39`...
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38`...
0.129[zip.sup] @[neg_reflect did not simplify the clause @]
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38`...
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41`...
0.129[zip.sup] @[neg_reflect did not simplify the clause @]
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41`...
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40`...
0.129[zip.sup] @[neg_reflect did not simplify the clause @]
0.129[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40`...
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35`...
0.130[zip.sup] @[neg_reflect did not simplify the clause @]
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35`...
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.130[zip.sup] @[neg_reflect did not simplify the clause @]
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37`...
0.130[zip.sup] @[neg_reflect did not simplify the clause @]
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37`...
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36`...
0.130[zip.sup] @[neg_reflect did not simplify the clause @]
0.130[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36`...
0.130[zip.saturate]
    inferred new clauses:
      [forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43, 
       forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39, 
       forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40, 
       forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35, 
       forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36]
[K[0.13s]  11 steps0.131[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.132[zip.sup] @[neg_reflect did not simplify the clause @]
0.132[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.132[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.132[zip.saturate] ### step    11 ###
0.132[zip.saturate]
    given (11 steps, penalty 1):
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`
0.132[zip.env]
    do binary inferences with current active set:
      `{forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13,
        forall (F0:ι → ι → prop) X1.
        [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14,
        forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34}`
0.132[zip.env] apply binary rule superposition_active
0.133[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.133[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44.

0.133[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1]
         passive_lit=¬F0 (sk_X-84 F0) X1 p=1.→.ε)
      with subst={}.

0.133[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45.

0.133[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[1]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.133[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46.

0.133[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[1]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.134[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47.

0.137[zip.sup] ... cancel, will yield a tautology
0.141[zip.sup] ... cancel, will yield a tautology
0.145[zip.env] apply binary rule superposition_passive
0.147[zip.sup] ... cancel, will yield a tautology
0.150[zip.sup] ... cancel, will yield a tautology
0.155[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.155[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48.

0.155[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop) X1.
       [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14[1] s=false
         t=F0 (sk_X-84 F0) X1, t'=F0 (sk_X-84 F0) X1)
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.155[zip.sup]
    Res: forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49.

0.155[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[1]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.156[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50.

0.156[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[1]
         s=false
         t=F0 (sk_X-84 F0) (sk_X-84 F0), t'=F0 (sk_X-84 F0) (sk_X-84 F0))
      (forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34[0]
         passive_lit=¬F0 (sk_X-84 F0) (sk_X-84 F0) p=0.→.ε)
      with subst={}.

0.156[zip.sup]
    Res: forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51.

0.156[zip.env] apply binary rule ctx_narrow
0.156[zip.env] apply binary rule narrow_term_defs
0.156[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34`...
0.156[zip.env] do unary inferences
0.156[zip.env] apply unary rule equality_resolution
0.156[zip.env] apply unary rule equality_factoring
0.156[zip.env] apply unary rule narrow_lit_defs
0.156[zip.env] apply unary rule ind_types.exhaustiveness
0.156[zip.env] apply unary rule ind_types.acyclicity
0.156[zip.env] apply unary rule ho_prim_enum
0.156[zip.ho]
    (ho.refine
       :clause forall (F0:ι → ι → prop).
               [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
       :terms {F0})
0.156[zip.ho]
    (ho.refine
       :from forall (F0:ι → ι → prop).
             [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
       :subst {F0[0] → λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F3 Y0 Y1))[0]}
       :yields forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
               [¬(λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))
                   (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                   (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1))))*]/52)
0.156[zip.env] apply unary rule neg_ext
0.156[zip.env] apply unary rule ho_ext_pos
0.156[zip.env] apply unary rule ho_complete_eq
0.156[zip.env] apply unary rule avatar_check_empty
0.156[zip.env]
    lambda rewritten clause `forall A0 (F1:ι → ι → A0) 
                                    (F2:ι → ι → A0).
                             [¬(λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))
                                 (sk_X-84
                                   (λ (Y0:ι) (Y1:ι).
                                     ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                                 (sk_X-84
                                   (λ (Y0:ι) (Y1:ι).
                                     ((F2 Y0 Y1 = F1 Y0 Y1))))*]/52`
    into `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
          [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
               (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
               F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`
0.157[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.157[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.157[zip.env] apply generating rule avatar.lemmas (full: false)
0.157[zip.env] apply generating rule avatar_check_sat (full: false)
0.157[zip.avatar] SAT-solver reports "SAT"
0.157[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.158[zip.sup] @[neg_reflect did not simplify the clause @]
0.158[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.158[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49`...
0.158[zip.sup] @[neg_reflect did not simplify the clause @]
0.158[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49`...
0.158[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48`...
0.159[zip.sup] @[neg_reflect did not simplify the clause @]
0.159[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48`...
0.159[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51`...
0.159[zip.sup] @[neg_reflect did not simplify the clause @]
0.159[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51`...
0.159[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50`...
0.160[zip.sup] @[neg_reflect did not simplify the clause @]
0.160[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50`...
0.160[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45`...
0.160[zip.sup] @[neg_reflect did not simplify the clause @]
0.160[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45`...
0.160[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44`...
0.161[zip.sup] @[neg_reflect did not simplify the clause @]
0.161[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44`...
0.161[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47`...
0.161[zip.sup] @[neg_reflect did not simplify the clause @]
0.161[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47`...
0.161[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46`...
0.161[zip.sup] @[neg_reflect did not simplify the clause @]
0.161[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46`...
0.161[zip.saturate]
    inferred new clauses:
      [forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49, 
       forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47, 
       forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46]
[K[0.16s]  12 steps0.162[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35`...
0.162[zip.sup] @[neg_reflect did not simplify the clause @]
0.162[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35`...
0.162[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-184[0] → F0[0], F0[1] → F-184[0]}
0.162[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35
      subsumed by active set
0.162[zip.saturate]
    given clause forall (F0:ι → ι → prop).
                 [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/35
      is redundant
[K[0.16s]  13 steps0.162[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38`...
0.163[zip.sup] @[neg_reflect did not simplify the clause @]
0.163[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38`...
0.163[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-189[0] → F0[0], F0[1] → F-189[0]}
0.163[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38
      subsumed by active set
0.163[zip.saturate]
    given clause forall (F0:ι → ι → prop).
                 [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/38
      is redundant
[K[0.16s]  14 steps0.163[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39`...
0.163[zip.sup] @[neg_reflect did not simplify the clause @]
0.163[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39`...
0.163[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-194[0] → F0[0], F0[1] → F-194[0]}
0.163[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39
      subsumed by active set
0.163[zip.saturate]
    given clause forall (F0:ι → ι → prop).
                 [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/39
      is redundant
[K[0.16s]  15 steps0.163[zip.env]
    rewrite clause
      `[miff
         = λ (Y0:ι → prop) (Y1:ι → prop).
            (mand (mimpl Y0 Y1) (mimpl Y1 Y0))*]/10`...
0.163[rewrite]
    rewrite `miff`
      using `miff :=
               λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))`
0.164[rewrite]
     simpl rewrite `miff`
      :into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
              (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))`
      :using {(miff :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
               :with {}[1])}
0.164[zip.env]
    rewrite `miff`
      into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
             (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))`
      :proof ((miff :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2))) [T]))
0.164[rewrite]
    (rewrite `mimpl Y-1 Y-2`
       :using `mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1] :rest [Y-1,Y-2])
0.164[rewrite]
    (rewrite `mimpl Y-2 Y-1`
       :using `mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))`
       :with `{}`[1] :rest [Y-2,Y-1])
0.164[rewrite]
    (rewrite `mand
               ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)))
                 Y-2 Y-1) 
               ((λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)))
                 Y-1 Y-2)`
       :using `mand :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∧ Y1 Y2))`
       :with `{}`[1]
       :rest [(λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2)))
               Y-2 Y-1,
              (λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                ((¬ Y0 Y2 ∨ Y1 Y2)))
               Y-1 Y-2])
0.164[rewrite]
     simpl rewrite `λ (Y0:ι → prop) (Y1:ι → prop).
                     (mand (mimpl Y0 Y1) (mimpl Y1 Y0))`
      :into `λ (Y0:ι → prop) (Y1:ι → prop).
              ((λ (Y2:ι → prop) (Y3:ι → prop) (Y4:ι).
                 ((Y2 Y4 ∧ Y3 Y4)))
                ((λ (Y2:ι → prop) (Y3:ι → prop) (Y4:ι).
                   ((¬ Y2 Y4 ∨ Y3 Y4)))
                  Y0 Y1) 
                ((λ (Y2:ι → prop) (Y3:ι → prop) (Y4:ι).
                   ((¬ Y2 Y4 ∨ Y3 Y4)))
                  Y1 Y0))`
      :using {(mand :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∧ Y1 Y2))
               :with {}[1]), 
              (mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2))
               :with {}[1])}
0.165[zip.env]
    rewrite `λ (Y0:ι → prop) (Y1:ι → prop).
              (mand (mimpl Y0 Y1) (mimpl Y1 Y0))`
      into `λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
             (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))`
      :proof ((mimpl :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((¬ Y0 Y2 ∨ Y1 Y2)) [T]), 
              (mand :=
                 λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                  ((Y0 Y2 ∧ Y1 Y2)) [T]))
0.165[zip.env]
    term rewritten clause `[miff
                             = λ (Y0:ι → prop) (Y1:ι → prop).
                                (mand (mimpl Y0 Y1) (mimpl Y1 Y0))*]/10`
    into `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
            = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
               (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54`
0.165[zip.sup] @[neg_reflect did not simplify the clause @]
0.165[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
         (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54`...
0.165[zip.env]
    clause `[miff
              = λ (Y0:ι → prop) (Y1:ι → prop).
                 (mand (mimpl Y0 Y1) (mimpl Y1 Y0))*]/10`
    simplified into `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                       (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
                       = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
                          (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54`
0.166[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
         (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54`...
0.166[zip.sup] @[neg_reflect did not simplify the clause @]
0.166[zip.env]
    rewrite clause
      `[λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
         (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
         = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
            (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54`...
0.166[zip.sup]
    [λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
      (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))
      = λ (Y0:ι → prop) (Y1:ι → prop) (Y2:ι).
         (((¬ Y0 Y2 ∨ Y1 Y2) ∧ (¬ Y1 Y2 ∨ Y0 Y2)))*]/54
    is a tautology
0.166[zip.saturate]
    given clause [miff
                   = λ (Y0:ι → prop) (Y1:ι → prop).
                      (mand (mimpl Y0 Y1) (mimpl Y1 Y0))*]/10
      is redundant
[K[0.17s]  16 steps0.166[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46`...
0.166[zip.sup] @[neg_reflect did not simplify the clause @]
0.166[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46`...
0.167[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46`...
0.167[cnf]
    flatten_rec
      `((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
        (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
      vars: (X0/376, X1/375)
0.167[cnf]
    flatten `assert
               ∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
                 (((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
                   (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))).`
      into `assert
              ∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
                ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
                 (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))).`
0.167[cnf]
    simplify and rename
      `∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
         ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
          (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
0.167[cnf]
    reduce
      `∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
         ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
          (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
      to CNF
0.167[cnf]
    nnf of
      `∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
         ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
          (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
0.167[cnf]
    nnf of
      `∀ X1/375:(ι → ι → prop).
         ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
          (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
0.167[cnf]
    nnf of
      `(X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ≡
       (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))`
0.167[cnf]
    nnf of
      `((X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)) ⇒
        (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)))
       ∧ ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ⇒
            (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
0.167[cnf]
    nnf of
      `(X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)) ⇒
       (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))`
0.167[cnf]
    nnf of
      `(X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))
       ∨ (¬ (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))`
0.167[cnf] nnf of `X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)`
0.167[cnf] nnf of `¬ (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))`
0.167[cnf]
    nnf of
      `(X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)) ⇒
       (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))`
0.167[cnf]
    nnf of
      `(X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))
       ∨ (¬ (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)))`
0.167[cnf] nnf of `X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)`
0.167[cnf] nnf of `¬ (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))`
0.168[cnf]
    ... NNF:
      `∀ X0/376:(ι → ι → prop) X1/375:(ι → ι → prop).
         (((¬ (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375)))
           ∨ (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))
          ∧ ((¬ (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))
               ∨ (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))))`
0.168[cnf]
    ... miniscoped:
      `∀ X0/376:(ι → ι → prop).
         ((∀ X1/375:(ι → ι → prop).
             ((X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))
              ∨ (¬ (X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376)))))
          ∧ (∀ X1/375:(ι → ι → prop).
                 ((X0/376 (sk_X-84 X0/376) (sk_X-84 X0/376))
                  ∨ (¬ (X1/375 (sk_X-84 X1/375) (sk_X-84 X1/375))))))`
0.168[cnf] rename `X0/376` to `X0/377` :subst {}
0.168[cnf] rename `X1/375` to `X1/378` :subst {X0/376 → X0/377}
0.168[cnf] rename `X1/375` to `X1/379` :subst {X0/376 → X0/377}
0.168[cnf]
    ... skolemized:
      `((¬ (X1/379 (sk_X-84 X1/379) (sk_X-84 X1/379)))
        ∨ (X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377)))
       ∧ ((¬ (X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377)))
            ∨ (X1/378 (sk_X-84 X1/378) (sk_X-84 X1/378)))`
0.168[cnf]
    ... CNF:
      `X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377) ∨ 
         ¬ X1/379 (sk_X-84 X1/379) (sk_X-84 X1/379), 
       X1/378 (sk_X-84 X1/378) (sk_X-84 X1/378) ∨ 
         ¬ X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377)`
0.168[cnf]
    convert
      `assert
         X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377) ∨ 
         ¬ X1/379 (sk_X-84 X1/379) (sk_X-84 X1/379).`
0.168[cnf]
    convert
      `assert
         X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377) ∨ 
         ¬ X1/379 (sk_X-84 X1/379) (sk_X-84 X1/379).`
    into `assert
            F0 (sk_X-84 F0) (sk_X-84 F0) ∨ ¬ F1 (sk_X-84 F1) (sk_X-84 F1).`
0.168[cnf]
    convert
      `assert
         X1/378 (sk_X-84 X1/378) (sk_X-84 X1/378) ∨ 
         ¬ X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377).`
0.168[cnf]
    convert
      `assert
         X1/378 (sk_X-84 X1/378) (sk_X-84 X1/378) ∨ 
         ¬ X0/377 (sk_X-84 X0/377) (sk_X-84 X0/377).`
    into `assert
            F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬ F0 (sk_X-84 F0) (sk_X-84 F0).`
0.168[zip.env] trigger on_input_statement
0.168[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop).
      [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55 
      forall (F0:ι → ι → prop) (F2:ι → ι → prop).
      [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56
    sos: 
0.169[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55`...
0.169[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56`...
0.169[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55`...
0.169[zip.sup] @[neg_reflect did not simplify the clause @]
0.169[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55`...
0.169[unif] protected with set *
0.169[unif] protected with set *
0.170[unif] protected with set *
0.170[unif] protected with set *
0.170[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)]
      :subst {F-207[0] → F0[0], F0[1] → F-207[0]}
0.170[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/57
0.170[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
            [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/55`
    simplified into `forall (F1:ι → ι → prop).
                     [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/57`
0.171[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/57`...
0.171[zip.sup] @[neg_reflect did not simplify the clause @]
0.171[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/57`...
0.171[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F1 (sk_X-84 F1) (sk_X-84 F1)
      :subst {F-212[0] → F1[0], F0[1] → F-212[0]}
0.171[zip.sup]
    forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/57
      subsumed by active set
0.171[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56`...
0.172[zip.sup] @[neg_reflect did not simplify the clause @]
0.172[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56`...
0.172[unif] protected with set *
0.172[unif] protected with set *
0.172[unif] protected with set *
0.172[unif] protected with set *
0.172[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-221[0] → F2[0], F0[1] → F-221[0]}
0.172[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/58
0.172[zip.env]
    clause `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
            [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/56`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/58`
0.173[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/58`...
0.173[zip.sup] @[neg_reflect did not simplify the clause @]
0.173[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/58`...
0.173[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-226[0] → F0[0], F0[1] → F-226[0]}
0.173[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/58
      subsumed by active set
0.173[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop).
                 [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/46
      is redundant
[K[0.17s]  17 steps0.173[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47`...
0.174[zip.sup] @[neg_reflect did not simplify the clause @]
0.174[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47`...
0.174[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47`...
0.174[cnf]
    flatten_rec
      `((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
        (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
      vars: (X0/437, X1/436)
0.174[cnf]
    flatten `assert
               ∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
                 (((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
                   (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))).`
      into `assert
              ∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
                ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
                 (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))).`
0.174[cnf]
    simplify and rename
      `∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
         ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
          (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
0.174[cnf]
    reduce
      `∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
         ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
          (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
      to CNF
0.174[cnf]
    nnf of
      `∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
         ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
          (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
0.174[cnf]
    nnf of
      `∀ X1/436:(ι → ι → prop).
         ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
          (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
0.174[cnf]
    nnf of
      `(X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ≡
       (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))`
0.174[cnf]
    nnf of
      `((X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)) ⇒
        (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)))
       ∧ ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ⇒
            (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
0.174[cnf]
    nnf of
      `(X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)) ⇒
       (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))`
0.174[cnf]
    nnf of
      `(X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))
       ∨ (¬ (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))`
0.174[cnf] nnf of `X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)`
0.174[cnf] nnf of `¬ (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))`
0.174[cnf]
    nnf of
      `(X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)) ⇒
       (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))`
0.174[cnf]
    nnf of
      `(X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))
       ∨ (¬ (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)))`
0.174[cnf] nnf of `X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)`
0.174[cnf] nnf of `¬ (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))`
0.174[cnf]
    ... NNF:
      `∀ X0/437:(ι → ι → prop) X1/436:(ι → ι → prop).
         (((¬ (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436)))
           ∨ (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))
          ∧ ((¬ (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))
               ∨ (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))))`
0.175[cnf]
    ... miniscoped:
      `∀ X0/437:(ι → ι → prop).
         ((∀ X1/436:(ι → ι → prop).
             ((X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))
              ∨ (¬ (X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437)))))
          ∧ (∀ X1/436:(ι → ι → prop).
                 ((X0/437 (sk_X-84 X0/437) (sk_X-84 X0/437))
                  ∨ (¬ (X1/436 (sk_X-84 X1/436) (sk_X-84 X1/436))))))`
0.175[cnf] rename `X0/437` to `X0/438` :subst {}
0.175[cnf] rename `X1/436` to `X1/439` :subst {X0/437 → X0/438}
0.175[cnf] rename `X1/436` to `X1/440` :subst {X0/437 → X0/438}
0.175[cnf]
    ... skolemized:
      `((¬ (X1/440 (sk_X-84 X1/440) (sk_X-84 X1/440)))
        ∨ (X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438)))
       ∧ ((¬ (X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438)))
            ∨ (X1/439 (sk_X-84 X1/439) (sk_X-84 X1/439)))`
0.175[cnf]
    ... CNF:
      `X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438) ∨ 
         ¬ X1/440 (sk_X-84 X1/440) (sk_X-84 X1/440), 
       X1/439 (sk_X-84 X1/439) (sk_X-84 X1/439) ∨ 
         ¬ X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438)`
0.175[cnf]
    convert
      `assert
         X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438) ∨ 
         ¬ X1/440 (sk_X-84 X1/440) (sk_X-84 X1/440).`
0.175[cnf]
    convert
      `assert
         X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438) ∨ 
         ¬ X1/440 (sk_X-84 X1/440) (sk_X-84 X1/440).`
    into `assert
            F0 (sk_X-84 F0) (sk_X-84 F0) ∨ ¬ F1 (sk_X-84 F1) (sk_X-84 F1).`
0.175[cnf]
    convert
      `assert
         X1/439 (sk_X-84 X1/439) (sk_X-84 X1/439) ∨ 
         ¬ X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438).`
0.175[cnf]
    convert
      `assert
         X1/439 (sk_X-84 X1/439) (sk_X-84 X1/439) ∨ 
         ¬ X0/438 (sk_X-84 X0/438) (sk_X-84 X0/438).`
    into `assert
            F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬ F0 (sk_X-84 F0) (sk_X-84 F0).`
0.175[zip.env] trigger on_input_statement
0.175[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop).
      [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59 
      forall (F0:ι → ι → prop) (F2:ι → ι → prop).
      [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60
    sos: 
0.175[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59`...
0.175[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60`...
0.176[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59`...
0.176[zip.sup] @[neg_reflect did not simplify the clause @]
0.176[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59`...
0.176[unif] protected with set *
0.176[unif] protected with set *
0.176[unif] protected with set *
0.176[unif] protected with set *
0.176[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)]
      :subst {F-239[0] → F0[0], F0[1] → F-239[0]}
0.176[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/61
0.176[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
            [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/59`
    simplified into `forall (F1:ι → ι → prop).
                     [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/61`
0.176[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/61`...
0.176[zip.sup] @[neg_reflect did not simplify the clause @]
0.176[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/61`...
0.177[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F1 (sk_X-84 F1) (sk_X-84 F1)
      :subst {F-244[0] → F1[0], F0[1] → F-244[0]}
0.177[zip.sup]
    forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/61
      subsumed by active set
0.177[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60`...
0.177[zip.sup] @[neg_reflect did not simplify the clause @]
0.177[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60`...
0.177[unif] protected with set *
0.177[unif] protected with set *
0.177[unif] protected with set *
0.177[unif] protected with set *
0.177[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-253[0] → F2[0], F0[1] → F-253[0]}
0.177[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/62
0.177[zip.env]
    clause `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
            [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/60`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/62`
0.177[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/62`...
0.177[zip.sup] @[neg_reflect did not simplify the clause @]
0.177[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/62`...
0.177[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-258[0] → F0[0], F0[1] → F-258[0]}
0.177[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/62
      subsumed by active set
0.177[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop).
                 [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/47
      is redundant
[K[0.18s]  18 steps0.178[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50`...
0.178[zip.sup] @[neg_reflect did not simplify the clause @]
0.178[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50`...
0.178[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50`...
0.178[cnf]
    flatten_rec
      `((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
        (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
      vars: (X0/498, X1/497)
0.178[cnf]
    flatten `assert
               ∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
                 (((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
                   (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))).`
      into `assert
              ∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
                ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
                 (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))).`
0.178[cnf]
    simplify and rename
      `∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
         ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
          (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
0.178[cnf]
    reduce
      `∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
         ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
          (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
      to CNF
0.178[cnf]
    nnf of
      `∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
         ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
          (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
0.178[cnf]
    nnf of
      `∀ X1/497:(ι → ι → prop).
         ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
          (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
0.178[cnf]
    nnf of
      `(X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ≡
       (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))`
0.179[cnf]
    nnf of
      `((X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)) ⇒
        (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)))
       ∧ ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ⇒
            (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
0.179[cnf]
    nnf of
      `(X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)) ⇒
       (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))`
0.179[cnf]
    nnf of
      `(X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))
       ∨ (¬ (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))`
0.179[cnf] nnf of `X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)`
0.179[cnf] nnf of `¬ (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))`
0.179[cnf]
    nnf of
      `(X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)) ⇒
       (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))`
0.179[cnf]
    nnf of
      `(X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))
       ∨ (¬ (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)))`
0.179[cnf] nnf of `X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)`
0.179[cnf] nnf of `¬ (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))`
0.179[cnf]
    ... NNF:
      `∀ X0/498:(ι → ι → prop) X1/497:(ι → ι → prop).
         (((¬ (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497)))
           ∨ (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))
          ∧ ((¬ (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))
               ∨ (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))))`
0.179[cnf]
    ... miniscoped:
      `∀ X0/498:(ι → ι → prop).
         ((∀ X1/497:(ι → ι → prop).
             ((X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))
              ∨ (¬ (X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498)))))
          ∧ (∀ X1/497:(ι → ι → prop).
                 ((X0/498 (sk_X-84 X0/498) (sk_X-84 X0/498))
                  ∨ (¬ (X1/497 (sk_X-84 X1/497) (sk_X-84 X1/497))))))`
0.179[cnf] rename `X0/498` to `X0/499` :subst {}
0.179[cnf] rename `X1/497` to `X1/500` :subst {X0/498 → X0/499}
0.179[cnf] rename `X1/497` to `X1/501` :subst {X0/498 → X0/499}
0.179[cnf]
    ... skolemized:
      `((¬ (X1/501 (sk_X-84 X1/501) (sk_X-84 X1/501)))
        ∨ (X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499)))
       ∧ ((¬ (X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499)))
            ∨ (X1/500 (sk_X-84 X1/500) (sk_X-84 X1/500)))`
0.179[cnf]
    ... CNF:
      `X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499) ∨ 
         ¬ X1/501 (sk_X-84 X1/501) (sk_X-84 X1/501), 
       X1/500 (sk_X-84 X1/500) (sk_X-84 X1/500) ∨ 
         ¬ X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499)`
0.179[cnf]
    convert
      `assert
         X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499) ∨ 
         ¬ X1/501 (sk_X-84 X1/501) (sk_X-84 X1/501).`
0.179[cnf]
    convert
      `assert
         X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499) ∨ 
         ¬ X1/501 (sk_X-84 X1/501) (sk_X-84 X1/501).`
    into `assert
            F0 (sk_X-84 F0) (sk_X-84 F0) ∨ ¬ F1 (sk_X-84 F1) (sk_X-84 F1).`
0.179[cnf]
    convert
      `assert
         X1/500 (sk_X-84 X1/500) (sk_X-84 X1/500) ∨ 
         ¬ X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499).`
0.180[cnf]
    convert
      `assert
         X1/500 (sk_X-84 X1/500) (sk_X-84 X1/500) ∨ 
         ¬ X0/499 (sk_X-84 X0/499) (sk_X-84 X0/499).`
    into `assert
            F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬ F0 (sk_X-84 F0) (sk_X-84 F0).`
0.180[zip.env] trigger on_input_statement
0.180[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop).
      [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63 
      forall (F0:ι → ι → prop) (F2:ι → ι → prop).
      [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64
    sos: 
0.180[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63`...
0.180[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64`...
0.180[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63`...
0.180[zip.sup] @[neg_reflect did not simplify the clause @]
0.180[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63`...
0.181[unif] protected with set *
0.181[unif] protected with set *
0.181[unif] protected with set *
0.181[unif] protected with set *
0.181[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)]
      :subst {F-271[0] → F0[0], F0[1] → F-271[0]}
0.181[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/65
0.181[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
            [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/63`
    simplified into `forall (F1:ι → ι → prop).
                     [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/65`
0.182[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/65`...
0.182[zip.sup] @[neg_reflect did not simplify the clause @]
0.182[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/65`...
0.182[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F1 (sk_X-84 F1) (sk_X-84 F1)
      :subst {F-276[0] → F1[0], F0[1] → F-276[0]}
0.182[zip.sup]
    forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/65
      subsumed by active set
0.182[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64`...
0.182[zip.sup] @[neg_reflect did not simplify the clause @]
0.182[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64`...
0.183[unif] protected with set *
0.183[unif] protected with set *
0.183[unif] protected with set *
0.183[unif] protected with set *
0.183[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-285[0] → F2[0], F0[1] → F-285[0]}
0.183[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/66
0.183[zip.env]
    clause `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
            [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/64`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/66`
0.183[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/66`...
0.183[zip.sup] @[neg_reflect did not simplify the clause @]
0.183[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/66`...
0.183[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-290[0] → F0[0], F0[1] → F-290[0]}
0.184[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/66
      subsumed by active set
0.184[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop).
                 [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/50
      is redundant
[K[0.18s]  19 steps0.184[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51`...
0.184[zip.sup] @[neg_reflect did not simplify the clause @]
0.184[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51`...
0.184[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51`...
0.184[cnf]
    flatten_rec
      `((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
        (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
      vars: (X0/559, X1/558)
0.184[cnf]
    flatten `assert
               ∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
                 (((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
                   (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))).`
      into `assert
              ∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
                ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
                 (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))).`
0.184[cnf]
    simplify and rename
      `∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
         ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
          (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
0.184[cnf]
    reduce
      `∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
         ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
          (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
      to CNF
0.184[cnf]
    nnf of
      `∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
         ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
          (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
0.184[cnf]
    nnf of
      `∀ X1/558:(ι → ι → prop).
         ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
          (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
0.184[cnf]
    nnf of
      `(X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ≡
       (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))`
0.185[cnf]
    nnf of
      `((X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)) ⇒
        (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)))
       ∧ ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ⇒
            (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
0.185[cnf]
    nnf of
      `(X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)) ⇒
       (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))`
0.185[cnf]
    nnf of
      `(X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))
       ∨ (¬ (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))`
0.185[cnf] nnf of `X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)`
0.185[cnf] nnf of `¬ (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))`
0.185[cnf]
    nnf of
      `(X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)) ⇒
       (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))`
0.185[cnf]
    nnf of
      `(X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))
       ∨ (¬ (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)))`
0.185[cnf] nnf of `X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)`
0.185[cnf] nnf of `¬ (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))`
0.185[cnf]
    ... NNF:
      `∀ X0/559:(ι → ι → prop) X1/558:(ι → ι → prop).
         (((¬ (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558)))
           ∨ (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))
          ∧ ((¬ (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))
               ∨ (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))))`
0.185[cnf]
    ... miniscoped:
      `∀ X0/559:(ι → ι → prop).
         ((∀ X1/558:(ι → ι → prop).
             ((X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))
              ∨ (¬ (X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559)))))
          ∧ (∀ X1/558:(ι → ι → prop).
                 ((X0/559 (sk_X-84 X0/559) (sk_X-84 X0/559))
                  ∨ (¬ (X1/558 (sk_X-84 X1/558) (sk_X-84 X1/558))))))`
0.185[cnf] rename `X0/559` to `X0/560` :subst {}
0.185[cnf] rename `X1/558` to `X1/561` :subst {X0/559 → X0/560}
0.185[cnf] rename `X1/558` to `X1/562` :subst {X0/559 → X0/560}
0.185[cnf]
    ... skolemized:
      `((¬ (X1/562 (sk_X-84 X1/562) (sk_X-84 X1/562)))
        ∨ (X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560)))
       ∧ ((¬ (X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560)))
            ∨ (X1/561 (sk_X-84 X1/561) (sk_X-84 X1/561)))`
0.185[cnf]
    ... CNF:
      `X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560) ∨ 
         ¬ X1/562 (sk_X-84 X1/562) (sk_X-84 X1/562), 
       X1/561 (sk_X-84 X1/561) (sk_X-84 X1/561) ∨ 
         ¬ X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560)`
0.185[cnf]
    convert
      `assert
         X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560) ∨ 
         ¬ X1/562 (sk_X-84 X1/562) (sk_X-84 X1/562).`
0.185[cnf]
    convert
      `assert
         X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560) ∨ 
         ¬ X1/562 (sk_X-84 X1/562) (sk_X-84 X1/562).`
    into `assert
            F0 (sk_X-84 F0) (sk_X-84 F0) ∨ ¬ F1 (sk_X-84 F1) (sk_X-84 F1).`
0.185[cnf]
    convert
      `assert
         X1/561 (sk_X-84 X1/561) (sk_X-84 X1/561) ∨ 
         ¬ X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560).`
0.186[cnf]
    convert
      `assert
         X1/561 (sk_X-84 X1/561) (sk_X-84 X1/561) ∨ 
         ¬ X0/560 (sk_X-84 X0/560) (sk_X-84 X0/560).`
    into `assert
            F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬ F0 (sk_X-84 F0) (sk_X-84 F0).`
0.186[zip.env] trigger on_input_statement
0.186[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop).
      [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67 
      forall (F0:ι → ι → prop) (F2:ι → ι → prop).
      [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68
    sos: 
0.186[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67`...
0.186[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68`...
0.186[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67`...
0.186[zip.sup] @[neg_reflect did not simplify the clause @]
0.186[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
       [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67`...
0.187[unif] protected with set *
0.187[unif] protected with set *
0.187[unif] protected with set *
0.187[unif] protected with set *
0.187[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)]
      :subst {F-303[0] → F0[0], F0[1] → F-303[0]}
0.187[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop).
         [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/69
0.187[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop).
            [F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             ¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/67`
    simplified into `forall (F1:ι → ι → prop).
                     [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/69`
0.187[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/69`...
0.188[zip.sup] @[neg_reflect did not simplify the clause @]
0.188[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/69`...
0.188[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F1 (sk_X-84 F1) (sk_X-84 F1)
      :subst {F-308[0] → F1[0], F0[1] → F-308[0]}
0.188[zip.sup]
    forall (F1:ι → ι → prop). [¬F1 (sk_X-84 F1) (sk_X-84 F1)*]/69
      subsumed by active set
0.188[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68`...
0.189[zip.sup] @[neg_reflect did not simplify the clause @]
0.189[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68`...
0.189[unif] protected with set *
0.189[unif] protected with set *
0.189[unif] protected with set *
0.189[unif] protected with set *
0.189[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-317[0] → F2[0], F0[1] → F-317[0]}
0.189[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F2:ι → ι → prop).
         [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/70
0.190[zip.env]
    clause `forall (F0:ι → ι → prop) (F2:ι → ι → prop).
            [F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/68`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/70`
0.190[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/70`...
0.190[zip.sup] @[neg_reflect did not simplify the clause @]
0.190[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/70`...
0.191[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-322[0] → F0[0], F0[1] → F-322[0]}
0.191[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/70
      subsumed by active set
0.191[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop).
                 [F1 (sk_X-84 F1) (sk_X-84 F1) = F0 (sk_X-84 F0) (sk_X-84 F0)*]/51
      is redundant
[K[0.19s]  20 steps0.191[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44`...
0.191[zip.sup] @[neg_reflect did not simplify the clause @]
0.191[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44`...
0.191[unif] protected with set *
0.191[unif] protected with set *
0.191[unif] protected with set *
0.191[unif] protected with set *
0.191[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/44`...
0.192[cnf]
    flatten_rec
      `((X1/619 (sk_X-84 X1/619) X2/620) ≡
        (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
       ∨ (sk_A X1/619 X2/620)`
      vars: (X0/621, X1/619, X2/620)
0.192[cnf]
    flatten `assert
               ∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) 
                 X2/620.
                 (((X1/619 (sk_X-84 X1/619) X2/620) ≡
                   (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
                  ∨ (sk_A X1/619 X2/620)).`
      into `assert
              ∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) 
                X2/620.
                ((sk_A X1/619 X2/620)
                 ∨ ((X1/619 (sk_X-84 X1/619) X2/620) ≡
                      (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))).`
0.192[cnf]
    simplify and rename
      `∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) X2/620.
         ((sk_A X1/619 X2/620)
          ∨ ((X1/619 (sk_X-84 X1/619) X2/620) ≡
               (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))))`
0.192[cnf]
    reduce
      `∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) X2/620.
         (((X1/619 (sk_X-84 X1/619) X2/620) ≡
           (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
          ∨ (sk_A X1/619 X2/620))`
      to CNF
0.192[cnf]
    nnf of
      `∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) X2/620.
         (((X1/619 (sk_X-84 X1/619) X2/620) ≡
           (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
          ∨ (sk_A X1/619 X2/620))`
0.192[cnf]
    nnf of
      `∀ X1/619:(ι → ι → prop) X2/620.
         (((X1/619 (sk_X-84 X1/619) X2/620) ≡
           (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
          ∨ (sk_A X1/619 X2/620))`
0.192[cnf]
    nnf of
      `∀ X2/620.
         (((X1/619 (sk_X-84 X1/619) X2/620) ≡
           (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
          ∨ (sk_A X1/619 X2/620))`
0.192[cnf]
    nnf of
      `((X1/619 (sk_X-84 X1/619) X2/620) ≡
        (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
       ∨ (sk_A X1/619 X2/620)`
0.192[cnf]
    nnf of
      `(X1/619 (sk_X-84 X1/619) X2/620) ≡
       (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))`
0.192[cnf]
    nnf of
      `((X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)) ⇒
        (X1/619 (sk_X-84 X1/619) X2/620))
       ∧ ((X1/619 (sk_X-84 X1/619) X2/620) ⇒
            (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))`
0.192[cnf]
    nnf of
      `(X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)) ⇒
       (X1/619 (sk_X-84 X1/619) X2/620)`
0.192[cnf]
    nnf of
      `(X1/619 (sk_X-84 X1/619) X2/620)
       ∨ (¬ (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))`
0.192[cnf] nnf of `X1/619 (sk_X-84 X1/619) X2/620`
0.192[cnf] nnf of `¬ (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))`
0.192[cnf]
    nnf of
      `(X1/619 (sk_X-84 X1/619) X2/620) ⇒
       (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))`
0.192[cnf]
    nnf of
      `(X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))
       ∨ (¬ (X1/619 (sk_X-84 X1/619) X2/620))`
0.192[cnf] nnf of `X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)`
0.192[cnf] nnf of `¬ (X1/619 (sk_X-84 X1/619) X2/620)`
0.192[cnf] nnf of `sk_A X1/619 X2/620`
0.192[cnf]
    ... NNF:
      `∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) X2/620.
         ((sk_A X1/619 X2/620)
          ∨ (((¬ (X1/619 (sk_X-84 X1/619) X2/620))
                ∨ (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
               ∧ ((¬ (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621)))
                    ∨ (X1/619 (sk_X-84 X1/619) X2/620))))`
0.193[cnf]
    ... miniscoped:
      `∀ X0/621:(ι → ι → prop) X1/619:(ι → ι → prop) X2/620.
         ((((X1/619 (sk_X-84 X1/619) X2/620)
            ∨ (¬ (X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))))
           ∧ ((X0/621 (sk_X-84 X0/621) (sk_X-84 X0/621))
                ∨ (¬ (X1/619 (sk_X-84 X1/619) X2/620))))
          ∨ (sk_A X1/619 X2/620))`
0.193[cnf] rename `X0/621` to `X0/622` :subst {}
0.193[cnf] rename `X1/619` to `X1/623` :subst {X0/621 → X0/622}
0.193[cnf]
    rename `X2/620` to `X2/624` :subst {X1/619 → X1/623, X0/621 → X0/622}
0.193[cnf]
    ... skolemized:
      `(sk_A X1/623 X2/624)
       ∨ (((¬ (X1/623 (sk_X-84 X1/623) X2/624))
             ∨ (X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622)))
            ∧ ((¬ (X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622)))
                 ∨ (X1/623 (sk_X-84 X1/623) X2/624)))`
0.193[cnf]
    ... CNF:
      `¬ X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ 
         X1/623 (sk_X-84 X1/623) X2/624 ∨ sk_A X1/623 X2/624, 
       ¬ X1/623 (sk_X-84 X1/623) X2/624 ∨ 
         X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ sk_A X1/623 X2/624`
0.193[cnf]
    convert
      `assert
         ¬ X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ 
         X1/623 (sk_X-84 X1/623) X2/624 ∨ 
         sk_A X1/623 X2/624.`
0.193[cnf]
    convert
      `assert
         ¬ X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ 
         X1/623 (sk_X-84 X1/623) X2/624 ∨ 
         sk_A X1/623 X2/624.`
    into `assert
            ¬ F0 (sk_X-84 F0) (sk_X-84 F0) ∨ F1 (sk_X-84 F1) X2 ∨ 
            sk_A F1 X2.`
0.193[cnf]
    convert
      `assert
         ¬ X1/623 (sk_X-84 X1/623) X2/624 ∨ 
         X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ 
         sk_A X1/623 X2/624.`
0.193[cnf]
    convert
      `assert
         ¬ X1/623 (sk_X-84 X1/623) X2/624 ∨ 
         X0/622 (sk_X-84 X0/622) (sk_X-84 X0/622) ∨ 
         sk_A X1/623 X2/624.`
    into `assert
            ¬ F1 (sk_X-84 F1) X2 ∨ F0 (sk_X-84 F0) (sk_X-84 F0) ∨ 
            sk_A F1 X2.`
0.193[zip.env] trigger on_input_statement
0.193[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
      [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
       sk_A F1 X2*]/71 
      forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
      [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
       sk_A F1 X2*]/72
    sos: 
0.193[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/71`...
0.193[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/72`...
0.194[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/71`...
0.194[zip.sup] @[neg_reflect did not simplify the clause @]
0.194[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/71`...
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[unif] protected with set *
0.194[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) X2
                   ∨ sk_A F1 X2]
      :subst {F-343[0] → F0[0], F0[1] → F-343[0]}
0.194[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
          sk_A F1 X2*]/71
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [sk_A F1 X2* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/73
0.195[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬sk_A F1 X2 ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-346[0] → F0[0], F0[1] → F-346[0]}
0.195[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [sk_A F1 X2* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/73
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/74
0.195[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
             sk_A F1 X2*]/71`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/74`
0.195[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/74`...
0.195[zip.sup] @[neg_reflect did not simplify the clause @]
0.195[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/74`...
0.195[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-351[0] → F0[0], F0[1] → F-351[0]}
0.195[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/74
      subsumed by active set
0.195[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/72`...
0.195[zip.sup] @[neg_reflect did not simplify the clause @]
0.195[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/72`...
0.195[unif] protected with set *
0.195[unif] protected with set *
0.195[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F1 (sk_X-84 F1) X2
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ sk_A F1 X2]
      :subst {F-364[0] → F0[0], F0[1] → F-364[0]}
0.196[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
          sk_A F1 X2*]/72
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop) X2.
            [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/75
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             sk_A F1 X2*]/72`
    simplified into `forall (F1:ι → ι → prop) X2.
                     [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/75`
0.196[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop) X2.
       [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/75`...
0.196[zip.sup] @[neg_reflect did not simplify the clause @]
0.196[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop) X2.
       [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/75`...
0.196[unif] protected with set *
0.196[unif] protected with set *
0.196[unif] protected with set *
0.197[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F1 X2 ∨ ¬F1 (sk_X-84 F1) X2]
     :subst {F0[0] → F-389[1], 
             X1[0] → X-390[1], 
             X-390[1] → X2[1], 
             F-389[1] → F1[1]}
0.197[zip.sup]
    forall (F1:ι → ι → prop) X2.
    [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/75 subsumed by active set
0.197[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
                 [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
                  sk_A F1 X2*]/44
      is redundant
[K[0.20s]  21 steps0.197[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45`...
0.197[zip.sup] @[neg_reflect did not simplify the clause @]
0.197[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45`...
0.197[unif] protected with set *
0.197[unif] protected with set *
0.197[unif] protected with set *
0.197[unif] protected with set *
0.197[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ sk_A F1 X2*]/45`...
0.197[cnf]
    flatten_rec
      `((X1/681 (sk_X-84 X1/681) X2/682) ≡
        (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
       ∨ (sk_A X1/681 X2/682)`
      vars: (X0/683, X1/681, X2/682)
0.197[cnf]
    flatten `assert
               ∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) 
                 X2/682.
                 (((X1/681 (sk_X-84 X1/681) X2/682) ≡
                   (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
                  ∨ (sk_A X1/681 X2/682)).`
      into `assert
              ∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) 
                X2/682.
                ((sk_A X1/681 X2/682)
                 ∨ ((X1/681 (sk_X-84 X1/681) X2/682) ≡
                      (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))).`
0.198[cnf]
    simplify and rename
      `∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) X2/682.
         ((sk_A X1/681 X2/682)
          ∨ ((X1/681 (sk_X-84 X1/681) X2/682) ≡
               (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))))`
0.198[cnf]
    reduce
      `∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) X2/682.
         (((X1/681 (sk_X-84 X1/681) X2/682) ≡
           (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
          ∨ (sk_A X1/681 X2/682))`
      to CNF
0.198[cnf]
    nnf of
      `∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) X2/682.
         (((X1/681 (sk_X-84 X1/681) X2/682) ≡
           (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
          ∨ (sk_A X1/681 X2/682))`
0.198[cnf]
    nnf of
      `∀ X1/681:(ι → ι → prop) X2/682.
         (((X1/681 (sk_X-84 X1/681) X2/682) ≡
           (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
          ∨ (sk_A X1/681 X2/682))`
0.198[cnf]
    nnf of
      `∀ X2/682.
         (((X1/681 (sk_X-84 X1/681) X2/682) ≡
           (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
          ∨ (sk_A X1/681 X2/682))`
0.198[cnf]
    nnf of
      `((X1/681 (sk_X-84 X1/681) X2/682) ≡
        (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
       ∨ (sk_A X1/681 X2/682)`
0.198[cnf]
    nnf of
      `(X1/681 (sk_X-84 X1/681) X2/682) ≡
       (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))`
0.198[cnf]
    nnf of
      `((X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)) ⇒
        (X1/681 (sk_X-84 X1/681) X2/682))
       ∧ ((X1/681 (sk_X-84 X1/681) X2/682) ⇒
            (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))`
0.198[cnf]
    nnf of
      `(X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)) ⇒
       (X1/681 (sk_X-84 X1/681) X2/682)`
0.198[cnf]
    nnf of
      `(X1/681 (sk_X-84 X1/681) X2/682)
       ∨ (¬ (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))`
0.198[cnf] nnf of `X1/681 (sk_X-84 X1/681) X2/682`
0.198[cnf] nnf of `¬ (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))`
0.198[cnf]
    nnf of
      `(X1/681 (sk_X-84 X1/681) X2/682) ⇒
       (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))`
0.198[cnf]
    nnf of
      `(X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))
       ∨ (¬ (X1/681 (sk_X-84 X1/681) X2/682))`
0.198[cnf] nnf of `X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)`
0.198[cnf] nnf of `¬ (X1/681 (sk_X-84 X1/681) X2/682)`
0.199[cnf] nnf of `sk_A X1/681 X2/682`
0.199[cnf]
    ... NNF:
      `∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) X2/682.
         ((sk_A X1/681 X2/682)
          ∨ (((¬ (X1/681 (sk_X-84 X1/681) X2/682))
                ∨ (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
               ∧ ((¬ (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683)))
                    ∨ (X1/681 (sk_X-84 X1/681) X2/682))))`
0.199[cnf]
    ... miniscoped:
      `∀ X0/683:(ι → ι → prop) X1/681:(ι → ι → prop) X2/682.
         ((((X1/681 (sk_X-84 X1/681) X2/682)
            ∨ (¬ (X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))))
           ∧ ((X0/683 (sk_X-84 X0/683) (sk_X-84 X0/683))
                ∨ (¬ (X1/681 (sk_X-84 X1/681) X2/682))))
          ∨ (sk_A X1/681 X2/682))`
0.199[cnf] rename `X0/683` to `X0/684` :subst {}
0.199[cnf] rename `X1/681` to `X1/685` :subst {X0/683 → X0/684}
0.199[cnf]
    rename `X2/682` to `X2/686` :subst {X1/681 → X1/685, X0/683 → X0/684}
0.199[cnf]
    ... skolemized:
      `(sk_A X1/685 X2/686)
       ∨ (((¬ (X1/685 (sk_X-84 X1/685) X2/686))
             ∨ (X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684)))
            ∧ ((¬ (X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684)))
                 ∨ (X1/685 (sk_X-84 X1/685) X2/686)))`
0.199[cnf]
    ... CNF:
      `¬ X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ 
         X1/685 (sk_X-84 X1/685) X2/686 ∨ sk_A X1/685 X2/686, 
       ¬ X1/685 (sk_X-84 X1/685) X2/686 ∨ 
         X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ sk_A X1/685 X2/686`
0.200[cnf]
    convert
      `assert
         ¬ X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ 
         X1/685 (sk_X-84 X1/685) X2/686 ∨ 
         sk_A X1/685 X2/686.`
0.200[cnf]
    convert
      `assert
         ¬ X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ 
         X1/685 (sk_X-84 X1/685) X2/686 ∨ 
         sk_A X1/685 X2/686.`
    into `assert
            ¬ F0 (sk_X-84 F0) (sk_X-84 F0) ∨ F1 (sk_X-84 F1) X2 ∨ 
            sk_A F1 X2.`
0.200[cnf]
    convert
      `assert
         ¬ X1/685 (sk_X-84 X1/685) X2/686 ∨ 
         X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ 
         sk_A X1/685 X2/686.`
0.200[cnf]
    convert
      `assert
         ¬ X1/685 (sk_X-84 X1/685) X2/686 ∨ 
         X0/684 (sk_X-84 X0/684) (sk_X-84 X0/684) ∨ 
         sk_A X1/685 X2/686.`
    into `assert
            ¬ F1 (sk_X-84 F1) X2 ∨ F0 (sk_X-84 F0) (sk_X-84 F0) ∨ 
            sk_A F1 X2.`
0.200[zip.env] trigger on_input_statement
0.200[zip.env]
    clauses:
      forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
      [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
       sk_A F1 X2*]/76 
      forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
      [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
       sk_A F1 X2*]/77
    sos: 
0.200[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/76`...
0.200[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/77`...
0.201[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/76`...
0.201[zip.sup] @[neg_reflect did not simplify the clause @]
0.201[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
        sk_A F1 X2*]/76`...
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[unif] protected with set *
0.201[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ ¬F1 (sk_X-84 F1) X2
                   ∨ sk_A F1 X2]
      :subst {F-411[0] → F0[0], F0[1] → F-411[0]}
0.201[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
          sk_A F1 X2*]/76
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [sk_A F1 X2* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/78
0.201[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬sk_A F1 X2 ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)]
      :subst {F-414[0] → F0[0], F0[1] → F-414[0]}
0.202[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [sk_A F1 X2* ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/78
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/79
0.202[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [¬F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ F1 (sk_X-84 F1) X2* ∨ 
             sk_A F1 X2*]/76`
    simplified into `forall (F0:ι → ι → prop).
                     [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/79`
0.202[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/79`...
0.202[zip.sup] @[neg_reflect did not simplify the clause @]
0.202[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/79`...
0.202[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      :subst {F-419[0] → F0[0], F0[1] → F-419[0]}
0.202[zip.sup]
    forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/79
      subsumed by active set
0.202[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/77`...
0.203[zip.sup] @[neg_reflect did not simplify the clause @]
0.203[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
       [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
        sk_A F1 X2*]/77`...
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F1 (sk_X-84 F1) X2
                   ∨ ¬F0 (sk_X-84 F0) (sk_X-84 F0)
                   ∨ sk_A F1 X2]
      :subst {F-432[0] → F0[0], F0[1] → F-432[0]}
0.203[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
         [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
          sk_A F1 X2*]/77
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F1:ι → ι → prop) X2.
            [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/80
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[unif] protected with set *
0.203[zip.env]
    clause `forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
            [¬F1 (sk_X-84 F1) X2* ∨ F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
             sk_A F1 X2*]/77`
    simplified into `forall (F1:ι → ι → prop) X2.
                     [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/80`
0.203[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop) X2.
       [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/80`...
0.203[zip.sup] @[neg_reflect did not simplify the clause @]
0.203[zip.env]
    rewrite clause
      `forall (F1:ι → ι → prop) X2.
       [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/80`...
0.204[unif] protected with set *
0.204[unif] protected with set *
0.204[unif] protected with set *
0.204[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F1 X2 ∨ ¬F1 (sk_X-84 F1) X2]
     :subst {F0[0] → F-457[1], 
             X1[0] → X-458[1], 
             X-458[1] → X2[1], 
             F-457[1] → F1[1]}
0.204[zip.sup]
    forall (F1:ι → ι → prop) X2.
    [sk_A F1 X2* ∨ ¬F1 (sk_X-84 F1) X2*]/80 subsumed by active set
0.204[zip.saturate]
    given clause forall (F0:ι → ι → prop) (F1:ι → ι → prop) X2.
                 [F1 (sk_X-84 F1) X2 = F0 (sk_X-84 F0) (sk_X-84 F0)* ∨ 
                  sk_A F1 X2*]/45
      is redundant
[K[0.20s]  22 steps0.204[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48`...
0.204[zip.sup] @[neg_reflect did not simplify the clause @]
0.204[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48`...
0.204[unif] protected with set *
0.204[unif] protected with set *
0.204[unif] protected with set *
0.204[unif] protected with set *
0.204[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/48`...
0.204[cnf]
    flatten_rec
      `((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
        (X0/744 (sk_X-84 X0/744) X1/745))
       ∨ (sk_A X0/744 X1/745)`
      vars: (X0/744, X1/745, X2/743)
0.204[cnf]
    flatten `assert
               ∀ X0/744:(ι → ι → prop) X1/745 
                 X2/743:(ι → ι → prop).
                 (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
                   (X0/744 (sk_X-84 X0/744) X1/745))
                  ∨ (sk_A X0/744 X1/745)).`
      into `assert
              ∀ X0/744:(ι → ι → prop) X1/745 
                X2/743:(ι → ι → prop).
                ((sk_A X0/744 X1/745)
                 ∨ ((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
                      (X0/744 (sk_X-84 X0/744) X1/745))).`
0.205[cnf]
    simplify and rename
      `∀ X0/744:(ι → ι → prop) X1/745 X2/743:(ι → ι → prop).
         ((sk_A X0/744 X1/745)
          ∨ ((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
               (X0/744 (sk_X-84 X0/744) X1/745)))`
0.205[cnf]
    reduce
      `∀ X0/744:(ι → ι → prop) X1/745 X2/743:(ι → ι → prop).
         (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
           (X0/744 (sk_X-84 X0/744) X1/745))
          ∨ (sk_A X0/744 X1/745))`
      to CNF
0.205[cnf]
    nnf of
      `∀ X0/744:(ι → ι → prop) X1/745 X2/743:(ι → ι → prop).
         (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
           (X0/744 (sk_X-84 X0/744) X1/745))
          ∨ (sk_A X0/744 X1/745))`
0.205[cnf]
    nnf of
      `∀ X1/745 X2/743:(ι → ι → prop).
         (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
           (X0/744 (sk_X-84 X0/744) X1/745))
          ∨ (sk_A X0/744 X1/745))`
0.205[cnf]
    nnf of
      `∀ X2/743:(ι → ι → prop).
         (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
           (X0/744 (sk_X-84 X0/744) X1/745))
          ∨ (sk_A X0/744 X1/745))`
0.205[cnf]
    nnf of
      `((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
        (X0/744 (sk_X-84 X0/744) X1/745))
       ∨ (sk_A X0/744 X1/745)`
0.205[cnf]
    nnf of
      `(X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ≡
       (X0/744 (sk_X-84 X0/744) X1/745)`
0.205[cnf]
    nnf of
      `((X0/744 (sk_X-84 X0/744) X1/745) ⇒
        (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)))
       ∧ ((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ⇒
            (X0/744 (sk_X-84 X0/744) X1/745))`
0.205[cnf]
    nnf of
      `(X0/744 (sk_X-84 X0/744) X1/745) ⇒
       (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743))`
0.205[cnf]
    nnf of
      `(X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743))
       ∨ (¬ (X0/744 (sk_X-84 X0/744) X1/745))`
0.205[cnf] nnf of `X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)`
0.205[cnf] nnf of `¬ (X0/744 (sk_X-84 X0/744) X1/745)`
0.205[cnf]
    nnf of
      `(X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)) ⇒
       (X0/744 (sk_X-84 X0/744) X1/745)`
0.205[cnf]
    nnf of
      `(X0/744 (sk_X-84 X0/744) X1/745)
       ∨ (¬ (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)))`
0.205[cnf] nnf of `X0/744 (sk_X-84 X0/744) X1/745`
0.205[cnf] nnf of `¬ (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743))`
0.205[cnf] nnf of `sk_A X0/744 X1/745`
0.205[cnf]
    ... NNF:
      `∀ X0/744:(ι → ι → prop) X1/745 X2/743:(ι → ι → prop).
         ((sk_A X0/744 X1/745)
          ∨ (((¬ (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)))
                ∨ (X0/744 (sk_X-84 X0/744) X1/745))
               ∧ ((¬ (X0/744 (sk_X-84 X0/744) X1/745))
                    ∨ (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)))))`
0.206[cnf]
    ... miniscoped:
      `∀ X0/744:(ι → ι → prop) X1/745.
         ((sk_A X0/744 X1/745)
          ∨ (∀ X2/743:(ι → ι → prop).
                 (((X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743))
                   ∨ (¬ (X0/744 (sk_X-84 X0/744) X1/745)))
                  ∧ ((X0/744 (sk_X-84 X0/744) X1/745)
                       ∨ (¬ (X2/743 (sk_X-84 X2/743) (sk_X-84 X2/743)))))))`
0.206[cnf] rename `X0/744` to `X0/746` :subst {}
0.206[cnf] rename `X1/745` to `X1/747` :subst {X0/744 → X0/746}
0.206[cnf]
    rename `X2/743` to `X2/748` :subst {X0/744 → X0/746, X1/745 → X1/747}
0.206[cnf]
    ... skolemized:
      `(((¬ (X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748)))
         ∨ (X0/746 (sk_X-84 X0/746) X1/747))
        ∧ ((¬ (X0/746 (sk_X-84 X0/746) X1/747))
             ∨ (X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748))))
       ∨ (sk_A X0/746 X1/747)`
0.206[cnf]
    ... CNF:
      `sk_A X0/746 X1/747 ∨ X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748) ∨ 
         ¬ X0/746 (sk_X-84 X0/746) X1/747, 
       sk_A X0/746 X1/747 ∨ X0/746 (sk_X-84 X0/746) X1/747 ∨ 
         ¬ X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748)`
0.206[cnf]
    convert
      `assert
         sk_A X0/746 X1/747 ∨ 
         X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748) ∨ 
         ¬ X0/746 (sk_X-84 X0/746) X1/747.`
0.206[cnf]
    convert
      `assert
         sk_A X0/746 X1/747 ∨ 
         X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748) ∨ 
         ¬ X0/746 (sk_X-84 X0/746) X1/747.`
    into `assert
            sk_A F0 X1 ∨ F2 (sk_X-84 F2) (sk_X-84 F2) ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.206[cnf]
    convert
      `assert
         sk_A X0/746 X1/747 ∨ 
         X0/746 (sk_X-84 X0/746) X1/747 ∨ 
         ¬ X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748).`
0.206[cnf]
    convert
      `assert
         sk_A X0/746 X1/747 ∨ 
         X0/746 (sk_X-84 X0/746) X1/747 ∨ 
         ¬ X2/748 (sk_X-84 X2/748) (sk_X-84 X2/748).`
    into `assert
            sk_A F0 X1 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) (sk_X-84 F2).`
0.206[zip.env] trigger on_input_statement
0.206[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
      [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/81 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
      [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82
    sos: 
0.207[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/81`...
0.207[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82`...
0.207[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/81`...
0.207[zip.sup] @[neg_reflect did not simplify the clause @]
0.207[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/81`...
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[unif] protected with set *
0.208[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [sk_A F0 X1
                   ∨ ¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) X1]
      :subst {F-483[0] → F2[0], F0[1] → F-483[0]}
0.208[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
          ¬F0 (sk_X-84 F0) X1*]/81
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) X1.
            [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/83
0.208[unif] protected with set *
0.209[unif] protected with set *
0.209[unif] protected with set *
0.209[zip.env]
    clause `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) X1*]/81`
    simplified into `forall (F0:ι → ι → prop) X1.
                     [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/83`
0.209[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/83`...
0.209[zip.sup] @[neg_reflect did not simplify the clause @]
0.209[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/83`...
0.209[unif] protected with set *
0.209[unif] protected with set *
0.209[unif] protected with set *
0.210[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :subst {F0[0] → F-502[1], 
             X1[0] → X-503[1], 
             X-503[1] → X1[1], 
             F-502[1] → F0[1]}
0.210[zip.sup]
    forall (F0:ι → ι → prop) X1.
    [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/83 subsumed by active set
0.210[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82`...
0.210[zip.sup] @[neg_reflect did not simplify the clause @]
0.210[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82`...
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[unif] protected with set *
0.211[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬sk_A F0 X1
                   ∨ F0 (sk_X-84 F0) X1
                   ∨ ¬F2 (sk_X-84 F2) (sk_X-84 F2)]
      :subst {F-520[0] → F2[0], F0[1] → F-520[0]}
0.212[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
          ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [¬F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ F0 (sk_X-84 F0) X1*]/84
0.212[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬F0 (sk_X-84 F0) X1]
      :subst {F-521[0] → F2[0], F0[1] → F-521[0]}
0.212[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [¬F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ F0 (sk_X-84 F0) X1*]/84
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/85
0.212[zip.env]
    clause `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
             ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/82`
    simplified into `forall (F2:ι → ι → prop).
                     [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/85`
0.212[zip.env]
    rewrite clause
      `forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/85`...
0.212[zip.sup] @[neg_reflect did not simplify the clause @]
0.212[zip.env]
    rewrite clause
      `forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/85`...
0.213[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F2 (sk_X-84 F2) (sk_X-84 F2)
      :subst {F-526[0] → F2[0], F0[1] → F-526[0]}
0.213[zip.sup]
    forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/85
      subsumed by active set
0.213[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
                 [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1*]/48
      is redundant
[K[0.21s]  23 steps0.213[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49`...
0.213[zip.sup] @[neg_reflect did not simplify the clause @]
0.213[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49`...
0.213[unif] protected with set *
0.213[unif] protected with set *
0.213[unif] protected with set *
0.213[unif] protected with set *
0.213[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/49`...
0.214[cnf]
    flatten_rec
      `((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
        (X0/806 (sk_X-84 X0/806) X1/807))
       ∨ (sk_A X0/806 X1/807)`
      vars: (X0/806, X1/807, X2/805)
0.214[cnf]
    flatten `assert
               ∀ X0/806:(ι → ι → prop) X1/807 
                 X2/805:(ι → ι → prop).
                 (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
                   (X0/806 (sk_X-84 X0/806) X1/807))
                  ∨ (sk_A X0/806 X1/807)).`
      into `assert
              ∀ X0/806:(ι → ι → prop) X1/807 
                X2/805:(ι → ι → prop).
                ((sk_A X0/806 X1/807)
                 ∨ ((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
                      (X0/806 (sk_X-84 X0/806) X1/807))).`
0.214[cnf]
    simplify and rename
      `∀ X0/806:(ι → ι → prop) X1/807 X2/805:(ι → ι → prop).
         ((sk_A X0/806 X1/807)
          ∨ ((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
               (X0/806 (sk_X-84 X0/806) X1/807)))`
0.214[cnf]
    reduce
      `∀ X0/806:(ι → ι → prop) X1/807 X2/805:(ι → ι → prop).
         (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
           (X0/806 (sk_X-84 X0/806) X1/807))
          ∨ (sk_A X0/806 X1/807))`
      to CNF
0.214[cnf]
    nnf of
      `∀ X0/806:(ι → ι → prop) X1/807 X2/805:(ι → ι → prop).
         (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
           (X0/806 (sk_X-84 X0/806) X1/807))
          ∨ (sk_A X0/806 X1/807))`
0.214[cnf]
    nnf of
      `∀ X1/807 X2/805:(ι → ι → prop).
         (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
           (X0/806 (sk_X-84 X0/806) X1/807))
          ∨ (sk_A X0/806 X1/807))`
0.214[cnf]
    nnf of
      `∀ X2/805:(ι → ι → prop).
         (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
           (X0/806 (sk_X-84 X0/806) X1/807))
          ∨ (sk_A X0/806 X1/807))`
0.214[cnf]
    nnf of
      `((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
        (X0/806 (sk_X-84 X0/806) X1/807))
       ∨ (sk_A X0/806 X1/807)`
0.215[cnf]
    nnf of
      `(X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ≡
       (X0/806 (sk_X-84 X0/806) X1/807)`
0.215[cnf]
    nnf of
      `((X0/806 (sk_X-84 X0/806) X1/807) ⇒
        (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)))
       ∧ ((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ⇒
            (X0/806 (sk_X-84 X0/806) X1/807))`
0.215[cnf]
    nnf of
      `(X0/806 (sk_X-84 X0/806) X1/807) ⇒
       (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805))`
0.215[cnf]
    nnf of
      `(X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805))
       ∨ (¬ (X0/806 (sk_X-84 X0/806) X1/807))`
0.215[cnf] nnf of `X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)`
0.215[cnf] nnf of `¬ (X0/806 (sk_X-84 X0/806) X1/807)`
0.215[cnf]
    nnf of
      `(X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)) ⇒
       (X0/806 (sk_X-84 X0/806) X1/807)`
0.215[cnf]
    nnf of
      `(X0/806 (sk_X-84 X0/806) X1/807)
       ∨ (¬ (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)))`
0.215[cnf] nnf of `X0/806 (sk_X-84 X0/806) X1/807`
0.215[cnf] nnf of `¬ (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805))`
0.216[cnf] nnf of `sk_A X0/806 X1/807`
0.216[cnf]
    ... NNF:
      `∀ X0/806:(ι → ι → prop) X1/807 X2/805:(ι → ι → prop).
         ((sk_A X0/806 X1/807)
          ∨ (((¬ (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)))
                ∨ (X0/806 (sk_X-84 X0/806) X1/807))
               ∧ ((¬ (X0/806 (sk_X-84 X0/806) X1/807))
                    ∨ (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)))))`
0.216[cnf]
    ... miniscoped:
      `∀ X0/806:(ι → ι → prop) X1/807.
         ((sk_A X0/806 X1/807)
          ∨ (∀ X2/805:(ι → ι → prop).
                 (((X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805))
                   ∨ (¬ (X0/806 (sk_X-84 X0/806) X1/807)))
                  ∧ ((X0/806 (sk_X-84 X0/806) X1/807)
                       ∨ (¬ (X2/805 (sk_X-84 X2/805) (sk_X-84 X2/805)))))))`
0.216[cnf] rename `X0/806` to `X0/808` :subst {}
0.216[cnf] rename `X1/807` to `X1/809` :subst {X0/806 → X0/808}
0.217[cnf]
    rename `X2/805` to `X2/810` :subst {X0/806 → X0/808, X1/807 → X1/809}
0.217[cnf]
    ... skolemized:
      `(((¬ (X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810)))
         ∨ (X0/808 (sk_X-84 X0/808) X1/809))
        ∧ ((¬ (X0/808 (sk_X-84 X0/808) X1/809))
             ∨ (X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810))))
       ∨ (sk_A X0/808 X1/809)`
0.217[cnf]
    ... CNF:
      `sk_A X0/808 X1/809 ∨ X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810) ∨ 
         ¬ X0/808 (sk_X-84 X0/808) X1/809, 
       sk_A X0/808 X1/809 ∨ X0/808 (sk_X-84 X0/808) X1/809 ∨ 
         ¬ X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810)`
0.217[cnf]
    convert
      `assert
         sk_A X0/808 X1/809 ∨ 
         X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810) ∨ 
         ¬ X0/808 (sk_X-84 X0/808) X1/809.`
0.217[cnf]
    convert
      `assert
         sk_A X0/808 X1/809 ∨ 
         X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810) ∨ 
         ¬ X0/808 (sk_X-84 X0/808) X1/809.`
    into `assert
            sk_A F0 X1 ∨ F2 (sk_X-84 F2) (sk_X-84 F2) ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.217[cnf]
    convert
      `assert
         sk_A X0/808 X1/809 ∨ 
         X0/808 (sk_X-84 X0/808) X1/809 ∨ 
         ¬ X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810).`
0.217[cnf]
    convert
      `assert
         sk_A X0/808 X1/809 ∨ 
         X0/808 (sk_X-84 X0/808) X1/809 ∨ 
         ¬ X2/810 (sk_X-84 X2/810) (sk_X-84 X2/810).`
    into `assert
            sk_A F0 X1 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) (sk_X-84 F2).`
0.217[zip.env] trigger on_input_statement
0.217[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
      [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/86 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
      [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87
    sos: 
0.218[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/86`...
0.218[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87`...
0.218[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/86`...
0.219[zip.sup] @[neg_reflect did not simplify the clause @]
0.219[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/86`...
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[unif] protected with set *
0.220[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [sk_A F0 X1
                   ∨ ¬F2 (sk_X-84 F2) (sk_X-84 F2)
                   ∨ ¬F0 (sk_X-84 F0) X1]
      :subst {F-551[0] → F2[0], F0[1] → F-551[0]}
0.221[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
          ¬F0 (sk_X-84 F0) X1*]/86
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) X1.
            [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/88
0.221[unif] protected with set *
0.221[unif] protected with set *
0.221[unif] protected with set *
0.222[zip.env]
    clause `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [sk_A F0 X1* ∨ F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ 
             ¬F0 (sk_X-84 F0) X1*]/86`
    simplified into `forall (F0:ι → ι → prop) X1.
                     [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/88`
0.222[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/88`...
0.222[zip.sup] @[neg_reflect did not simplify the clause @]
0.222[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1.
       [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/88`...
0.222[unif] protected with set *
0.223[unif] protected with set *
0.223[unif] protected with set *
0.223[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :subst {F0[0] → F-570[1], 
             X1[0] → X-571[1], 
             X-571[1] → X1[1], 
             F-570[1] → F0[1]}
0.223[zip.sup]
    forall (F0:ι → ι → prop) X1.
    [¬F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1*]/88 subsumed by active set
0.223[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87`...
0.223[zip.sup] @[neg_reflect did not simplify the clause @]
0.223[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
       [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87`...
0.223[unif] protected with set *
0.223[unif] protected with set *
0.223[unif] protected with set *
0.223[unif] protected with set *
0.223[unif] protected with set *
0.223[unif] protected with set *
0.224[unif] protected with set *
0.224[unif] protected with set *
0.224[unif] protected with set *
0.224[unif] protected with set *
0.224[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬sk_A F0 X1
                   ∨ F0 (sk_X-84 F0) X1
                   ∨ ¬F2 (sk_X-84 F2) (sk_X-84 F2)]
      :subst {F-588[0] → F2[0], F0[1] → F-588[0]}
0.224[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
          ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [¬F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ F0 (sk_X-84 F0) X1*]/89
0.224[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0)
      eq-subsumes [¬F2 (sk_X-84 F2) (sk_X-84 F2) ∨ ¬F0 (sk_X-84 F0) X1]
      :subst {F-589[0] → F2[0], F0[1] → F-589[0]}
0.224[zip.sup]
    contextual literal cutting
      in forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
         [¬F2 (sk_X-84 F2) (sk_X-84 F2)* ∨ F0 (sk_X-84 F0) X1*]/89
      using forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34
      gives forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/90
0.224[zip.env]
    clause `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
            [sk_A F0 X1* ∨ F0 (sk_X-84 F0) X1* ∨ 
             ¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/87`
    simplified into `forall (F2:ι → ι → prop).
                     [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/90`
0.224[zip.env]
    rewrite clause
      `forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/90`...
0.224[zip.sup] @[neg_reflect did not simplify the clause @]
0.224[zip.env]
    rewrite clause
      `forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/90`...
0.224[zip.sup]
    ¬F0 (sk_X-84 F0) (sk_X-84 F0) eq-subsumes ¬F2 (sk_X-84 F2) (sk_X-84 F2)
      :subst {F-594[0] → F2[0], F0[1] → F-594[0]}
0.224[zip.sup]
    forall (F2:ι → ι → prop). [¬F2 (sk_X-84 F2) (sk_X-84 F2)*]/90
      subsumed by active set
0.225[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop).
                 [F2 (sk_X-84 F2) (sk_X-84 F2) = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1*]/49
      is redundant
[K[0.22s]  24 steps0.225[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36`...
0.225[zip.sup] @[neg_reflect did not simplify the clause @]
0.225[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36`...
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[unif] protected with set *
0.225[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/36`...
0.226[cnf]
    flatten_rec
      `((X2/867 (sk_X-84 X2/867) X3/868) ≡ (X0/869 (sk_X-84 X0/869) X1/870))
       ∨ (sk_A X0/869 X1/870)
       ∨ (sk_A X2/867 X3/868)`
      vars: (X0/869, X1/870, X2/867, X3/868)
0.226[cnf]
    flatten `assert
               ∀ X0/869:(ι → ι → prop) X1/870 
                 X2/867:(ι → ι → prop) X3/868.
                 (((X2/867 (sk_X-84 X2/867) X3/868) ≡
                   (X0/869 (sk_X-84 X0/869) X1/870))
                  ∨ (sk_A X0/869 X1/870)
                  ∨ (sk_A X2/867 X3/868)).`
      into `assert
              ∀ X0/869:(ι → ι → prop) X1/870 
                X2/867:(ι → ι → prop) X3/868.
                ((sk_A X2/867 X3/868)
                 ∨ (sk_A X0/869 X1/870)
                 ∨ ((X2/867 (sk_X-84 X2/867) X3/868) ≡
                      (X0/869 (sk_X-84 X0/869) X1/870))).`
0.226[cnf]
    simplify and rename
      `∀ X0/869:(ι → ι → prop) X1/870 X2/867:(ι → ι → prop) 
         X3/868.
         ((sk_A X2/867 X3/868)
          ∨ (sk_A X0/869 X1/870)
          ∨ ((X2/867 (sk_X-84 X2/867) X3/868) ≡
               (X0/869 (sk_X-84 X0/869) X1/870)))`
0.226[cnf]
    reduce
      `∀ X0/869:(ι → ι → prop) X1/870 X2/867:(ι → ι → prop) 
         X3/868.
         (((X2/867 (sk_X-84 X2/867) X3/868) ≡
           (X0/869 (sk_X-84 X0/869) X1/870))
          ∨ (sk_A X0/869 X1/870)
          ∨ (sk_A X2/867 X3/868))`
      to CNF
0.226[cnf]
    nnf of
      `∀ X0/869:(ι → ι → prop) X1/870 X2/867:(ι → ι → prop) 
         X3/868.
         (((X2/867 (sk_X-84 X2/867) X3/868) ≡
           (X0/869 (sk_X-84 X0/869) X1/870))
          ∨ (sk_A X0/869 X1/870)
          ∨ (sk_A X2/867 X3/868))`
0.226[cnf]
    nnf of
      `∀ X1/870 X2/867:(ι → ι → prop) X3/868.
         (((X2/867 (sk_X-84 X2/867) X3/868) ≡
           (X0/869 (sk_X-84 X0/869) X1/870))
          ∨ (sk_A X0/869 X1/870)
          ∨ (sk_A X2/867 X3/868))`
0.226[cnf]
    nnf of
      `∀ X2/867:(ι → ι → prop) X3/868.
         (((X2/867 (sk_X-84 X2/867) X3/868) ≡
           (X0/869 (sk_X-84 X0/869) X1/870))
          ∨ (sk_A X0/869 X1/870)
          ∨ (sk_A X2/867 X3/868))`
0.226[cnf]
    nnf of
      `∀ X3/868.
         (((X2/867 (sk_X-84 X2/867) X3/868) ≡
           (X0/869 (sk_X-84 X0/869) X1/870))
          ∨ (sk_A X0/869 X1/870)
          ∨ (sk_A X2/867 X3/868))`
0.226[cnf]
    nnf of
      `((X2/867 (sk_X-84 X2/867) X3/868) ≡ (X0/869 (sk_X-84 X0/869) X1/870))
       ∨ (sk_A X0/869 X1/870)
       ∨ (sk_A X2/867 X3/868)`
0.226[cnf]
    nnf of
      `(X2/867 (sk_X-84 X2/867) X3/868) ≡ (X0/869 (sk_X-84 X0/869) X1/870)`
0.226[cnf]
    nnf of
      `((X0/869 (sk_X-84 X0/869) X1/870) ⇒ (X2/867 (sk_X-84 X2/867) X3/868))
       ∧ ((X2/867 (sk_X-84 X2/867) X3/868) ⇒
            (X0/869 (sk_X-84 X0/869) X1/870))`
0.226[cnf]
    nnf of
      `(X0/869 (sk_X-84 X0/869) X1/870) ⇒ (X2/867 (sk_X-84 X2/867) X3/868)`
0.226[cnf]
    nnf of
      `(X2/867 (sk_X-84 X2/867) X3/868)
       ∨ (¬ (X0/869 (sk_X-84 X0/869) X1/870))`
0.226[cnf] nnf of `X2/867 (sk_X-84 X2/867) X3/868`
0.226[cnf] nnf of `¬ (X0/869 (sk_X-84 X0/869) X1/870)`
0.227[cnf]
    nnf of
      `(X2/867 (sk_X-84 X2/867) X3/868) ⇒ (X0/869 (sk_X-84 X0/869) X1/870)`
0.227[cnf]
    nnf of
      `(X0/869 (sk_X-84 X0/869) X1/870)
       ∨ (¬ (X2/867 (sk_X-84 X2/867) X3/868))`
0.227[cnf] nnf of `X0/869 (sk_X-84 X0/869) X1/870`
0.227[cnf] nnf of `¬ (X2/867 (sk_X-84 X2/867) X3/868)`
0.227[cnf] nnf of `sk_A X0/869 X1/870`
0.227[cnf] nnf of `sk_A X2/867 X3/868`
0.227[cnf]
    ... NNF:
      `∀ X0/869:(ι → ι → prop) X1/870 X2/867:(ι → ι → prop) 
         X3/868.
         ((sk_A X2/867 X3/868)
          ∨ (sk_A X0/869 X1/870)
          ∨ (((¬ (X2/867 (sk_X-84 X2/867) X3/868))
                ∨ (X0/869 (sk_X-84 X0/869) X1/870))
               ∧ ((¬ (X0/869 (sk_X-84 X0/869) X1/870))
                    ∨ (X2/867 (sk_X-84 X2/867) X3/868))))`
0.227[cnf]
    ... miniscoped:
      `∀ X0/869:(ι → ι → prop) X1/870 X2/867:(ι → ι → prop).
         ((sk_A X0/869 X1/870)
          ∨ (∀ X3/868.
                 ((((X2/867 (sk_X-84 X2/867) X3/868)
                    ∨ (¬ (X0/869 (sk_X-84 X0/869) X1/870)))
                   ∧ ((X0/869 (sk_X-84 X0/869) X1/870)
                        ∨ (¬ (X2/867 (sk_X-84 X2/867) X3/868))))
                  ∨ (sk_A X2/867 X3/868))))`
0.227[cnf] rename `X0/869` to `X0/871` :subst {}
0.227[cnf] rename `X1/870` to `X1/872` :subst {X0/869 → X0/871}
0.227[cnf]
    rename `X2/867` to `X2/873` :subst {X0/869 → X0/871, X1/870 → X1/872}
0.227[cnf]
    rename `X3/868` to `X3/874`
      :subst {X2/867 → X2/873, X0/869 → X0/871, X1/870 → X1/872}
0.227[cnf]
    ... skolemized:
      `(((¬ (X2/873 (sk_X-84 X2/873) X3/874))
         ∨ (X0/871 (sk_X-84 X0/871) X1/872))
        ∧ ((¬ (X0/871 (sk_X-84 X0/871) X1/872))
             ∨ (X2/873 (sk_X-84 X2/873) X3/874)))
       ∨ (sk_A X2/873 X3/874)
       ∨ (sk_A X0/871 X1/872)`
0.227[cnf]
    ... CNF:
      `sk_A X0/871 X1/872 ∨ sk_A X2/873 X3/874 ∨ 
         X0/871 (sk_X-84 X0/871) X1/872 ∨ ¬ X2/873 (sk_X-84 X2/873) X3/874, 
       sk_A X0/871 X1/872 ∨ sk_A X2/873 X3/874 ∨ 
         X2/873 (sk_X-84 X2/873) X3/874 ∨ ¬ X0/871 (sk_X-84 X0/871) X1/872`
0.227[cnf]
    convert
      `assert
         sk_A X0/871 X1/872 ∨ 
         sk_A X2/873 X3/874 ∨ 
         X0/871 (sk_X-84 X0/871) X1/872 ∨ 
         ¬ X2/873 (sk_X-84 X2/873) X3/874.`
0.227[cnf]
    convert
      `assert
         sk_A X0/871 X1/872 ∨ 
         sk_A X2/873 X3/874 ∨ 
         X0/871 (sk_X-84 X0/871) X1/872 ∨ 
         ¬ X2/873 (sk_X-84 X2/873) X3/874.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) X3.`
0.227[cnf]
    convert
      `assert
         sk_A X0/871 X1/872 ∨ 
         sk_A X2/873 X3/874 ∨ 
         X2/873 (sk_X-84 X2/873) X3/874 ∨ 
         ¬ X0/871 (sk_X-84 X0/871) X1/872.`
0.227[cnf]
    convert
      `assert
         sk_A X0/871 X1/872 ∨ 
         sk_A X2/873 X3/874 ∨ 
         X2/873 (sk_X-84 X2/873) X3/874 ∨ 
         ¬ X0/871 (sk_X-84 X0/871) X1/872.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F2 (sk_X-84 F2) X3 ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.227[zip.env] trigger on_input_statement
0.227[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) X3*]/91 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/92
    sos: 
0.228[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/91`...
0.228[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/92`...
0.228[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/91`...
0.229[zip.sup] @[neg_reflect did not simplify the clause @]
0.229[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/91`...
0.229[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F0 (sk_X-84 F0) X1
          ∨ ¬F2 (sk_X-84 F2) X3]
     :subst {F0[0] → F-673[1], 
             X1[0] → X-674[1], 
             X-674[1] → X3[1], 
             F-673[1] → F2[1]}
0.229[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
     ¬F2 (sk_X-84 F2) X3*]/91 subsumed by active set
0.229[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/92`...
0.230[zip.sup] @[neg_reflect did not simplify the clause @]
0.230[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/92`...
0.230[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F2 (sk_X-84 F2) X3
          ∨ ¬F0 (sk_X-84 F0) X1]
     :subst {F0[0] → F-717[1], 
             X1[0] → X-718[1], 
             X-718[1] → X1[1], 
             F-717[1] → F0[1]}
0.230[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
     ¬F0 (sk_X-84 F0) X1*]/92 subsumed by active set
0.230[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
                 [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1* ∨ sk_A F2 X3*]/36
      is redundant
[K[0.23s]  25 steps0.231[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37`...
0.231[zip.sup] @[neg_reflect did not simplify the clause @]
0.231[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37`...
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.231[unif] protected with set *
0.232[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/37`...
0.232[cnf]
    flatten_rec
      `((X2/923 (sk_X-84 X2/923) X3/924) ≡ (X0/925 (sk_X-84 X0/925) X1/926))
       ∨ (sk_A X0/925 X1/926)
       ∨ (sk_A X2/923 X3/924)`
      vars: (X0/925, X1/926, X2/923, X3/924)
0.232[cnf]
    flatten `assert
               ∀ X0/925:(ι → ι → prop) X1/926 
                 X2/923:(ι → ι → prop) X3/924.
                 (((X2/923 (sk_X-84 X2/923) X3/924) ≡
                   (X0/925 (sk_X-84 X0/925) X1/926))
                  ∨ (sk_A X0/925 X1/926)
                  ∨ (sk_A X2/923 X3/924)).`
      into `assert
              ∀ X0/925:(ι → ι → prop) X1/926 
                X2/923:(ι → ι → prop) X3/924.
                ((sk_A X2/923 X3/924)
                 ∨ (sk_A X0/925 X1/926)
                 ∨ ((X2/923 (sk_X-84 X2/923) X3/924) ≡
                      (X0/925 (sk_X-84 X0/925) X1/926))).`
0.232[cnf]
    simplify and rename
      `∀ X0/925:(ι → ι → prop) X1/926 X2/923:(ι → ι → prop) 
         X3/924.
         ((sk_A X2/923 X3/924)
          ∨ (sk_A X0/925 X1/926)
          ∨ ((X2/923 (sk_X-84 X2/923) X3/924) ≡
               (X0/925 (sk_X-84 X0/925) X1/926)))`
0.232[cnf]
    reduce
      `∀ X0/925:(ι → ι → prop) X1/926 X2/923:(ι → ι → prop) 
         X3/924.
         (((X2/923 (sk_X-84 X2/923) X3/924) ≡
           (X0/925 (sk_X-84 X0/925) X1/926))
          ∨ (sk_A X0/925 X1/926)
          ∨ (sk_A X2/923 X3/924))`
      to CNF
0.232[cnf]
    nnf of
      `∀ X0/925:(ι → ι → prop) X1/926 X2/923:(ι → ι → prop) 
         X3/924.
         (((X2/923 (sk_X-84 X2/923) X3/924) ≡
           (X0/925 (sk_X-84 X0/925) X1/926))
          ∨ (sk_A X0/925 X1/926)
          ∨ (sk_A X2/923 X3/924))`
0.233[cnf]
    nnf of
      `∀ X1/926 X2/923:(ι → ι → prop) X3/924.
         (((X2/923 (sk_X-84 X2/923) X3/924) ≡
           (X0/925 (sk_X-84 X0/925) X1/926))
          ∨ (sk_A X0/925 X1/926)
          ∨ (sk_A X2/923 X3/924))`
0.233[cnf]
    nnf of
      `∀ X2/923:(ι → ι → prop) X3/924.
         (((X2/923 (sk_X-84 X2/923) X3/924) ≡
           (X0/925 (sk_X-84 X0/925) X1/926))
          ∨ (sk_A X0/925 X1/926)
          ∨ (sk_A X2/923 X3/924))`
0.233[cnf]
    nnf of
      `∀ X3/924.
         (((X2/923 (sk_X-84 X2/923) X3/924) ≡
           (X0/925 (sk_X-84 X0/925) X1/926))
          ∨ (sk_A X0/925 X1/926)
          ∨ (sk_A X2/923 X3/924))`
0.233[cnf]
    nnf of
      `((X2/923 (sk_X-84 X2/923) X3/924) ≡ (X0/925 (sk_X-84 X0/925) X1/926))
       ∨ (sk_A X0/925 X1/926)
       ∨ (sk_A X2/923 X3/924)`
0.233[cnf]
    nnf of
      `(X2/923 (sk_X-84 X2/923) X3/924) ≡ (X0/925 (sk_X-84 X0/925) X1/926)`
0.233[cnf]
    nnf of
      `((X0/925 (sk_X-84 X0/925) X1/926) ⇒ (X2/923 (sk_X-84 X2/923) X3/924))
       ∧ ((X2/923 (sk_X-84 X2/923) X3/924) ⇒
            (X0/925 (sk_X-84 X0/925) X1/926))`
0.233[cnf]
    nnf of
      `(X0/925 (sk_X-84 X0/925) X1/926) ⇒ (X2/923 (sk_X-84 X2/923) X3/924)`
0.233[cnf]
    nnf of
      `(X2/923 (sk_X-84 X2/923) X3/924)
       ∨ (¬ (X0/925 (sk_X-84 X0/925) X1/926))`
0.233[cnf] nnf of `X2/923 (sk_X-84 X2/923) X3/924`
0.233[cnf] nnf of `¬ (X0/925 (sk_X-84 X0/925) X1/926)`
0.233[cnf]
    nnf of
      `(X2/923 (sk_X-84 X2/923) X3/924) ⇒ (X0/925 (sk_X-84 X0/925) X1/926)`
0.233[cnf]
    nnf of
      `(X0/925 (sk_X-84 X0/925) X1/926)
       ∨ (¬ (X2/923 (sk_X-84 X2/923) X3/924))`
0.233[cnf] nnf of `X0/925 (sk_X-84 X0/925) X1/926`
0.233[cnf] nnf of `¬ (X2/923 (sk_X-84 X2/923) X3/924)`
0.233[cnf] nnf of `sk_A X0/925 X1/926`
0.233[cnf] nnf of `sk_A X2/923 X3/924`
0.233[cnf]
    ... NNF:
      `∀ X0/925:(ι → ι → prop) X1/926 X2/923:(ι → ι → prop) 
         X3/924.
         ((sk_A X2/923 X3/924)
          ∨ (sk_A X0/925 X1/926)
          ∨ (((¬ (X2/923 (sk_X-84 X2/923) X3/924))
                ∨ (X0/925 (sk_X-84 X0/925) X1/926))
               ∧ ((¬ (X0/925 (sk_X-84 X0/925) X1/926))
                    ∨ (X2/923 (sk_X-84 X2/923) X3/924))))`
0.234[cnf]
    ... miniscoped:
      `∀ X0/925:(ι → ι → prop) X1/926 X2/923:(ι → ι → prop).
         ((sk_A X0/925 X1/926)
          ∨ (∀ X3/924.
                 ((((X2/923 (sk_X-84 X2/923) X3/924)
                    ∨ (¬ (X0/925 (sk_X-84 X0/925) X1/926)))
                   ∧ ((X0/925 (sk_X-84 X0/925) X1/926)
                        ∨ (¬ (X2/923 (sk_X-84 X2/923) X3/924))))
                  ∨ (sk_A X2/923 X3/924))))`
0.234[cnf] rename `X0/925` to `X0/927` :subst {}
0.234[cnf] rename `X1/926` to `X1/928` :subst {X0/925 → X0/927}
0.234[cnf]
    rename `X2/923` to `X2/929` :subst {X0/925 → X0/927, X1/926 → X1/928}
0.234[cnf]
    rename `X3/924` to `X3/930`
      :subst {X2/923 → X2/929, X0/925 → X0/927, X1/926 → X1/928}
0.234[cnf]
    ... skolemized:
      `(((¬ (X2/929 (sk_X-84 X2/929) X3/930))
         ∨ (X0/927 (sk_X-84 X0/927) X1/928))
        ∧ ((¬ (X0/927 (sk_X-84 X0/927) X1/928))
             ∨ (X2/929 (sk_X-84 X2/929) X3/930)))
       ∨ (sk_A X2/929 X3/930)
       ∨ (sk_A X0/927 X1/928)`
0.234[cnf]
    ... CNF:
      `sk_A X0/927 X1/928 ∨ sk_A X2/929 X3/930 ∨ 
         X0/927 (sk_X-84 X0/927) X1/928 ∨ ¬ X2/929 (sk_X-84 X2/929) X3/930, 
       sk_A X0/927 X1/928 ∨ sk_A X2/929 X3/930 ∨ 
         X2/929 (sk_X-84 X2/929) X3/930 ∨ ¬ X0/927 (sk_X-84 X0/927) X1/928`
0.234[cnf]
    convert
      `assert
         sk_A X0/927 X1/928 ∨ 
         sk_A X2/929 X3/930 ∨ 
         X0/927 (sk_X-84 X0/927) X1/928 ∨ 
         ¬ X2/929 (sk_X-84 X2/929) X3/930.`
0.234[cnf]
    convert
      `assert
         sk_A X0/927 X1/928 ∨ 
         sk_A X2/929 X3/930 ∨ 
         X0/927 (sk_X-84 X0/927) X1/928 ∨ 
         ¬ X2/929 (sk_X-84 X2/929) X3/930.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) X3.`
0.234[cnf]
    convert
      `assert
         sk_A X0/927 X1/928 ∨ 
         sk_A X2/929 X3/930 ∨ 
         X2/929 (sk_X-84 X2/929) X3/930 ∨ 
         ¬ X0/927 (sk_X-84 X0/927) X1/928.`
0.234[cnf]
    convert
      `assert
         sk_A X0/927 X1/928 ∨ 
         sk_A X2/929 X3/930 ∨ 
         X2/929 (sk_X-84 X2/929) X3/930 ∨ 
         ¬ X0/927 (sk_X-84 X0/927) X1/928.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F2 (sk_X-84 F2) X3 ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.234[zip.env] trigger on_input_statement
0.234[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) X3*]/93 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/94
    sos: 
0.235[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/93`...
0.235[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/94`...
0.235[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/93`...
0.236[zip.sup] @[neg_reflect did not simplify the clause @]
0.236[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/93`...
0.237[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F0 (sk_X-84 F0) X1
          ∨ ¬F2 (sk_X-84 F2) X3]
     :subst {F0[0] → F-797[1], 
             X1[0] → X-798[1], 
             X-798[1] → X3[1], 
             F-797[1] → F2[1]}
0.237[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
     ¬F2 (sk_X-84 F2) X3*]/93 subsumed by active set
0.237[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/94`...
0.238[zip.sup] @[neg_reflect did not simplify the clause @]
0.238[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/94`...
0.238[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F2 (sk_X-84 F2) X3
          ∨ ¬F0 (sk_X-84 F0) X1]
     :subst {F0[0] → F-841[1], 
             X1[0] → X-842[1], 
             X-842[1] → X1[1], 
             F-841[1] → F0[1]}
0.238[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
     ¬F0 (sk_X-84 F0) X1*]/94 subsumed by active set
0.238[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
                 [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1* ∨ sk_A F2 X3*]/37
      is redundant
[K[0.24s]  26 steps0.238[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40`...
0.239[zip.sup] @[neg_reflect did not simplify the clause @]
0.239[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40`...
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[unif] protected with set *
0.239[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/40`...
0.240[cnf]
    flatten_rec
      `((X2/979 (sk_X-84 X2/979) X3/980) ≡ (X0/981 (sk_X-84 X0/981) X1/982))
       ∨ (sk_A X0/981 X1/982)
       ∨ (sk_A X2/979 X3/980)`
      vars: (X0/981, X1/982, X2/979, X3/980)
0.240[cnf]
    flatten `assert
               ∀ X0/981:(ι → ι → prop) X1/982 
                 X2/979:(ι → ι → prop) X3/980.
                 (((X2/979 (sk_X-84 X2/979) X3/980) ≡
                   (X0/981 (sk_X-84 X0/981) X1/982))
                  ∨ (sk_A X0/981 X1/982)
                  ∨ (sk_A X2/979 X3/980)).`
      into `assert
              ∀ X0/981:(ι → ι → prop) X1/982 
                X2/979:(ι → ι → prop) X3/980.
                ((sk_A X2/979 X3/980)
                 ∨ (sk_A X0/981 X1/982)
                 ∨ ((X2/979 (sk_X-84 X2/979) X3/980) ≡
                      (X0/981 (sk_X-84 X0/981) X1/982))).`
0.240[cnf]
    simplify and rename
      `∀ X0/981:(ι → ι → prop) X1/982 X2/979:(ι → ι → prop) 
         X3/980.
         ((sk_A X2/979 X3/980)
          ∨ (sk_A X0/981 X1/982)
          ∨ ((X2/979 (sk_X-84 X2/979) X3/980) ≡
               (X0/981 (sk_X-84 X0/981) X1/982)))`
0.240[cnf]
    reduce
      `∀ X0/981:(ι → ι → prop) X1/982 X2/979:(ι → ι → prop) 
         X3/980.
         (((X2/979 (sk_X-84 X2/979) X3/980) ≡
           (X0/981 (sk_X-84 X0/981) X1/982))
          ∨ (sk_A X0/981 X1/982)
          ∨ (sk_A X2/979 X3/980))`
      to CNF
0.240[cnf]
    nnf of
      `∀ X0/981:(ι → ι → prop) X1/982 X2/979:(ι → ι → prop) 
         X3/980.
         (((X2/979 (sk_X-84 X2/979) X3/980) ≡
           (X0/981 (sk_X-84 X0/981) X1/982))
          ∨ (sk_A X0/981 X1/982)
          ∨ (sk_A X2/979 X3/980))`
0.240[cnf]
    nnf of
      `∀ X1/982 X2/979:(ι → ι → prop) X3/980.
         (((X2/979 (sk_X-84 X2/979) X3/980) ≡
           (X0/981 (sk_X-84 X0/981) X1/982))
          ∨ (sk_A X0/981 X1/982)
          ∨ (sk_A X2/979 X3/980))`
0.240[cnf]
    nnf of
      `∀ X2/979:(ι → ι → prop) X3/980.
         (((X2/979 (sk_X-84 X2/979) X3/980) ≡
           (X0/981 (sk_X-84 X0/981) X1/982))
          ∨ (sk_A X0/981 X1/982)
          ∨ (sk_A X2/979 X3/980))`
0.240[cnf]
    nnf of
      `∀ X3/980.
         (((X2/979 (sk_X-84 X2/979) X3/980) ≡
           (X0/981 (sk_X-84 X0/981) X1/982))
          ∨ (sk_A X0/981 X1/982)
          ∨ (sk_A X2/979 X3/980))`
0.240[cnf]
    nnf of
      `((X2/979 (sk_X-84 X2/979) X3/980) ≡ (X0/981 (sk_X-84 X0/981) X1/982))
       ∨ (sk_A X0/981 X1/982)
       ∨ (sk_A X2/979 X3/980)`
0.241[cnf]
    nnf of
      `(X2/979 (sk_X-84 X2/979) X3/980) ≡ (X0/981 (sk_X-84 X0/981) X1/982)`
0.241[cnf]
    nnf of
      `((X0/981 (sk_X-84 X0/981) X1/982) ⇒ (X2/979 (sk_X-84 X2/979) X3/980))
       ∧ ((X2/979 (sk_X-84 X2/979) X3/980) ⇒
            (X0/981 (sk_X-84 X0/981) X1/982))`
0.241[cnf]
    nnf of
      `(X0/981 (sk_X-84 X0/981) X1/982) ⇒ (X2/979 (sk_X-84 X2/979) X3/980)`
0.241[cnf]
    nnf of
      `(X2/979 (sk_X-84 X2/979) X3/980)
       ∨ (¬ (X0/981 (sk_X-84 X0/981) X1/982))`
0.241[cnf] nnf of `X2/979 (sk_X-84 X2/979) X3/980`
0.241[cnf] nnf of `¬ (X0/981 (sk_X-84 X0/981) X1/982)`
0.241[cnf]
    nnf of
      `(X2/979 (sk_X-84 X2/979) X3/980) ⇒ (X0/981 (sk_X-84 X0/981) X1/982)`
0.241[cnf]
    nnf of
      `(X0/981 (sk_X-84 X0/981) X1/982)
       ∨ (¬ (X2/979 (sk_X-84 X2/979) X3/980))`
0.241[cnf] nnf of `X0/981 (sk_X-84 X0/981) X1/982`
0.241[cnf] nnf of `¬ (X2/979 (sk_X-84 X2/979) X3/980)`
0.241[cnf] nnf of `sk_A X0/981 X1/982`
0.241[cnf] nnf of `sk_A X2/979 X3/980`
0.241[cnf]
    ... NNF:
      `∀ X0/981:(ι → ι → prop) X1/982 X2/979:(ι → ι → prop) 
         X3/980.
         ((sk_A X2/979 X3/980)
          ∨ (sk_A X0/981 X1/982)
          ∨ (((¬ (X2/979 (sk_X-84 X2/979) X3/980))
                ∨ (X0/981 (sk_X-84 X0/981) X1/982))
               ∧ ((¬ (X0/981 (sk_X-84 X0/981) X1/982))
                    ∨ (X2/979 (sk_X-84 X2/979) X3/980))))`
0.241[cnf]
    ... miniscoped:
      `∀ X0/981:(ι → ι → prop) X1/982 X2/979:(ι → ι → prop).
         ((sk_A X0/981 X1/982)
          ∨ (∀ X3/980.
                 ((((X2/979 (sk_X-84 X2/979) X3/980)
                    ∨ (¬ (X0/981 (sk_X-84 X0/981) X1/982)))
                   ∧ ((X0/981 (sk_X-84 X0/981) X1/982)
                        ∨ (¬ (X2/979 (sk_X-84 X2/979) X3/980))))
                  ∨ (sk_A X2/979 X3/980))))`
0.241[cnf] rename `X0/981` to `X0/983` :subst {}
0.241[cnf] rename `X1/982` to `X1/984` :subst {X0/981 → X0/983}
0.241[cnf]
    rename `X2/979` to `X2/985` :subst {X0/981 → X0/983, X1/982 → X1/984}
0.241[cnf]
    rename `X3/980` to `X3/986`
      :subst {X2/979 → X2/985, X0/981 → X0/983, X1/982 → X1/984}
0.241[cnf]
    ... skolemized:
      `(((¬ (X2/985 (sk_X-84 X2/985) X3/986))
         ∨ (X0/983 (sk_X-84 X0/983) X1/984))
        ∧ ((¬ (X0/983 (sk_X-84 X0/983) X1/984))
             ∨ (X2/985 (sk_X-84 X2/985) X3/986)))
       ∨ (sk_A X2/985 X3/986)
       ∨ (sk_A X0/983 X1/984)`
0.241[cnf]
    ... CNF:
      `sk_A X0/983 X1/984 ∨ sk_A X2/985 X3/986 ∨ 
         X0/983 (sk_X-84 X0/983) X1/984 ∨ ¬ X2/985 (sk_X-84 X2/985) X3/986, 
       sk_A X0/983 X1/984 ∨ sk_A X2/985 X3/986 ∨ 
         X2/985 (sk_X-84 X2/985) X3/986 ∨ ¬ X0/983 (sk_X-84 X0/983) X1/984`
0.242[cnf]
    convert
      `assert
         sk_A X0/983 X1/984 ∨ 
         sk_A X2/985 X3/986 ∨ 
         X0/983 (sk_X-84 X0/983) X1/984 ∨ 
         ¬ X2/985 (sk_X-84 X2/985) X3/986.`
0.242[cnf]
    convert
      `assert
         sk_A X0/983 X1/984 ∨ 
         sk_A X2/985 X3/986 ∨ 
         X0/983 (sk_X-84 X0/983) X1/984 ∨ 
         ¬ X2/985 (sk_X-84 X2/985) X3/986.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) X3.`
0.242[cnf]
    convert
      `assert
         sk_A X0/983 X1/984 ∨ 
         sk_A X2/985 X3/986 ∨ 
         X2/985 (sk_X-84 X2/985) X3/986 ∨ 
         ¬ X0/983 (sk_X-84 X0/983) X1/984.`
0.242[cnf]
    convert
      `assert
         sk_A X0/983 X1/984 ∨ 
         sk_A X2/985 X3/986 ∨ 
         X2/985 (sk_X-84 X2/985) X3/986 ∨ 
         ¬ X0/983 (sk_X-84 X0/983) X1/984.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F2 (sk_X-84 F2) X3 ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.242[zip.env] trigger on_input_statement
0.242[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) X3*]/95 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/96
    sos: 
0.242[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/95`...
0.242[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/96`...
0.243[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/95`...
0.243[zip.sup] @[neg_reflect did not simplify the clause @]
0.243[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/95`...
0.243[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F0 (sk_X-84 F0) X1
          ∨ ¬F2 (sk_X-84 F2) X3]
     :subst {F0[0] → F-921[1], 
             X1[0] → X-922[1], 
             X-922[1] → X3[1], 
             F-921[1] → F2[1]}
0.244[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
     ¬F2 (sk_X-84 F2) X3*]/95 subsumed by active set
0.244[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/96`...
0.244[zip.sup] @[neg_reflect did not simplify the clause @]
0.244[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/96`...
0.245[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F2 (sk_X-84 F2) X3
          ∨ ¬F0 (sk_X-84 F0) X1]
     :subst {F0[0] → F-965[1], 
             X1[0] → X-966[1], 
             X-966[1] → X1[1], 
             F-965[1] → F0[1]}
0.245[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
     ¬F0 (sk_X-84 F0) X1*]/96 subsumed by active set
0.245[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
                 [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1* ∨ sk_A F2 X3*]/40
      is redundant
[K[0.24s]  27 steps0.245[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41`...
0.245[zip.sup] @[neg_reflect did not simplify the clause @]
0.245[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41`...
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[unif] protected with set *
0.246[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ sk_A F0 X1* ∨ 
        sk_A F2 X3*]/41`...
0.246[cnf]
    flatten_rec
      `((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
        (X0/1037 (sk_X-84 X0/1037) X1/1038))
       ∨ (sk_A X0/1037 X1/1038)
       ∨ (sk_A X2/1035 X3/1036)`
      vars: (X0/1037, X1/1038, X2/1035, X3/1036)
0.246[cnf]
    flatten `assert
               ∀ X0/1037:(ι → ι → prop) X1/1038 
                 X2/1035:(ι → ι → prop) X3/1036.
                 (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
                   (X0/1037 (sk_X-84 X0/1037) X1/1038))
                  ∨ (sk_A X0/1037 X1/1038)
                  ∨ (sk_A X2/1035 X3/1036)).`
      into `assert
              ∀ X0/1037:(ι → ι → prop) X1/1038 
                X2/1035:(ι → ι → prop) X3/1036.
                ((sk_A X2/1035 X3/1036)
                 ∨ (sk_A X0/1037 X1/1038)
                 ∨ ((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
                      (X0/1037 (sk_X-84 X0/1037) X1/1038))).`
0.247[cnf]
    simplify and rename
      `∀ X0/1037:(ι → ι → prop) X1/1038 X2/1035:(ι → ι → prop) 
         X3/1036.
         ((sk_A X2/1035 X3/1036)
          ∨ (sk_A X0/1037 X1/1038)
          ∨ ((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
               (X0/1037 (sk_X-84 X0/1037) X1/1038)))`
0.247[cnf]
    reduce
      `∀ X0/1037:(ι → ι → prop) X1/1038 X2/1035:(ι → ι → prop) 
         X3/1036.
         (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
           (X0/1037 (sk_X-84 X0/1037) X1/1038))
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (sk_A X2/1035 X3/1036))`
      to CNF
0.247[cnf]
    nnf of
      `∀ X0/1037:(ι → ι → prop) X1/1038 X2/1035:(ι → ι → prop) 
         X3/1036.
         (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
           (X0/1037 (sk_X-84 X0/1037) X1/1038))
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (sk_A X2/1035 X3/1036))`
0.247[cnf]
    nnf of
      `∀ X1/1038 X2/1035:(ι → ι → prop) X3/1036.
         (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
           (X0/1037 (sk_X-84 X0/1037) X1/1038))
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (sk_A X2/1035 X3/1036))`
0.247[cnf]
    nnf of
      `∀ X2/1035:(ι → ι → prop) X3/1036.
         (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
           (X0/1037 (sk_X-84 X0/1037) X1/1038))
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (sk_A X2/1035 X3/1036))`
0.247[cnf]
    nnf of
      `∀ X3/1036.
         (((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
           (X0/1037 (sk_X-84 X0/1037) X1/1038))
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (sk_A X2/1035 X3/1036))`
0.247[cnf]
    nnf of
      `((X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
        (X0/1037 (sk_X-84 X0/1037) X1/1038))
       ∨ (sk_A X0/1037 X1/1038)
       ∨ (sk_A X2/1035 X3/1036)`
0.247[cnf]
    nnf of
      `(X2/1035 (sk_X-84 X2/1035) X3/1036) ≡
       (X0/1037 (sk_X-84 X0/1037) X1/1038)`
0.247[cnf]
    nnf of
      `((X0/1037 (sk_X-84 X0/1037) X1/1038) ⇒
        (X2/1035 (sk_X-84 X2/1035) X3/1036))
       ∧ ((X2/1035 (sk_X-84 X2/1035) X3/1036) ⇒
            (X0/1037 (sk_X-84 X0/1037) X1/1038))`
0.247[cnf]
    nnf of
      `(X0/1037 (sk_X-84 X0/1037) X1/1038) ⇒
       (X2/1035 (sk_X-84 X2/1035) X3/1036)`
0.247[cnf]
    nnf of
      `(X2/1035 (sk_X-84 X2/1035) X3/1036)
       ∨ (¬ (X0/1037 (sk_X-84 X0/1037) X1/1038))`
0.247[cnf] nnf of `X2/1035 (sk_X-84 X2/1035) X3/1036`
0.247[cnf] nnf of `¬ (X0/1037 (sk_X-84 X0/1037) X1/1038)`
0.247[cnf]
    nnf of
      `(X2/1035 (sk_X-84 X2/1035) X3/1036) ⇒
       (X0/1037 (sk_X-84 X0/1037) X1/1038)`
0.247[cnf]
    nnf of
      `(X0/1037 (sk_X-84 X0/1037) X1/1038)
       ∨ (¬ (X2/1035 (sk_X-84 X2/1035) X3/1036))`
0.247[cnf] nnf of `X0/1037 (sk_X-84 X0/1037) X1/1038`
0.247[cnf] nnf of `¬ (X2/1035 (sk_X-84 X2/1035) X3/1036)`
0.247[cnf] nnf of `sk_A X0/1037 X1/1038`
0.247[cnf] nnf of `sk_A X2/1035 X3/1036`
0.247[cnf]
    ... NNF:
      `∀ X0/1037:(ι → ι → prop) X1/1038 X2/1035:(ι → ι → prop) 
         X3/1036.
         ((sk_A X2/1035 X3/1036)
          ∨ (sk_A X0/1037 X1/1038)
          ∨ (((¬ (X2/1035 (sk_X-84 X2/1035) X3/1036))
                ∨ (X0/1037 (sk_X-84 X0/1037) X1/1038))
               ∧ ((¬ (X0/1037 (sk_X-84 X0/1037) X1/1038))
                    ∨ (X2/1035 (sk_X-84 X2/1035) X3/1036))))`
0.248[cnf]
    ... miniscoped:
      `∀ X0/1037:(ι → ι → prop) X1/1038 X2/1035:(ι → ι → prop).
         ((sk_A X0/1037 X1/1038)
          ∨ (∀ X3/1036.
                 ((((X2/1035 (sk_X-84 X2/1035) X3/1036)
                    ∨ (¬ (X0/1037 (sk_X-84 X0/1037) X1/1038)))
                   ∧ ((X0/1037 (sk_X-84 X0/1037) X1/1038)
                        ∨ (¬ (X2/1035 (sk_X-84 X2/1035) X3/1036))))
                  ∨ (sk_A X2/1035 X3/1036))))`
0.248[cnf] rename `X0/1037` to `X0/1039` :subst {}
0.248[cnf] rename `X1/1038` to `X1/1040` :subst {X0/1037 → X0/1039}
0.248[cnf]
    rename `X2/1035` to `X2/1041`
      :subst {X0/1037 → X0/1039, X1/1038 → X1/1040}
0.248[cnf]
    rename `X3/1036` to `X3/1042`
      :subst {X2/1035 → X2/1041, X0/1037 → X0/1039, X1/1038 → X1/1040}
0.248[cnf]
    ... skolemized:
      `(((¬ (X2/1041 (sk_X-84 X2/1041) X3/1042))
         ∨ (X0/1039 (sk_X-84 X0/1039) X1/1040))
        ∧ ((¬ (X0/1039 (sk_X-84 X0/1039) X1/1040))
             ∨ (X2/1041 (sk_X-84 X2/1041) X3/1042)))
       ∨ (sk_A X2/1041 X3/1042)
       ∨ (sk_A X0/1039 X1/1040)`
0.248[cnf]
    ... CNF:
      `sk_A X0/1039 X1/1040 ∨ sk_A X2/1041 X3/1042 ∨ 
         X0/1039 (sk_X-84 X0/1039) X1/1040 ∨ 
         ¬ X2/1041 (sk_X-84 X2/1041) X3/1042, 
       sk_A X0/1039 X1/1040 ∨ sk_A X2/1041 X3/1042 ∨ 
         X2/1041 (sk_X-84 X2/1041) X3/1042 ∨ 
         ¬ X0/1039 (sk_X-84 X0/1039) X1/1040`
0.248[cnf]
    convert
      `assert
         sk_A X0/1039 X1/1040 ∨ 
         sk_A X2/1041 X3/1042 ∨ 
         X0/1039 (sk_X-84 X0/1039) X1/1040 ∨ 
         ¬ X2/1041 (sk_X-84 X2/1041) X3/1042.`
0.248[cnf]
    convert
      `assert
         sk_A X0/1039 X1/1040 ∨ 
         sk_A X2/1041 X3/1042 ∨ 
         X0/1039 (sk_X-84 X0/1039) X1/1040 ∨ 
         ¬ X2/1041 (sk_X-84 X2/1041) X3/1042.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F0 (sk_X-84 F0) X1 ∨ 
            ¬ F2 (sk_X-84 F2) X3.`
0.249[cnf]
    convert
      `assert
         sk_A X0/1039 X1/1040 ∨ 
         sk_A X2/1041 X3/1042 ∨ 
         X2/1041 (sk_X-84 X2/1041) X3/1042 ∨ 
         ¬ X0/1039 (sk_X-84 X0/1039) X1/1040.`
0.249[cnf]
    convert
      `assert
         sk_A X0/1039 X1/1040 ∨ 
         sk_A X2/1041 X3/1042 ∨ 
         X2/1041 (sk_X-84 X2/1041) X3/1042 ∨ 
         ¬ X0/1039 (sk_X-84 X0/1039) X1/1040.`
    into `assert
            sk_A F0 X1 ∨ sk_A F2 X3 ∨ F2 (sk_X-84 F2) X3 ∨ 
            ¬ F0 (sk_X-84 F0) X1.`
0.249[zip.env] trigger on_input_statement
0.249[zip.env]
    clauses:
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
       ¬F2 (sk_X-84 F2) X3*]/97 
      forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
      [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
       ¬F0 (sk_X-84 F0) X1*]/98
    sos: 
0.249[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/97`...
0.249[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/98`...
0.250[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/97`...
0.250[zip.sup] @[neg_reflect did not simplify the clause @]
0.250[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
        ¬F2 (sk_X-84 F2) X3*]/97`...
0.251[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F0 (sk_X-84 F0) X1
          ∨ ¬F2 (sk_X-84 F2) X3]
     :subst {F0[0] → F-1045[1], 
             X1[0] → X-1046[1], 
             X-1046[1] → X3[1], 
             F-1045[1] → F2[1]}
0.251[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F0 (sk_X-84 F0) X1* ∨ 
     ¬F2 (sk_X-84 F2) X3*]/97 subsumed by active set
0.251[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/98`...
0.252[zip.sup] @[neg_reflect did not simplify the clause @]
0.252[zip.env]
    rewrite clause
      `forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
       [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
        ¬F0 (sk_X-84 F0) X1*]/98`...
0.253[zip.sup]
    (subsumes
     :c1 [¬F0 (sk_X-84 F0) X1 ∨ sk_A F0 X1]
     :c2 [sk_A F0 X1
          ∨ sk_A F2 X3
          ∨ F2 (sk_X-84 F2) X3
          ∨ ¬F0 (sk_X-84 F0) X1]
     :subst {F0[0] → F-1089[1], 
             X1[0] → X-1090[1], 
             X-1090[1] → X1[1], 
             F-1089[1] → F0[1]}
0.253[zip.sup]
    forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
    [sk_A F0 X1* ∨ sk_A F2 X3* ∨ F2 (sk_X-84 F2) X3* ∨ 
     ¬F0 (sk_X-84 F0) X1*]/98 subsumed by active set
0.254[zip.saturate]
    given clause forall (F0:ι → ι → prop) X1 (F2:ι → ι → prop) X3.
                 [F2 (sk_X-84 F2) X3 = F0 (sk_X-84 F0) X1* ∨ 
                  sk_A F0 X1* ∨ sk_A F2 X3*]/41
      is redundant
[K[0.25s]  28 steps0.254[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.255[zip.sup] @[neg_reflect did not simplify the clause @]
0.255[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.256[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.257[zip.saturate] ### step    28 ###
0.257[zip.saturate]
    given (28 steps, penalty 2):
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`
0.257[zip.env]
    do binary inferences with current active set:
      `{forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13,
        forall (F0:ι → ι → prop) X1.
        [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14,
        forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34,
        forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
        [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
         ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
             F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43}`
0.258[zip.env] apply binary rule superposition_active
0.259[zip.sup] ... cancel, will yield a tautology
0.260[zip.sup]
    sup, kind sup
      (forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43[0]
         s=sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0
         t=true, t'=true)
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         passive_lit=¬sk_A F0 (sk_X-84 F0) p=0.←.ε)
      with subst={X0[0] → sk_X-84 F0[1], 
                  F0[1] → λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))[0]}.

0.260[zip.sup]
    Res: forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
         [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
              (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
              F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
               (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99.

0.261[zip.sup] ... cancel, will yield a tautology
0.269[zip.sup] ... cancel, will yield a tautology
0.269[zip.sup] ... cancel, will yield a tautology
0.269[zip.env] apply binary rule superposition_passive
0.270[zip.sup] ... cancel, will yield a tautology
0.271[zip.sup]
    sup, kind sup
      (forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13[1]
         s=sk_A F0 (sk_X-84 F0) t=false, t'=false)
      (forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43[0]
         passive_lit=sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0
         p=0.←.ε)
      with subst={X0[0] → sk_X-84 F0[1], 
                  F0[1] → λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))[0]}.

0.271[zip.sup]
    Res: forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
         [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
              (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
              F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
               (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100.

0.272[zip.sup] ... cancel, will yield a tautology
0.278[zip.sup] ... cancel, will yield a tautology
0.278[zip.sup] ... cancel, will yield a tautology
0.301[zip.env] apply binary rule ctx_narrow
0.301[zip.env] apply binary rule narrow_term_defs
0.301[zip.env]
    rewrite clause
      `forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
       [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
        ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
            F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43`...
0.301[zip.env] do unary inferences
0.301[zip.env] apply unary rule equality_resolution
0.301[zip.env] apply unary rule equality_factoring
0.302[zip.env] apply unary rule narrow_lit_defs
0.302[zip.env] apply unary rule ind_types.exhaustiveness
0.302[zip.env] apply unary rule ind_types.acyclicity
0.302[zip.env] apply unary rule ho_prim_enum
0.302[zip.env] apply unary rule neg_ext
0.302[zip.env] apply unary rule ho_ext_pos
0.302[zip.env] apply unary rule ho_complete_eq
0.302[zip.env] apply unary rule avatar_check_empty
0.302[zip.env] apply generating rule avatar.lemmas (full: false)
0.302[zip.env] apply generating rule avatar_check_sat (full: false)
0.302[zip.avatar] SAT-solver reports "SAT"
0.302[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100`...
0.302[zip.sup] @[neg_reflect did not simplify the clause @]
0.302[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100`...
0.302[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99`...
0.303[zip.sup] @[neg_reflect did not simplify the clause @]
0.303[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99`...
0.303[zip.saturate]
    inferred new clauses:
      [forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100, 
       forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99]
[K[0.30s]  29 steps0.303[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.304[zip.sup] @[neg_reflect did not simplify the clause @]
0.304[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.304[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.304[zip.saturate] ### step    29 ###
0.304[zip.saturate]
    given (29 steps, penalty 2):
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`
0.305[unif]
    (flex_flex_matching `X-1216 Y-2, Y-1`[1] `X2 Y-2, Y-1`[1]
     :subst {A0[0] → A1[1], 
             F1[0] → F-1216[1], 
             F2[0] → F-1215[1], 
             F-1215[1] → F3[1]}
     :bvars {[ι],[ι] | [ι],[ι]})
0.305[zip.env]
    do binary inferences with current active set:
      `{forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13,
        forall (F0:ι → ι → prop) X1.
        [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14,
        forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34,
        forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
        [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
         ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
             F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43,
        forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
        [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
             F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
              (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53}`
0.305[zip.env] apply binary rule superposition_active
0.312[zip.sup] ... cancel, will yield a tautology
0.312[zip.sup] ... cancel, will yield a tautology
0.318[zip.sup] ... cancel, will yield a tautology
0.319[zip.sup] ... cancel, will yield a tautology
0.319[zip.sup] ... cancel, will yield a tautology
0.319[zip.sup] ... cancel, will yield a tautology
0.319[zip.env] apply binary rule superposition_passive
0.325[zip.sup] ... cancel, will yield a tautology
0.325[zip.sup] ... cancel, will yield a tautology
0.332[zip.sup] ... cancel, will yield a tautology
0.332[zip.sup] ... cancel, will yield a tautology
0.332[zip.sup] ... cancel, will yield a tautology
0.332[zip.sup] ... cancel, will yield a tautology
0.359[zip.env] apply binary rule ctx_narrow
0.359[zip.env] apply binary rule narrow_term_defs
0.359[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53`...
0.359[zip.env] do unary inferences
0.359[zip.env] apply unary rule equality_resolution
0.359[zip.env] apply unary rule equality_factoring
0.359[zip.env] apply unary rule narrow_lit_defs
0.360[zip.env] apply unary rule ind_types.exhaustiveness
0.360[zip.env] apply unary rule ind_types.acyclicity
0.360[zip.env] apply unary rule ho_prim_enum
0.360[zip.env] apply unary rule neg_ext
0.360[zip.env] apply unary rule ho_ext_pos
0.360[zip.env] apply unary rule ho_complete_eq
0.360[zip.env] apply unary rule avatar_check_empty
0.360[zip.env] apply generating rule avatar.lemmas (full: false)
0.360[zip.env] apply generating rule avatar_check_sat (full: false)
0.360[zip.avatar] SAT-solver reports "SAT"
0.360[zip.saturate] inferred new clauses: []
[K[0.36s]  30 steps0.360[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99`...
0.360[unif]
    (flex_flex_matching `X-1279 Y-2, Y-1`[0] `X1 Y-2, Y-1`[0]
     :subst {F-1278[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1279[0], 
             F2[1] → F-1278[0]}
     :bvars {[ι],[ι] | [ι],[ι]})
0.360[zip.sup]
    demod:
      t=(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
          (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
          F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))[0],
      l=(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
          (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
          F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))[1],
      r=false[1],
      subst={F-1279[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
             F-1278[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1279[0], 
             F2[1] → F-1278[0]}
0.361[zip.sup]
    demod:
      rewrite `(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                 F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                  (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))`
      into `false`
      using {F-1279[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
             F-1278[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1279[0], 
             F2[1] → F-1278[0]}[1]
0.361[zip.sup]
    demodulate
      forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
      [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
           F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99
      into [Τ*]/101
      using {(forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
              [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                   (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                   F1
                    (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                    (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53
              :subst {F-1279[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
                      F-1278[0] → F2[0], 
                      A0[1] → A0[0], 
                      F1[1] → F-1279[0], 
                      F2[1] → F-1278[0]}[1])}
0.361[zip.sup] @[neg_reflect did not simplify the clause @]
0.361[zip.sup] @[neg_reflect did not simplify the clause @]
0.361[zip.env] rewrite clause `[Τ*]/101`...
0.361[zip.env]
    clause `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
            [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                 F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                  (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99`
    simplified into `[Τ*]/101`
0.361[zip.env] rewrite clause `[Τ*]/101`...
0.361[zip.sup] @[neg_reflect did not simplify the clause @]
0.361[zip.env] rewrite clause `[Τ*]/101`...
0.361[zip.sup] [Τ*]/101 is a tautology
0.361[zip.saturate]
    given clause forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
                 [¬(F2
                      (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                      (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1))))
                      =
                      F1
                       (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                       (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/99
      is redundant
[K[0.36s]  31 steps0.361[zip.env]
    rewrite clause
      `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
       [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
            F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
             (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100`...
0.361[unif]
    (flex_flex_matching `X-1284 Y-2, Y-1`[0] `X1 Y-2, Y-1`[0]
     :subst {F-1283[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1284[0], 
             F2[1] → F-1283[0]}
     :bvars {[ι],[ι] | [ι],[ι]})
0.362[zip.sup]
    demod:
      t=(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
          (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
          F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))[0],
      l=(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
          (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
          F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))[1],
      r=false[1],
      subst={F-1284[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
             F-1283[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1284[0], 
             F2[1] → F-1283[0]}
0.362[zip.sup]
    demod:
      rewrite `(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                 F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                  (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))`
      into `false`
      using {F-1284[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
             F-1283[0] → F2[0], 
             A0[1] → A0[0], 
             F1[1] → F-1284[0], 
             F2[1] → F-1283[0]}[1]
0.362[zip.sup]
    demodulate
      forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
      [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
           F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100
      into [Τ*]/102
      using {(forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
              [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                   (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                   F1
                    (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                    (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53
              :subst {F-1284[0] → λ (Y0:ι) (Y1:ι). (F1 Y0 Y1)[0], 
                      F-1283[0] → F2[0], 
                      A0[1] → A0[0], 
                      F1[1] → F-1284[0], 
                      F2[1] → F-1283[0]}[1])}
0.362[zip.sup] @[neg_reflect did not simplify the clause @]
0.362[zip.sup] @[neg_reflect did not simplify the clause @]
0.362[zip.env] rewrite clause `[Τ*]/102`...
0.362[zip.env]
    clause `forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
            [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
                 F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                  (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100`
    simplified into `[Τ*]/102`
0.362[zip.env] rewrite clause `[Τ*]/102`...
0.362[zip.sup] @[neg_reflect did not simplify the clause @]
0.362[zip.env] rewrite clause `[Τ*]/102`...
0.362[zip.sup] [Τ*]/102 is a tautology
0.362[zip.saturate]
    given clause forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
                 [¬(F2
                      (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                      (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1))))
                      =
                      F1
                       (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
                       (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/100
      is redundant
[K[0.36s]  32 steps0.363[zip.env] apply generating rule avatar.lemmas (full: true)
0.363[zip.env] apply generating rule avatar_check_sat (full: true)
0.363[zip.msat] check_real
0.363[zip.avatar] SAT-solver reports "SAT"
# done 32 iterations in 0.363s
0.363[zip]
    final precedence:
      [sk_A < current_world < individuals < prop_a < prop_b < prop_c < 
         mimpl < mand < mbox < mnot < mor < mvalid < mall < 
         mcountersatisfiable < mdia < mexists < mfalse < miff < minvalid < 
         msatisfiable < mtrue]
0.363[zip] terminate phase saturate
0.363[zip] start phase print_result
# SZS status GaveUp for '/home/petar/Documents/tptp/Problems/LCL/LCL594^1.p'
0.363[zip]
    saturated set:
      forall (F0:ι → ι → prop). [¬sk_A F0 (sk_X-84 F0)*]/13 
      forall (F0:ι → ι → prop) X1.
      [sk_A F0 X1* ∨ ¬F0 (sk_X-84 F0) X1*]/14 
      forall (F0:ι → ι → prop). [¬F0 (sk_X-84 F0) (sk_X-84 F0)*]/34 
      forall X0 A1 (F2:ι → ι → A1) (F3:ι → ι → A1).
      [sk_A (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1))) X0* ∨ 
       ¬(F3 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0 =
           F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F3 Y0 Y1 = F2 Y0 Y1)))) X0)*]/43 
      forall A0 (F1:ι → ι → A0) (F2:ι → ι → A0).
      [¬(F2 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
           (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) =
           F1 (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))) 
            (sk_X-84 (λ (Y0:ι) (Y1:ι). ((F2 Y0 Y1 = F1 Y0 Y1)))))*]/53
0.363[zip] terminate phase print_result
0.363[zip] start phase print_dot
0.363[zip] terminate phase print_dot
0.363[zip] start phase check_proof
0.363[zip] terminate phase check_proof
0.363[zip] start phase print_stats
0.363[zip] terminate phase print_stats
0.363[zip] start phase exit
0.363[zip] terminate phase exit
0.363[zip] run time: 0.363
