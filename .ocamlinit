#use "topfind";;
#require "datalog";;
#require "num";;
#require "unix";;
#require "dynlink";;
#require "logtk";;
#require "logtk.meta";;
#directory "_build/containers/"
#directory "_build/src/"
#load "libzipperposition.cma";;
(* TODO: find a way to source logtk's ocamlinit *)
(* pretty printing *)
open Logtk;;
open Libzipperposition;;
open Logtk.Sequence.Infix;;
open Logtk.Type;;
#install_printer FOTerm.fmt;;
#install_printer HOTerm.fmt;;
#install_printer Literal.fmt;;
#install_printer Clause.fmt;;
#install_printer FOFormula.fmt;;
#install_printer Untyped.FO.fmt;;
#install_printer Untyped.Form.fmt;;
#install_printer Untyped.HO.fmt;;
#install_printer Type.Parsed.fmt;;
#install_printer Substs.FO.fmt;;
#install_printer Substs.HO.fmt;;
#install_printer Proof.fmt;;
#install_printer Symbol.fmt;;
#install_printer Signature.fmt;;
#install_printer Type.fmt;;
#install_printer Monome.fmt;;
module T = Logtk.FOTerm;;
module F = Logtk.FOFormula;;
module M = Monome;;
let pterm s =
    let t = Parse_tptp.parse_term Lex_tptp.token (Lexing.from_string s) in
    let tyctx = TypeInference.Ctx.create ~base:true () in
    let _, clos = TypeInference.FO.infer tyctx t 0 in
    let renaming = Substs.Ty.Renaming.create 5 in
    TypeInference.Ctx.apply_closure ~renaming tyctx clos
;;
let pform s =
    let f = Parse_tptp.parse_formula Lex_tptp.token (Lexing.from_string s) in
    let tyctx = TypeInference.Ctx.create ~base:true () in
    TypeInference.FO.convert_form ~ctx:tyctx f
;;
Printf.printf "finished loading\n";;
(* vim:syntax=ocaml
*)
