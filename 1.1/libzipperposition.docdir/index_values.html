<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="ClauseQueue" rel="Chapter" href="ClauseQueue.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="SClause" rel="Chapter" href="SClause.html">
<link title="Const" rel="Chapter" href="Const.html">
<link title="Extensions" rel="Chapter" href="Extensions.html">
<link title="Ctx" rel="Chapter" href="Ctx.html">
<link title="Proof" rel="Chapter" href="Proof.html">
<link title="ProofState" rel="Chapter" href="ProofState.html">
<link title="Saturate" rel="Chapter" href="Saturate.html">
<link title="Selection" rel="Chapter" href="Selection.html">
<link title="AC" rel="Chapter" href="AC.html">
<link title="AC_intf" rel="Chapter" href="AC_intf.html">
<link title="SimplM" rel="Chapter" href="SimplM.html">
<link title="Params" rel="Chapter" href="Params.html">
<link title="Env" rel="Chapter" href="Env.html">
<link title="Signals" rel="Chapter" href="Signals.html">
<link title="Classify_cst" rel="Chapter" href="Classify_cst.html">
<link title="Ctx_intf" rel="Chapter" href="Ctx_intf.html">
<link title="Clause_intf" rel="Chapter" href="Clause_intf.html">
<link title="Env_intf" rel="Chapter" href="Env_intf.html">
<link title="ProofState_intf" rel="Chapter" href="ProofState_intf.html">
<link title="BBox" rel="Chapter" href="BBox.html">
<link title="ClauseContext" rel="Chapter" href="ClauseContext.html">
<link title="ClauseQueue_intf" rel="Chapter" href="ClauseQueue_intf.html">
<link title="Bool_lit" rel="Chapter" href="Bool_lit.html">
<link title="Bool_lit_intf" rel="Chapter" href="Bool_lit_intf.html">
<link title="Sat_solver" rel="Chapter" href="Sat_solver.html">
<link title="Sat_solver_intf" rel="Chapter" href="Sat_solver_intf.html">
<link title="Trail" rel="Chapter" href="Trail.html">
<link title="Ind_cst" rel="Chapter" href="Ind_cst.html">
<link title="Cover_set" rel="Chapter" href="Cover_set.html">
<link title="Cut_form" rel="Chapter" href="Cut_form.html">
<link title="Phases" rel="Chapter" href="Phases.html">
<link title="Phases_impl" rel="Chapter" href="Phases_impl.html">
<link title="Avatar" rel="Chapter" href="Avatar.html">
<link title="Avatar_intf" rel="Chapter" href="Avatar_intf.html">
<link title="Induction" rel="Chapter" href="Induction.html">
<link title="Induction_intf" rel="Chapter" href="Induction_intf.html">
<link title="Superposition" rel="Chapter" href="Superposition.html">
<link title="Superposition_intf" rel="Chapter" href="Superposition_intf.html">
<link title="Rewriting" rel="Chapter" href="Rewriting.html">
<link title="EnumTypes" rel="Chapter" href="EnumTypes.html">
<link title="Arith_int" rel="Chapter" href="Arith_int.html">
<link title="Arith_rat" rel="Chapter" href="Arith_rat.html">
<link title="Heuristics" rel="Chapter" href="Heuristics.html">
<link title="Ind_types" rel="Chapter" href="Ind_types.html">
<link title="Fool" rel="Chapter" href="Fool.html"><title>Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL( ** )">( ** )</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "and"
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL(++)">(++)</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "or"
</div>
</td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.Infix.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="SimplM.Infix.html">SimplM.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VAL(>>=)">(&gt;&gt;=)</a> [<a href="SimplM.html">SimplM</a>]</td>
<td><div class="info">
Monadic bind
</div>
</td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>>?=)">(&gt;&gt;?=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.Infix.html#VAL(>|=)">(&gt;|=)</a> [<a href="Phases.Infix.html">Phases.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.Infix.html#VAL(>|=)">(&gt;|=)</a> [<a href="SimplM.Infix.html">SimplM.Infix</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VAL(~~)">(~~)</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "not"
</div>
</td></tr>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALabs">abs</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Literal without its sign
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALadapt_c">adapt_c</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALadapt_f">adapt_f</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALadd">add</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALadd">add</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Declare that the given symbol is AC, and update the Env subsequently
      by adding clauses, etc.
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALadd">add</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
Add clauses to the set
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALadd">add</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Add a clause to the Queue
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_active">add_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add active clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_active_simplify">add_active_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification w.r.t active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_backward_redundant">add_backward_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add rule that finds redundant clauses within active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_backward_simplify">add_backward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification of the active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_binary_inf">add_binary_inf</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a binary inference rule
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clause">add_clause</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
<code class="code">add_clause ~tag ~proof c</code> adds the constraint <code class="code">c</code> to the SAT solver,
      annotated with <code class="code">proof</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_clause_conversion">add_clause_conversion</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clause_seq">add_clause_seq</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALadd_clauses">add_clauses</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALadd_from_hook">add_from_hook</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_generate">add_generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALadd_imply">add_imply</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
<code class="code">add_imply l res</code> means that the conjunction of lemmas in <code class="code">l</code>
      implies that the lemma <code class="code">res</code> is proven
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_is_trivial">add_is_trivial</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add tautology detection rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_is_trivial_trail">add_is_trivial_trail</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add tautology detection rule
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALadd_lemma">add_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Add the given cut to the list of lemmas.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALadd_list">add_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_lit_rule">add_lit_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a literal rewrite rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_multi_simpl_rule">add_multi_simpl_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a multi-clause simplification rule
</div>
</td></tr>
<tr><td><a href="Params.html#VALadd_opt">add_opt</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALadd_opts">add_opts</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_passive">add_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add passive clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_redundant">add_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add redundancy criterion w.r.t.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_rewrite_rule">add_rewrite_rule</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a term rewrite rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_rw_simplify">add_rw_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add forward rewriting rule
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALadd_seq">add_seq</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Add clauses to the queue
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALadd_signature">add_signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Merge  the given signature with the context's one
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_simpl">add_simpl</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add simplification clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_simplify">add_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add basic simplification rule
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_step_init">add_step_init</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
add a function to call before each saturation step
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALadd_to_hook">add_to_hook</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALadd_unary_inf">add_unary_inf</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Add a unary inference rule
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALafter_check_sat">after_check_sat</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALall_proved">all_proved</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Set of (signed) proved literals
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALall_simplify">all_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Use all simplification rules to convert a clause into a set
      of maximally simplified clause (or <code class="code">[]</code> if they are all trivial).
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALalmost_bfs">almost_bfs</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Half FIFO, half default
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALalways">always</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
All literals
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALapp_list">app_list</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALapply">apply</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
<code class="code">apply c t</code> fills the hole of <code class="code">c</code> with the given term <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALapply_same_scope">apply_same_scope</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Same as <a href="ClauseContext.html#VALapply"><code class="code">ClauseContext.apply</code></a>, but now variables from the context and variables
    from the term live in the same scope
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALapply_sign">apply_sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
<code class="code">apply_sign s lit</code> is <code class="code">lit</code> if <code class="code">s</code>, <code class="code">neg lit</code> otherwise
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALapply_subst">apply_subst</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.html#VALare_variant">are_variant</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td><div class="info">
Are these two cut formulas alpha-equivalent?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALarith">arith</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALas_case">as_case</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
If <code class="code">payload t = Case p</code>, then return <code class="code">Some p</code>, else return <code class="code">None</code>
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALas_graph">as_graph</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Get a graph of the proof
</div>
</td></tr>
<tr><td><a href="BBox.html#VALas_lemma">as_lemma</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALassert'">assert'</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALassert_">assert_</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.Pos.html#VALat">at</a> [<a href="Cut_form.Pos.html">Cut_form.Pos</a>]</td>
<td><div class="info">
Return the subterm at the given position, or
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Pos.html#VALat">at</a> [<a href="Clause_intf.S.Pos.html">Clause_intf.S.Pos</a>]</td>
<td></td></tr>
<tr><td><a href="Selection.html#VALavailable_selections">available_selections</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
available names for selection functions
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALaxioms">axioms</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
List of (persistent) axioms that are needed for simplifications to
      be complete for the given symbol.
</div>
</td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Env_intf.S.html#VALbackward_simplify">backward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Perform backward simplification with the given clause.
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALbasic_simplify">basic_simplify</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
basic simplifications (remove duplicate literals, trivial literals,
      destructive equality resolution...)
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALbefore_check_sat">before_check_sat</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALbfs">bfs</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
FIFO
</div>
</td></tr>
<tr><td><a href="Phases.html#VALbind">bind</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">bind state f</code> calls <code class="code">f</code> to go one step further from <code class="code">state</code>
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALby_def">by_def</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Extensions.html#VALby_name">by_name</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Get an extension by its name, if any
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_div_case_switch">canc_div_case_switch</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Eliminate negative divisibility literals within a power-of-prime
      quotient of Z:
      not (d^i | m) -----&gt;
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_div_chaining">canc_div_chaining</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Chain together two divisibility literals, assuming they share the
      same prime
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_div_prime_decomposition">canc_div_prime_decomposition</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Eliminate divisibility literals with a non-power-of-prime
      quotient of Z (for instance  <code class="code">6 | a ---&gt; { 2 | a, 3 | a }</code>)
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_divisibility">canc_divisibility</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Infer divisibility constraints from integer equations,
      for instace   C or  2a=b ----&gt;  C or 2 | b    if a is maximal
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_equality_factoring">canc_equality_factoring</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
cancellative equality factoring
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_ineq_chaining">canc_ineq_chaining</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
cancellative inequality chaining.
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_ineq_factoring">canc_ineq_factoring</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Factoring between two inequation literals
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_less_to_lesseq">canc_less_to_lesseq</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Simplification:  a &lt; b  ----&gt; a+1 ≤ b
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_sup_active">canc_sup_active</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
cancellative superposition where given clause is active
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcanc_sup_passive">canc_sup_passive</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
cancellative superposition where given clause is passive
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALcancellation">cancellation</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
cancellation (unifies some terms on both sides of a
      comparison operator)
</div>
</td></tr>
<tr><td><a href="Arith_int.html#VALcase_switch_limit">case_switch_limit</a> [<a href="Arith_int.html">Arith_int</a>]</td>
<td><div class="info">
Positive integer: maximum width of an inequality case switch.
</div>
</td></tr>
<tr><td><a href="Cover_set.html#VALcases">cases</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td><div class="info">
Cases of the cover set
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALcheck">check</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALcheck">check</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Is the current problem satisfiable?
</div>
</td></tr>
<tr><td><a href="Params.html#VALcheck">check</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcheck_empty">check_empty</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Forbid empty clauses with trails, i.e.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcheck_satisfiability">check_satisfiability</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Checks that the SAT context is still valid
</div>
</td></tr>
<tr><td><a href="Saturate.html#VALcheck_timeout">check_timeout</a> [<a href="Saturate.html">Saturate</a>]</td>
<td><div class="info">
check whether we still have some time w.r.t timeout
</div>
</td></tr>
<tr><td><a href="Classify_cst.html#VALclassify">classify</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td><div class="info">
<code class="code">classify id</code> returns the role <code class="code">id</code> plays in inductive reasoning
</div>
</td></tr>
<tr><td><a href="Cut_form.Pos.html#VALclause_at">clause_at</a> [<a href="Cut_form.Pos.html">Cut_form.Pos</a>]</td>
<td><div class="info">
Lookup which clause the position is about, return it
      and the rest of the position.
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALclauses">clauses</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Current set of clauses
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.ActiveSet.html#VALclauses">clauses</a> [<a href="ProofState_intf.S.ActiveSet.html">ProofState_intf.S.ActiveSet</a>]</td>
<td><div class="info">
Current set of clauses
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALcombine">combine</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Combine a list of pairs <code class="code">w, coeff</code> where <code class="code">w</code> is a weight function,
        and <code class="code">coeff</code> a strictly positive number.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALcombine">combine</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Logical "and" of the given eligibility criteria.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALcomes_from_goal">comes_from_goal</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
<code class="code">true</code> iff the clause is (indirectly) deduced from a goal or lemma
</div>
</td></tr>
<tr><td><a href="Cover_set.Case.html#VALcompare">compare</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALcompare">compare</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALcompare">compare</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALcompare">compare</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALcompare">compare</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALcompare">compare</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALcompare">compare</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALcompare">compare</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.WithPos.html#VALcompare">compare</a> [<a href="Clause_intf.S.WithPos.html">Clause_intf.S.WithPos</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALcompare">compare</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Compare two terms
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALcompare">compare</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALcompare_by_result">compare_by_result</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Compare proofs by their result
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALcondensation">condensation</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
condensation
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALcontextual_literal_cutting">contextual_literal_cutting</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
contexual Literal.t cutting of the given clause by the active set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALconvert_input_statements">convert_input_statements</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Convert raw input statements into clauses, triggering
      <a href="Env_intf.S.html#VALon_input_statement"><code class="code">Env_intf.S.on_input_statement</code></a>
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALconvert_lemma">convert_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Intercepts input lemmas and converts them into clauses.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_add">cr_add</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_return">cr_return</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALcr_skip">cr_skip</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALcreate">create</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Build a new clause from the given literals.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALcreate_a">create_a</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Build a new clause from the given literals.
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALcs">cs</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.Key.html#VALcur_phase">cur_phase</a> [<a href="Phases.Key.html">Phases.Key</a>]</td>
<td><div class="info">
The current phase is stored in the state using this key
</div>
</td></tr>
<tr><td><a href="Phases.html#VALcurrent_phase">current_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Get the current phase
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_depth">cut_depth</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_form">cut_form</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_lit">cut_lit</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_pos">cut_pos</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_proof">cut_proof</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALcut_res_clauses">cut_res_clauses</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Proof.Step.html#VALdata">data</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.html#VALdebug">debug</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
debug functions: much more detailed printing
</div>
</td></tr>
<tr><td><a href="Cover_set.html#VALdeclarations">declarations</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td><div class="info">
<code class="code">declarations set</code> returns a list of type declarations that should
    be made if <code class="code">set</code> is new (declare the top cst and its subcases)
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALdeclare">declare</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Declare the type of a symbol (updates signature)
</div>
</td></tr>
<tr><td><a href="EnumTypes.S.html#VALdeclare_ty">declare_ty</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Declare that the domain of the type <code class="code">ty_id</code> is restricted to
      given list of <code class="code">cases</code>, in the form <code class="code">forall var. Or_{c in cases} var = c</code>.
</div>
</td></tr>
<tr><td><a href="Params.html#VALdef_as_rewrite">def_as_rewrite</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Extensions.html#VALdefault">default</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Default extension.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALdefault">default</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Use <code class="code">Literal.heuristic_weight</code>
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALdefault">default</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Obtain the default queue
</div>
</td></tr>
<tr><td><a href="Selection.html#VALdefault_selection">default_selection</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Default selection function
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALdepth">depth</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALdistance_to_goal">distance_to_goal</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td><div class="info">
<code class="code">distance_to_conjecture p</code> returns <code class="code">None</code> if <code class="code">p</code> has no ancestor
      that is a conjecture (including <code class="code">p</code> itself).
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALdistance_to_goal">distance_to_goal</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
See <code class="code">Proof.distance_to_goal</code>, applied to the clause's proof
</div>
</td></tr>
<tr><td><a href="Arith_int.html#VALdiv_case_switch_limit">div_case_switch_limit</a> [<a href="Arith_int.html">Arith_int</a>]</td>
<td><div class="info">
Positive integer: maximum prime number suitable for div_case_switch
    (ie maximum n for enumeration of cases in n^k | x)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_binary_inferences">do_binary_inferences</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do binary inferences that involve the given clause
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_generate">do_generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do generating inferences
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALdo_unary_inferences">do_unary_inferences</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
do unary inferences for the given clause
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALdominates">dominates</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">dominates c1 c2</code> if <code class="code">depth c1 &lt; depth c2</code>.
</div>
</td></tr>
<tr><td><a href="Params.html#VALdot_all_roots">dot_all_roots</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALdot_file">dot_file</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALdot_sat">dot_sat</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit.PAYLOAD.html#VALdummy">dummy</a> [<a href="Bool_lit.PAYLOAD.html">Bool_lit.PAYLOAD</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALdummy">dummy</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Value that should not be used
</div>
</td></tr>
<tr><td><a href="BBox.html#VALdummy">dummy</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Clause_intf.S.html#VALeligible_param">eligible_param</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Bitvector that indicates which of the literals of <code class="code">subst(clause)</code>
      are eligible for paramodulation.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALeligible_res">eligible_res</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Bitvector that indicates which of the literals of <code class="code">subst(clause)</code>
      are eligible for resolution.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALeligible_res_no_subst">eligible_res_no_subst</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
More efficient version of <a href="Clause_intf.S.html#VALeligible_res"><code class="code">Clause_intf.S.eligible_res</code></a> with <code class="code">Subst.empty</code>
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALeliminate_unshielded">eliminate_unshielded</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Eliminate unshielded variables using an adaptation of
      Cooper's algorithm
</div>
</td></tr>
<tr><td><a href="Trail.html#VALempty">empty</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALempty_state">empty_state</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Heuristics.html#VALenable_depth_limit">enable_depth_limit</a> [<a href="Heuristics.html">Heuristics</a>]</td>
<td><div class="info">
Set a maximal depth for terms.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALeq">eq</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Equations
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALeq_subsumes">eq_subsumes</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
equality subsumption
</div>
</td></tr>
<tr><td><a href="Cover_set.Case.html#VALequal">equal</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALequal">equal</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALequal">equal</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALequal">equal</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALequal">equal</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALequal">equal</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALequal">equal</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALequal">equal</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALesa">esa</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALexists">exists</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALexists_ac">exists_ac</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Is there any AC symbol?
</div>
</td></tr>
<tr><td><a href="Phases.html#VALexit">exit</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Exit
</div>
</td></tr>
<tr><td><a href="Params.html#VALexpand_def">expand_def</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALexplore">explore</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Use heuristics for selecting "small" clauses
</div>
</td></tr>
<tr><td><a href="Fool.html#VALextension">extension</a> [<a href="Fool.html">Fool</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_types.html#VALextension">extension</a> [<a href="Ind_types.html">Ind_types</a>]</td>
<td></td></tr>
<tr><td><a href="Heuristics.html#VALextension">extension</a> [<a href="Heuristics.html">Heuristics</a>]</td>
<td></td></tr>
<tr><td><a href="Arith_rat.html#VALextension">extension</a> [<a href="Arith_rat.html">Arith_rat</a>]</td>
<td></td></tr>
<tr><td><a href="Arith_int.html#VALextension">extension</a> [<a href="Arith_int.html">Arith_int</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.html#VALextension">extension</a> [<a href="EnumTypes.html">EnumTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Rewriting.html#VALextension">extension</a> [<a href="Rewriting.html">Rewriting</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.html#VALextension">extension</a> [<a href="Superposition.html">Superposition</a>]</td>
<td></td></tr>
<tr><td><a href="Induction.html#VALextension">extension</a> [<a href="Induction.html">Induction</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar.html#VALextension">extension</a> [<a href="Avatar.html">Avatar</a>]</td>
<td><div class="info">
Extension that enables Avatar splitting and create a new SAT-solver.
</div>
</td></tr>
<tr><td><a href="AC.html#VALextension">extension</a> [<a href="AC.html">AC</a>]</td>
<td></td></tr>
<tr><td><a href="Extensions.html#VALextensions">extensions</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
All currently available extensions
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALextract">extract</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
<code class="code">extract lits t</code> returns <code class="code">None</code> if <code class="code">t</code> doesn't occur in <code class="code">lits</code>.
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALextract_exn">extract_exn</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Unsafe version of <a href="ClauseContext.html#VALextract"><code class="code">ClauseContext.extract</code></a>.
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Phases.html#VALfail">fail</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Fail with the given error message
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_all_neg">favor_all_neg</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Favor clauses with only negative ground lits
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_goal">favor_goal</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
The closest a clause is from the initial goal, the lowest its weight.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_ground">favor_ground</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_horn">favor_horn</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALfavor_non_all_neg">favor_non_all_neg</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Favor clauses that have at least one non-(ground negative) lit
</div>
</td></tr>
<tr><td><a href="Params.html#VALfiles">files</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALfilter">filter</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Only keep a subset of boolean literals
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALfilter">filter</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALfilter_absurd_trails">filter_absurd_trails</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
<code class="code">filter_trails f</code> calls <code class="code">f</code> on every trail associated with the empty
      clause.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALfind_ind_skolems">find_ind_skolems</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">find_ind_skolem term</code> searches subterms of <code class="code">term</code> for constants
    that are of an inductive type and that are skolems or
    (already) inductive constants.
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALfind_proof">find_proof</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Recover the proof for the AC-property of this symbol.
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALfind_signature">find_signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Find the type of the given symbol
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALfind_signature_exn">find_signature_exn</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Unsafe version of <a href="Ctx_intf.S.html#VALfind_signature"><code class="code">Ctx_intf.S.find_signature</code></a>.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_backward_simplified">flag_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause has been backward simplified
</div>
</td></tr>
<tr><td><a href="Avatar.html#VALflag_cut_introduced">flag_cut_introduced</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALflag_lemma">flag_lemma</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause is a lemma
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_persistent">flag_persistent</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause cannot be redundant
</div>
</td></tr>
<tr><td><a href="SClause.html#VALflag_redundant">flag_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
clause has been shown to be redundant
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_add">flex_add</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
add <code class="code">k -&gt; v</code> to the flex state
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_get">flex_get</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
<code class="code">flex_get k</code> is the same as <code class="code">Flex_state.get_exn k (flex_state ())</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALflex_state">flex_state</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
State inherited from configuration
</div>
</td></tr>
<tr><td><a href="Trail.html#VALfold">fold</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALfold_l">fold_l</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALfold_l">fold_l</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALfor_all">for_all</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALforward_simplify">forward_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Simplify the clause w.r.t to the active set and experts
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALfresh_id">fresh_id</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Make a fresh ID.
</div>
</td></tr>
<tr><td><a href="Proof.Parent.html#VALfrom">from</a> [<a href="Proof.Parent.html">Proof.Parent</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALfrom_hooks">from_hooks</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Parent.html#VALfrom_subst">from_subst</a> [<a href="Proof.Parent.html">Proof.Parent</a>]</td>
<td></td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Env_intf.S.html#VALgenerate">generate</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Perform all generating inferences
</div>
</td></tr>
<tr><td><a href="Phases.html#VALget">get</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALget">get</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALget_active">get_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Active clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALget_empty_clauses">get_empty_clauses</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Set of known empty clauses
</div>
</td></tr>
<tr><td><a href="Avatar.html#VALget_env">get_env</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALget_flag">get_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
get value of boolean flag
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALget_flag">get_flag</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
get value of boolean flag
</div>
</td></tr>
<tr><td><a href="Phases.html#VALget_key">get_key</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">get_key k</code> returns the value associated with <code class="code">k</code> in the state
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALget_passive">get_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Passive clauses
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALget_profile">get_profile</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALget_proof">get_proof</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Return a proof of <code class="code">false</code>, assuming <a href="Sat_solver_intf.S.html#VALcheck"><code class="code">Sat_solver_intf.S.check</code></a> returned <code class="code">Unsat</code>.
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALget_proof_of_lit">get_proof_of_lit</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
<code class="code">get_proof_of_lit lit</code> returns the proof of <code class="code">lit</code>, assuming it has been
      proved true at level 0 (see <a href="Sat_solver_intf.S.html#VALvaluation_level"><code class="code">Sat_solver_intf.S.valuation_level</code></a>)
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALget_proof_opt">get_proof_opt</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Obtain the proof, if any
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALget_some_empty_clause">get_some_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Some empty clause, if present, otherwise None
</div>
</td></tr>
<tr><td><a href="Saturate.S.html#VALgiven_clause">given_clause</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
run the given clause until a timeout occurs or a result
      is found.
</div>
</td></tr>
<tr><td><a href="Saturate.S.html#VALgiven_clause_step">given_clause_step</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
Perform one step of the given clause algorithm.
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALgoal">goal</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALgoal'">goal'</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALgoal_oriented">goal_oriented</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
custom weight function that favors clauses that are "close" to
      initial conjectures.
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALground">ground</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Favor positive unit clauses and ground clauses
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALhandle_distinct_constants">handle_distinct_constants</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
Decide on "quoted" "symbols" (which are all distinct)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALhas_empty_clause">has_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is there an empty clause?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALhas_selected_lits">has_selected_lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
does the clause have some selected literals?
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALhas_trail">has_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Has a non-empty trail?
</div>
</td></tr>
<tr><td><a href="Cover_set.Case.html#VALhash">hash</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALhash">hash</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALhash">hash</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALhash">hash</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALhash">hash</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALhash">hash</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALhash">hash</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALhash">hash</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Const.html#VALhome">home</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Ind_cst.html#VALid">id</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALid">id</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALid">id</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALid_as_cst">id_as_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALid_as_cst_exn">id_as_cst_exn</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Unsafe version of <code class="code">as_cst</code>
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALid_is_cst">id_is_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Check whether the given constant is an inductive constant
</div>
</td></tr>
<tr><td><a href="Classify_cst.html#VALid_is_cstor">id_is_cstor</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Classify_cst.html#VALid_is_defined">id_is_defined</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALid_is_ind_skolem">id_is_ind_skolem</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
<code class="code">id_is_potential_cst id ty</code> returns <code class="code">true</code> if <code class="code">id:ty</code> is
    a skolem constant of an inductive type, or
    if it is already an inductive constant.
</div>
</td></tr>
<tr><td><a href="Classify_cst.html#VALid_is_projector">id_is_projector</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALid_is_sub">id_is_sub</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition_intf.S.html#VALidx_fv">idx_fv</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
index for subsumption
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALidx_sup_from">idx_sup_from</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
index for superposition from the set
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALidx_sup_into">idx_sup_into</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
index for superposition into the set
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALind_skolem_compare">ind_skolem_compare</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALind_skolem_depth">ind_skolem_depth</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
depth of the skolem (0 if not an inductive constant)
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALind_skolem_equal">ind_skolem_equal</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.html#VALind_vars">ind_vars</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td><div class="info">
subset of <a href="Cut_form.html#VALvars"><code class="code">Cut_form.vars</code></a> that have an inductive type
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALinfer_active">infer_active</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
superposition where given clause is active
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALinfer_equality_factoring">infer_equality_factoring</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition_intf.S.html#VALinfer_equality_resolution">infer_equality_resolution</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition_intf.S.html#VALinfer_passive">infer_passive</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
superposition where given clause is passive
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALinference">inference</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALinject_case">inject_case</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Inject <code class="code">cst = case</code>
</div>
</td></tr>
<tr><td><a href="BBox.html#VALinject_lemma">inject_lemma</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Make a new literal from this formula that we are going to cut
    on.
</div>
</td></tr>
<tr><td><a href="BBox.html#VALinject_lits">inject_lits</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Inject a clause into a boolean literal.
</div>
</td></tr>
<tr><td><a href="EnumTypes.S.html#VALinstantiate_vars">instantiate_vars</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Instantiate variables whose type is a known enumerated type,
      with all cases of this type.
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALintroduce_cut">introduce_cut</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Introduce a cut on the given clause(s).
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALis_ac">is_ac</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALis_active">is_active</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
<code class="code">Trail.is_active t ~v</code> is true iff all boolean literals
    in <code class="code">t</code> are satisfied in the boolean valuation <code class="code">v</code>.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_active">is_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the clause in the active set
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_active">is_active</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
True if the clause's trail is active in this valuation
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALis_assert">is_assert</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td><div class="info">
Proof: the statement was asserted in some file
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_backward_simplified">is_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_backward_simplified">is_backward_simplified</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALis_base">is_base</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALis_by_def">is_by_def</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALis_case">is_case</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALis_completeness_preserved">is_completeness_preserved</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Check whether completeness was preserved so far
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_eligible_param">is_eligible_param</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Check whether the <code class="code">idx</code>-th literal is eligible for paramodulation
</div>
</td></tr>
<tr><td><a href="Trail.html#VALis_empty">is_empty</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Empty trail?
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_empty">is_empty</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_empty">is_empty</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the clause an empty clause?
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALis_empty">is_empty</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
check whether the queue is empty
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALis_goal">is_goal</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td><div class="info">
The statement comes from the negation of a goal in some file
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_goal">is_goal</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Looking at the clause's proof, return <code class="code">true</code> iff the clause is an
      initial (negated) goal from the problem
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_ground">is_ground</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALis_lemma">is_lemma</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
returns <code class="code">true</code> if the bool literal represents a lemma
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_maxlit">is_maxlit</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the i-th literal maximal in subst(clause)? Equivalent to
      Bitvector.get (maxlits ~ord c subst) i
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALis_new">is_new</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_oriented_rule">is_oriented_rule</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Is the clause a positive oriented clause?
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_passive">is_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the clause a passive clause?
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALis_proof_of_false">is_proof_of_false</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALis_rec">is_rec</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALis_redundant">is_redundant</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Is the given clause redundant w.r.t the active set?
</div>
</td></tr>
<tr><td><a href="SClause.html#VALis_redundant">is_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_redundant">is_redundant</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALis_same">is_same</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_selected">is_selected</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
check whether a literal is selected
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALis_semantic_tautology">is_semantic_tautology</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
semantic tautology deletion, using a congruence closure algorithm
      to see if negative literals imply some positive Literal.t
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALis_sub">is_sub</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Is the constant a sub-constant (i.e.
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALis_tautology">is_tautology</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
is the clause a tautology w.r.t linear expressions?
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALis_tautology">is_tautology</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
Check whether the clause is a (syntactic) tautology, ie whether
      it contains true or "A" and "not A"
</div>
</td></tr>
<tr><td><a href="Trail.html#VALis_trivial">is_trivial</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
returns <code class="code">true</code> iff the trail contains both <code class="code">i</code> and <code class="code">-i</code>.
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALis_trivial">is_trivial</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Check whether the clause is AC-trivial
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_trivial">is_trivial</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Check whether the clause is trivial
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALis_trivial">is_trivial</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALis_trivial_lit">is_trivial_lit</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Is the literal AC-trivial?
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALis_trivial_trail">is_trivial_trail</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Check whether the trail is trivial
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALis_unit_clause">is_unit_clause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
is the clause a unit clause?
</div>
</td></tr>
<tr><td align="left"><br>K</td></tr>
<tr><td><a href="Avatar.html#VALk_avatar">k_avatar</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar.html#VALk_simplify_trail">k_simplify_trail</a> [<a href="Avatar.html">Avatar</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition.html#VALkey">key</a> [<a href="Superposition.html">Superposition</a>]</td>
<td><div class="info">
key to access the <code class="code">Env.flex_state</code>.
</div>
</td></tr>
<tr><td><a href="Params.html#VALkey">key</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="AC.html#VALkey_ac">key_ac</a> [<a href="AC.html">AC</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALkind">kind</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Trail.html#VALlabels">labels</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALlast_result">last_result</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Last computed result.
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALlemma">lemma</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALlength">length</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALlength">length</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALlength">length</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Number of literals
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALlength">length</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Number of elements
</div>
</td></tr>
<tr><td><a href="Cut_form.Pos.html#VALlit_at">lit_at</a> [<a href="Cut_form.Pos.html">Cut_form.Pos</a>]</td>
<td><div class="info">
Lookup which literal the position is about, return it
      and the rest of the position.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALlits">lits</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALlits">lits</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALlits">lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Phases_impl.html#VALload_extensions">load_extensions</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.Key.html#VALlost_completeness">lost_completeness</a> [<a href="Ctx.Key.html">Ctx.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALlost_completeness">lost_completeness</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
To be called when completeness is not preserved
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="Cut_form.html#VALmake">make</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.html#VALmake">make</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td><div class="info">
Build a cover set for the given type.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALmake">make</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Make a new constant of the given type
</div>
</td></tr>
<tr><td><a href="ClauseContext.html#VALmake">make</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Make a context from a var and literals containing this var.
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALmake">make</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Make a fresh literal with the given payload
</div>
</td></tr>
<tr><td><a href="SClause.html#VALmake">make</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALmake">make</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Bring your own implementation of queue.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALmake_skolem">make_skolem</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALmap">map</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Map the current value
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmap">map</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALmap">map</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALmap_l">map_l</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALmark_backward_simplified">mark_backward_simplified</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALmark_backward_simplified">mark_backward_simplified</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALmark_redundant">mark_redundant</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALmark_redundant">mark_redundant</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALmax">max</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Maximal literals of the clause
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALmaxlits">maxlits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
List of maximal literals
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmem">mem</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALmerge">merge</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Merge several trails (e.g.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALmerge_l">merge_l</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
Merge several trails (e.g.
</div>
</td></tr>
<tr><td><a href="Proof.Rule.html#VALmk">mk</a> [<a href="Proof.Rule.html">Proof.Rule</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_bc">mk_bc</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_c">mk_c</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_f">mk_f</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Constructors and utils
      In all the following constructors, <code class="code">theories</code> defaults to the empty list.
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALmk_f_by_def">mk_f_by_def</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_f_esa">mk_f_esa</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_f_inference">mk_f_inference</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_f_simp">mk_f_simp</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_f_trivial">mk_f_trivial</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALmk_stmt">mk_stmt</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Rule.html#VALmkf">mkf</a> [<a href="Proof.Rule.html">Proof.Rule</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALmulti_simplify">multi_simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Can we simplify the clause into a List of simplified clauses?
</div>
</td></tr>
<tr><td><a href="BBox.html#VALmust_be_kept">must_be_kept</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
<code class="code">must_be_kept lit</code> means that <code class="code">lit</code> should survive in boolean splitting,
    that is, that if <code class="code">C &lt;- lit, Gamma</code> then any clause derived from <code class="code">C</code>
    recursively will have <code class="code">lit</code> in its trail.
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="Proof.Rule.html#VALname">name</a> [<a href="Proof.Rule.html">Proof.Rule</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALname">name</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Name of the implementation/role of the queue
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALnames">names</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Names of loaded extensions
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALneg">neg</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Negate the boolean literal
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALneg">neg</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only negative literals
</div>
</td></tr>
<tr><td><a href="SClause.html#VALnew_flag">new_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
new flag that can be used on clauses
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALnext">next</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Get-and-remove the next passive clause to process
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALnext_passive">next_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Extract next passive clause
</div>
</td></tr>
<tr><td><a href="Selection.html#VALno_select">no_select</a> [<a href="Selection.html">Selection</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALnorm">norm</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
<code class="code">norm l = abs l, not (sign l)</code>
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALnormalize">normalize</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td><div class="info">
Use rewriting to normalize the formula
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALnum_clauses">num_clauses</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.ActiveSet.html#VALnum_clauses">num_clauses</a> [<a href="ProofState_intf.S.ActiveSet.html">ProofState_intf.S.ActiveSet</a>]</td>
<td></td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALof_form">of_form</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_forms">of_forms</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Directly from list of formulas
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_forms_axiom">of_forms_axiom</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Construction from formulas as axiom (initial clause)
</div>
</td></tr>
<tr><td><a href="Trail.html#VALof_list">of_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALof_profile">of_profile</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Select the queue corresponding to the given profile
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_sclause">of_sclause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALof_statement">of_statement</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Extract a clause from a statement, if any
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALon_add">on_add</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALon_add_clause">on_add_clause</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
signal triggered when a clause is added to the set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALon_empty_clause">on_empty_clause</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Signal triggered when an empty clause is found
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALon_input_lemma">on_input_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Triggered every time a cut is introduced  for an input lemma
      (i.e.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALon_input_statement">on_input_statement</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Triggered on every input statement
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALon_lemma">on_lemma</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Triggered every time a cut is introduced, by any means.
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALon_new_cst">on_new_cst</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Triggered with new inductive constants
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALon_new_symbol">on_new_symbol</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALon_remove_clause">on_remove_clause</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
signal triggered when a clause is removed from the set
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALon_signature_update">on_signature_update</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALon_start">on_start</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Triggered before starting saturation
</div>
</td></tr>
<tr><td><a href="Params.html#VALord">ord</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALord">ord</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALord">ord</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALord">ord</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
current ordering on terms
</div>
</td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALparam">param</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only literals that are eligible for paramodulation
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALparams">params</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALparents">parents</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALparse_args">parse_args</a> [<a href="Params.html">Params</a>]</td>
<td><div class="info">
parse_args returns parameters
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALparse_cli">parse_cli</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Parses the file list and parameters, also puts the parameters in
    the state
</div>
</td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALpayload">payload</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Obtain the payload
</div>
</td></tr>
<tr><td><a href="BBox.html#VALpayload">payload</a> [<a href="BBox.html">BBox</a>]</td>
<td><div class="info">
Obtain the payload of this boolean literal, that is, what the literal
    represents
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.WeightFun.html#VALpenalty">penalty</a> [<a href="ClauseQueue_intf.S.WeightFun.html">ClauseQueue_intf.S.WeightFun</a>]</td>
<td><div class="info">
Returns the penalty of the clause
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALpenalty">penalty</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALpos">pos</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only positive literals
</div>
</td></tr>
<tr><td><a href="Cover_set.Case.html#VALpp">pp</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.html#VALpp">pp</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALpp">pp</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALpp">pp</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALpp">pp</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALpp">pp</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALpp">pp</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.html#VALpp">pp</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
pretty print the content of the state
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALpp">pp</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Prints the proof according to the given input switch
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALpp">pp</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Result.html#VALpp">pp</a> [<a href="Proof.Result.html">Proof.Result</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Kind.html#VALpp">pp</a> [<a href="Proof.Kind.html">Proof.Kind</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Rule.html#VALpp">pp</a> [<a href="Proof.Rule.html">Proof.Rule</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp">pp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.WithPos.html#VALpp">pp</a> [<a href="Clause_intf.S.WithPos.html">Clause_intf.S.WithPos</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp">pp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALpp">pp</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALpp_bclause">pp_bclause</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALpp_cut_res">pp_cut_res</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.S.html#VALpp_decl">pp_decl</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALpp_dot">pp_dot</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Pretty print the proof as a DOT graph
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALpp_dot_file">pp_dot_file</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
print to dot into a file
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALpp_dot_seq">pp_dot_seq</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Print a set of proofs as a DOT graph, sharing common subproofs
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALpp_dot_seq_file">pp_dot_seq_file</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
same as <a href="Proof.S.html#VALpp_dot_seq"><code class="code">Proof.S.pp_dot_seq</code></a> but into a file
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALpp_full">pp_full</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALpp_normal">pp_normal</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALpp_notrec">pp_notrec</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Non recursive printing on formatter
</div>
</td></tr>
<tr><td><a href="BBox.html#VALpp_payload">pp_payload</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Classify_cst.html#VALpp_res">pp_res</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALpp_result_of">pp_result_of</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_set">pp_set</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_set_tstp">pp_set_tstp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Classify_cst.html#VALpp_signature">pp_signature</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td><div class="info">
Print classification of signature
</div>
</td></tr>
<tr><td><a href="SClause.html#VALpp_trail">pp_trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_trail">pp_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Printer for boolean trails, that uses <a href="Clause_intf.S.Ctx.html"><code class="code">Clause_intf.S.Ctx</code></a> to display boxes
</div>
</td></tr>
<tr><td><a href="SClause.html#VALpp_trail_tstp">pp_trail_tstp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.html#VALpp_tstp">pp_tstp</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALpp_tstp">pp_tstp</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp_tstp">pp_tstp</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_tstp">pp_tstp</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALpp_tstp_full">pp_tstp_full</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
Print in a toplevel TPTP statement
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALpp_tstp_full">pp_tstp_full</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Print in a cnf() statement
</div>
</td></tr>
<tr><td><a href="SClause.html#VALpp_vars">pp_vars</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Classify_cst.html#VALprec_constr">prec_constr</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td><div class="info">
Partial order on <code class="code">ID.t</code>, with:
    regular &gt; constant &gt; sub_constant &gt; cstor
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALprecedence">precedence</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALpresaturate">presaturate</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Saturate.S.html#VALpresaturate">presaturate</a> [<a href="Saturate.S.html">Saturate.S</a>]</td>
<td><div class="info">
Interreduction of the given state, without generating inferences.
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALprint">print</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Printing of results
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALprint_lemmas">print_lemmas</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
print the current list of lemmas, and their status
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALprocess_file">process_file</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
<code class="code">process_file f</code> parses <code class="code">f</code>, does the preprocessing phases, including
    type inference, choice of precedence, ordering, etc.
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALprocess_files_and_print">process_files_and_print</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td><div class="info">
Process each file in the list successively, printing the results.
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALprofile_of_string">profile_of_string</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td><div class="info">
</div>
</td></tr>
<tr><td><a href="Proof.Parent.html#VALproof">proof</a> [<a href="Proof.Parent.html">Proof.Parent</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof">proof</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Obtain the pair <code class="code">conclusion, step</code>
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof_parent">proof_parent</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof_parent_subst">proof_parent_subst</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALproof_step">proof_step</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Extract its proof from the clause
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALproofs">proofs</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
All proofs for all AC axioms
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALproved_at_0">proved_at_0</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
If the literal has been propagated at decision level 0,
      return its value (which does not depend on the model).
</div>
</td></tr>
<tr><td><a href="Arith_int.S.html#VALpurify">purify</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td><div class="info">
Purify clauses by replacing arithmetic expressions occurring
      under terms by variables, and adding constraints
</div>
</td></tr>
<tr><td align="left"><br>Q</td></tr>
<tr><td><a href="ProofState_intf.S.PassiveSet.html#VALqueue">queue</a> [<a href="ProofState_intf.S.PassiveSet.html">ProofState_intf.S.PassiveSet</a>]</td>
<td><div class="info">
Current state of the clause queue
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="ClauseContext.html#VALraw_lits">raw_lits</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
give access to the underlying literals.
</div>
</td></tr>
<tr><td><a href="Heuristics.S.html#VALregister">register</a> [<a href="Heuristics.S.html">Heuristics.S</a>]</td>
<td></td></tr>
<tr><td><a href="Arith_rat.S.html#VALregister">register</a> [<a href="Arith_rat.S.html">Arith_rat.S</a>]</td>
<td></td></tr>
<tr><td><a href="Arith_int.S.html#VALregister">register</a> [<a href="Arith_int.S.html">Arith_int.S</a>]</td>
<td></td></tr>
<tr><td><a href="Superposition_intf.S.html#VALregister">register</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
Register rules in the environment
</div>
</td></tr>
<tr><td><a href="Superposition.html#VALregister">register</a> [<a href="Superposition.html">Superposition</a>]</td>
<td><div class="info">
Register the superposition module to its Environment's
    mixtbl.
</div>
</td></tr>
<tr><td><a href="Induction_intf.S.html#VALregister">register</a> [<a href="Induction_intf.S.html">Induction_intf.S</a>]</td>
<td><div class="info">
Register the inference rules for inductive reasoning
</div>
</td></tr>
<tr><td><a href="Avatar_intf.S.html#VALregister">register</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Register inference rules to the environment
</div>
</td></tr>
<tr><td><a href="Selection.html#VALregister">register</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Register new selection function
</div>
</td></tr>
<tr><td><a href="Extensions.html#VALregister">register</a> [<a href="Extensions.html">Extensions</a>]</td>
<td><div class="info">
Register an extension to the (current) prover.
</div>
</td></tr>
<tr><td><a href="Trail.html#VALremove">remove</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="ProofState_intf.S.CLAUSE_SET.html#VALremove">remove</a> [<a href="ProofState_intf.S.CLAUSE_SET.html">ProofState_intf.S.CLAUSE_SET</a>]</td>
<td><div class="info">
Remove clauses from the set
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_active">remove_active</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove active clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_passive">remove_passive</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove passive clauses
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALremove_simpl">remove_simpl</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Remove simplification clauses
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALrenaming">renaming</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALrenaming_clear">renaming_clear</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Obtain the global renaming.
</div>
</td></tr>
<tr><td><a href="Cut_form.Pos.html#VALreplace">replace</a> [<a href="Cut_form.Pos.html">Cut_form.Pos</a>]</td>
<td><div class="info">
In-place modification of the array, in which the subterm at given
      position is replaced by the <code class="code">by</code> term.
</div>
</td></tr>
<tr><td><a href="Cut_form.Pos.html#VALreplace_many">replace_many</a> [<a href="Cut_form.Pos.html">Cut_form.Pos</a>]</td>
<td><div class="info">
In-place modification of the array, in which the subterm at given
      position is replaced by the <code class="code">by</code> term.
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.Eligible.html#VALres">res</a> [<a href="Clause_intf.S.Eligible.html">Clause_intf.S.Eligible</a>]</td>
<td><div class="info">
Only literals that are eligible for resolution
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALresult">result</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALreturn">return</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Return a value into the monad
</div>
</td></tr>
<tr><td><a href="SimplM.html#VALreturn">return</a> [<a href="SimplM.html">SimplM</a>]</td>
<td><div class="info">
Alias to <a href="SimplM.html#VALreturn_same"><code class="code">SimplM.return_same</code></a>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALreturn_err">return_err</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALreturn_new">return_new</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALreturn_phase">return_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Finish the given phase
</div>
</td></tr>
<tr><td><a href="Phases.html#VALreturn_phase_err">return_phase_err</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="SimplM.html#VALreturn_same">return_same</a> [<a href="SimplM.html">SimplM</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.Step.html#VALrule">rule</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td><div class="info">
Rule name for Esa/Simplification/Inference steps
</div>
</td></tr>
<tr><td><a href="Phases.html#VALrun">run</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run m</code> is <code class="code">run_with empty_state m</code>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALrun_parallel">run_parallel</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run_sequentiel l</code> runs each action of the list in succession,
    restarting every time with the initial state (once an action
    has finished, its state is discarded).
</div>
</td></tr>
<tr><td><a href="Phases.html#VALrun_with">run_with</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">run_with state m</code> executes the actions in <code class="code">m</code> starting with <code class="code">state</code>,
    returning some value (or error) and the final state.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Cover_set.Case.html#VALsame_cst">same_cst</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td><div class="info">
true iff the two cases are on the same constant
</div>
</td></tr>
<tr><td><a href="Ind_cst.html#VALsame_type">same_type</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td><div class="info">
Do these two inductive constants have the same type?
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALscan_statement">scan_statement</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Check whether the statement contains an "AC" attribute, do the proper
      declaration in this case
</div>
</td></tr>
<tr><td><a href="Superposition.html#VALsection">section</a> [<a href="Superposition.html">Superposition</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALsection">section</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.html#VALsection">section</a> [<a href="Proof.html">Proof</a>]</td>
<td></td></tr>
<tr><td><a href="Const.html#VALsection">section</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALseed">seed</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALselect">select</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALselect">select</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALselect">select</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Selection.html#VALselect_complex">select_complex</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
x!=y, or ground negative lit, or like select_diff_neg_lit
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_complex_except_RR_horn">select_complex_except_RR_horn</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
if clause is a restricted range horn clause, then select nothing;
    otherwise, like select_complex
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_diff_neg_lit">select_diff_neg_lit</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
arbitrary negative literal with maximal weight difference between sides
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselect_max_goal">select_max_goal</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
Select a maximal negative literal, if any, or nothing
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALselected_lits">selected_lits</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
get the list of selected literals
</div>
</td></tr>
<tr><td><a href="Selection.html#VALselection_from_string">selection_from_string</a> [<a href="Selection.html">Selection</a>]</td>
<td><div class="info">
selection function from string (may fail)
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.html#VALselection_fun">selection_fun</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
selection function for clauses
</div>
</td></tr>
<tr><td><a href="Phases.html#VALset">set</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver.html#VALset_compact">set_compact</a> [<a href="Sat_solver.html">Sat_solver</a>]</td>
<td><div class="info">
Toggle compact proofs.
</div>
</td></tr>
<tr><td><a href="SClause.html#VALset_flag">set_flag</a> [<a href="SClause.html">SClause</a>]</td>
<td><div class="info">
set boolean flag
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALset_flag">set_flag</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
set boolean flag
</div>
</td></tr>
<tr><td><a href="Phases.html#VALset_key">set_key</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALset_ord">set_ord</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALset_printer">set_printer</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
How to print literals?
</div>
</td></tr>
<tr><td><a href="ClauseQueue.html#VALset_profile">set_profile</a> [<a href="ClauseQueue.html">ClauseQueue</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALset_selection_fun">set_selection_fun</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALset_sign">set_sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Set the sign of the literal to the given boolean
</div>
</td></tr>
<tr><td><a href="Fool.S.html#VALsetup">setup</a> [<a href="Fool.S.html">Fool.S</a>]</td>
<td><div class="info">
Register rules in the environment
</div>
</td></tr>
<tr><td><a href="Ind_types.Make.html#VALsetup">setup</a> [<a href="Ind_types.Make.html">Ind_types.Make</a>]</td>
<td></td></tr>
<tr><td><a href="EnumTypes.S.html#VALsetup">setup</a> [<a href="EnumTypes.S.html">EnumTypes.S</a>]</td>
<td><div class="info">
Register rules in the environment
</div>
</td></tr>
<tr><td><a href="Rewriting.Make.html#VALsetup">setup</a> [<a href="Rewriting.Make.html">Rewriting.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALsetup">setup</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALsetup">setup</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Register on Env
</div>
</td></tr>
<tr><td><a href="Phases_impl.html#VALsetup_gc">setup_gc</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Phases_impl.html#VALsetup_signal">setup_signal</a> [<a href="Phases_impl.html">Phases_impl</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALsign">sign</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td><div class="info">
Current sign of the literal (positive or negative)
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsignature">signature</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx.PARAMETERS.html#VALsignature">signature</a> [<a href="Ctx.PARAMETERS.html">Ctx.PARAMETERS</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.html#VALsignature">signature</a> [<a href="Ctx_intf.S.html">Ctx_intf.S</a>]</td>
<td><div class="info">
Current signature
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALsimp">simp</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="AC_intf.S.html#VALsimplify">simplify</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
Simplify the clause modulo AC
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsimplify">simplify</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Simplify the clause.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsimplify_active_with">simplify_active_with</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Can be called when a simplification relation becomes stronger,
      with the strengthened relation.
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsimplify_term">simplify_term</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Simplify the term
</div>
</td></tr>
<tr><td><a href="Trail.html#VALsingleton">singleton</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALskolems">skolems</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Avatar_intf.S.html#VALsplit">split</a> [<a href="Avatar_intf.S.html">Avatar_intf.S</a>]</td>
<td><div class="info">
Split a clause into components
</div>
</td></tr>
<tr><td><a href="Phases.html#VALstart_phase">start_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Start the given phase
</div>
</td></tr>
<tr><td><a href="Clause.html#VALstat_clause_create">stat_clause_create</a> [<a href="Clause.html">Clause</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALstats">stats</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
Compute stats
</div>
</td></tr>
<tr><td><a href="ProofState_intf.S.html#VALstats">stats</a> [<a href="ProofState_intf.S.html">ProofState_intf.S</a>]</td>
<td><div class="info">
Compute statistics
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALstep">step</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Env_intf.S.html#VALstep_init">step_init</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
call all functions registered with <a href="Env_intf.S.html#VALadd_step_init"><code class="code">Env_intf.S.add_step_init</code></a>
</div>
</td></tr>
<tr><td><a href="Params.html#VALsteps">steps</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALstring_of_any_phase">string_of_any_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALstring_of_phase">string_of_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALsub_constants">sub_constants</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td><div class="info">
All sub-constants that are subterms of a specific case
</div>
</td></tr>
<tr><td><a href="Cover_set.html#VALsub_constants">sub_constants</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td><div class="info">
All sub-constants of a given inductive constant
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALsubst1">subst1</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td><div class="info">
Substitution of one variable
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALsubsumed_by">subsumed_by</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
List of active clauses subsumed by the given clause
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALsubsumed_by_active_set">subsumed_by_active_set</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
check whether the clause is subsumed by any clause in the set
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALsubsumed_in_active_set">subsumed_in_active_set</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
list of clauses in the active set that are subsumed by the clause
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALsubsumes">subsumes</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
subsumes c1 c2 iff c1 subsumes c2
</div>
</td></tr>
<tr><td><a href="Trail.html#VALsubsumes">subsumes</a> [<a href="Trail.html">Trail</a>]</td>
<td><div class="info">
<code class="code">subsumes a b</code> is true iff <code class="code">a</code> is a subset of <code class="code">b</code>
</div>
</td></tr>
<tr><td><a href="Superposition_intf.S.html#VALsubsumes_with">subsumes_with</a> [<a href="Superposition_intf.S.html">Superposition_intf.S</a>]</td>
<td><div class="info">
returns subsuming subst if the first clause subsumes the second one
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALsymbols">symbols</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
set of AC symbols
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALsymbols">symbols</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
symbols that occur in the clause
</div>
</td></tr>
<tr><td><a href="AC_intf.S.html#VALsymbols_of_terms">symbols_of_terms</a> [<a href="AC_intf.S.html">AC_intf.S</a>]</td>
<td><div class="info">
set of AC symbols occurring in the given term
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALtake_first">take_first</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td><div class="info">
Take first element of the queue, or raise Not_found
</div>
</td></tr>
<tr><td><a href="Cut_form.Seq.html#VALterms">terms</a> [<a href="Cut_form.Seq.html">Cut_form.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALterms">terms</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.Seq.html#VALterms_with_pos">terms_with_pos</a> [<a href="Cut_form.Seq.html">Cut_form.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALtimeout">timeout</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALto_form">to_form</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_forms">to_forms</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Easy iteration on an abstract view of literals
</div>
</td></tr>
<tr><td><a href="Ctx_intf.S.Lit.html#VALto_hooks">to_hooks</a> [<a href="Ctx_intf.S.Lit.html">Ctx_intf.S.Lit</a>]</td>
<td></td></tr>
<tr><td><a href="Bool_lit_intf.S.html#VALto_int">to_int</a> [<a href="Bool_lit_intf.S.html">Bool_lit_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALto_list">to_list</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALto_lit">to_lit</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Proof.S.html#VALto_llproof">to_llproof</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td><div class="info">
Convert to low level t
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALto_s_form">to_s_form</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td><div class="info">
Convert to input formula
</div>
</td></tr>
<tr><td><a href="Trail.html#VALto_s_form">to_s_form</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="BBox.html#VALto_s_form">to_s_form</a> [<a href="BBox.html">BBox</a>]</td>
<td></td></tr>
<tr><td><a href="SClause.html#VALto_s_form">to_s_form</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_s_form">to_s_form</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_sclause">to_sclause</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Trail.html#VALto_seq">to_seq</a> [<a href="Trail.html">Trail</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALto_string">to_string</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Debug printing to a  string
</div>
</td></tr>
<tr><td><a href="ClauseQueue_intf.S.html#VALto_string">to_string</a> [<a href="ClauseQueue_intf.S.html">ClauseQueue_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.Case.html#VALto_term">to_term</a> [<a href="Cover_set.Case.html">Cover_set.Case</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALto_term">to_term</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.html#VALtop">top</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td><div class="info">
top constant of the coverset
</div>
</td></tr>
<tr><td><a href="SClause.html#VALtrail">trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail">trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Get the clause's trail
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail_l">trail_l</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Merge the trails of several clauses
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALtrail_subsumes">trail_subsumes</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
<code class="code">trail_subsumes c1 c2 = Trail.subsumes (get_trail c1) (get_trail c2)</code>
</div>
</td></tr>
<tr><td><a href="Proof.S.html#VALtraverse">traverse</a> [<a href="Proof.S.html">Proof.S</a>]</td>
<td></td></tr>
<tr><td><a href="Cut_form.html#VALtrivial">trivial</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="ClauseContext.html#VALtrivial">trivial</a> [<a href="ClauseContext.html">ClauseContext</a>]</td>
<td><div class="info">
Trivial context, that contains 0 holes.
</div>
</td></tr>
<tr><td><a href="Proof.Step.html#VALtrivial">trivial</a> [<a href="Proof.Step.html">Proof.Step</a>]</td>
<td></td></tr>
<tr><td><a href="Cover_set.html#VALty">ty</a> [<a href="Cover_set.html">Cover_set</a>]</td>
<td></td></tr>
<tr><td><a href="Ind_cst.html#VALty">ty</a> [<a href="Ind_cst.html">Ind_cst</a>]</td>
<td></td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Params.html#VALunary_depth">unary_depth</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALupdate">update</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
<code class="code">update ~f</code> changes the state using <code class="code">f</code>
</div>
</td></tr>
<tr><td><a href="Env_intf.S.html#VALupdate_flex_state">update_flex_state</a> [<a href="Env_intf.S.html">Env_intf.S</a>]</td>
<td><div class="info">
<code class="code">update_flex_state f</code> changes <code class="code">flex_state ()</code> using <code class="code">f</code>
</div>
</td></tr>
<tr><td><a href="Clause_intf.S.html#VALupdate_proof">update_proof</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
<code class="code">update_proof c f</code> creates a new clause that is
      similar to <code class="code">c</code> in all aspects, but with
      the proof <code class="code">f (proof_step c)</code>
</div>
</td></tr>
<tr><td><a href="SClause.html#VALupdate_trail">update_trail</a> [<a href="SClause.html">SClause</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.html#VALupdate_trail">update_trail</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td><div class="info">
Change the trail.
</div>
</td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALvaluation">valuation</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Assuming the last call to <a href="Sat_solver_intf.S.html#VALcheck"><code class="code">Sat_solver_intf.S.check</code></a> returned <code class="code">Sat</code>, get the boolean
      valuation for this (positive) literal in the current model.
</div>
</td></tr>
<tr><td><a href="Sat_solver_intf.S.html#VALvaluation_level">valuation_level</a> [<a href="Sat_solver_intf.S.html">Sat_solver_intf.S</a>]</td>
<td><div class="info">
Gives the value of a literal in the model, as well as its
      decision level.
</div>
</td></tr>
<tr><td><a href="Cut_form.html#VALvars">vars</a> [<a href="Cut_form.html">Cut_form</a>]</td>
<td></td></tr>
<tr><td><a href="Clause_intf.S.Seq.html#VALvars">vars</a> [<a href="Clause_intf.S.Seq.html">Clause_intf.S.Seq</a>]</td>
<td></td></tr>
<tr><td><a href="Params.html#VALversion">version</a> [<a href="Params.html">Params</a>]</td>
<td></td></tr>
<tr><td><a href="Const.html#VALversion">version</a> [<a href="Const.html">Const</a>]</td>
<td></td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Clause_intf.S.html#VALweight">weight</a> [<a href="Clause_intf.S.html">Clause_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Classify_cst.html#VALweight_fun">weight_fun</a> [<a href="Classify_cst.html">Classify_cst</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALwith_phase">with_phase</a> [<a href="Phases.html">Phases</a>]</td>
<td><div class="info">
Start phase, call <code class="code">f ()</code> to get the result, return its result
    using <a href="Phases.html#VALreturn_phase"><code class="code">Phases.return_phase</code></a>
</div>
</td></tr>
<tr><td><a href="Phases.html#VALwith_phase1">with_phase1</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
<tr><td><a href="Phases.html#VALwith_phase2">with_phase2</a> [<a href="Phases.html">Phases</a>]</td>
<td></td></tr>
</table>
</body>
</html>