# OASIS_START
# DO NOT EDIT (digest: de548ca6b30f142865ad99a985d2d6c0)
# Ignore VCS directories, you can use the same kind of rule outside
# OASIS_START/STOP if you want to exclude directories that contains
# useless stuff for the build process
true: annot, bin_annot
<**/.svn>: -traverse
<**/.svn>: not_hygienic
".bzr": -traverse
".bzr": not_hygienic
".hg": -traverse
".hg": not_hygienic
".git": -traverse
".git": not_hygienic
"_darcs": -traverse
"_darcs": not_hygienic
# Library libzipperposition
"src/core/libzipperposition.cmxs": use_libzipperposition
"src/core/InnerTerm.cmx": for-pack(Libzipperposition)
"src/core/FOTerm.cmx": for-pack(Libzipperposition)
"src/core/Type.cmx": for-pack(Libzipperposition)
"src/core/Util.cmx": for-pack(Libzipperposition)
"src/core/STerm.cmx": for-pack(Libzipperposition)
"src/core/Interfaces.cmx": for-pack(Libzipperposition)
"src/core/DBEnv.cmx": for-pack(Libzipperposition)
"src/core/Position.cmx": for-pack(Libzipperposition)
"src/core/Var.cmx": for-pack(Libzipperposition)
"src/core/HVar.cmx": for-pack(Libzipperposition)
"src/core/Substs.cmx": for-pack(Libzipperposition)
"src/core/Unif.cmx": for-pack(Libzipperposition)
"src/core/Signature.cmx": for-pack(Libzipperposition)
"src/core/Scoped.cmx": for-pack(Libzipperposition)
"src/core/Unif_intf.cmx": for-pack(Libzipperposition)
"src/core/TypeInference.cmx": for-pack(Libzipperposition)
"src/core/Options.cmx": for-pack(Libzipperposition)
"src/core/Comparison.cmx": for-pack(Libzipperposition)
"src/core/Precedence.cmx": for-pack(Libzipperposition)
"src/core/Builtin.cmx": for-pack(Libzipperposition)
"src/core/Ordering.cmx": for-pack(Libzipperposition)
"src/core/Skolem.cmx": for-pack(Libzipperposition)
"src/core/Cnf.cmx": for-pack(Libzipperposition)
"src/core/ID.cmx": for-pack(Libzipperposition)
"src/core/IDOrBuiltin.cmx": for-pack(Libzipperposition)
"src/core/SLiteral.cmx": for-pack(Libzipperposition)
"src/core/Index.cmx": for-pack(Libzipperposition)
"src/core/Index_intf.cmx": for-pack(Libzipperposition)
"src/core/Dtree.cmx": for-pack(Libzipperposition)
"src/core/Fingerprint.cmx": for-pack(Libzipperposition)
"src/core/NPDtree.cmx": for-pack(Libzipperposition)
"src/core/Binder.cmx": for-pack(Libzipperposition)
"src/core/Congruence.cmx": for-pack(Libzipperposition)
"src/core/FeatureVector.cmx": for-pack(Libzipperposition)
"src/core/UntypedAST.cmx": for-pack(Libzipperposition)
"src/core/Ind_ty.cmx": for-pack(Libzipperposition)
"src/core/TypedSTerm.cmx": for-pack(Libzipperposition)
"src/core/Statement.cmx": for-pack(Libzipperposition)
"src/core/StatementSrc.cmx": for-pack(Libzipperposition)
"src/core/lib/Hashcons.cmx": for-pack(Libzipperposition)
"src/core/lib/ParseLocation.cmx": for-pack(Libzipperposition)
"src/core/lib/Multiset.cmx": for-pack(Libzipperposition)
"src/core/lib/LazyList.cmx": for-pack(Libzipperposition)
"src/core/lib/IArray.cmx": for-pack(Libzipperposition)
"src/core/lib/AllocCache.cmx": for-pack(Libzipperposition)
"src/core/lib/Multiset_intf.cmx": for-pack(Libzipperposition)
<src/core/*.ml{,i,y}>: oasis_library_libzipperposition_ccopt
<src/core/lib/*.ml{,i,y}>: oasis_library_libzipperposition_ccopt
"src/core/util_stubs.c": oasis_library_libzipperposition_ccopt
<src/core/libzipperposition.{cma,cmxa}>: use_liblibzipperposition_stubs
<src/core/*.ml{,i,y}>: package(bytes)
<src/core/*.ml{,i,y}>: package(containers)
<src/core/*.ml{,i,y}>: package(containers.data)
<src/core/*.ml{,i,y}>: package(oclock)
<src/core/*.ml{,i,y}>: package(sequence)
<src/core/*.ml{,i,y}>: package(unix)
<src/core/*.ml{,i,y}>: package(zarith)
<src/core/lib/*.ml{,i,y}>: package(bytes)
<src/core/lib/*.ml{,i,y}>: package(containers)
<src/core/lib/*.ml{,i,y}>: package(containers.data)
<src/core/lib/*.ml{,i,y}>: package(oclock)
<src/core/lib/*.ml{,i,y}>: package(sequence)
<src/core/lib/*.ml{,i,y}>: package(unix)
<src/core/lib/*.ml{,i,y}>: package(zarith)
"src/core/util_stubs.c": package(bytes)
"src/core/util_stubs.c": package(containers)
"src/core/util_stubs.c": package(containers.data)
"src/core/util_stubs.c": package(oclock)
"src/core/util_stubs.c": package(sequence)
"src/core/util_stubs.c": package(unix)
"src/core/util_stubs.c": package(zarith)
# Library libzipperposition_parsers
"src/parsers/libzipperposition_parsers.cmxs": use_libzipperposition_parsers
"src/parsers/parse_tptp.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/lex_tptp.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/ast_tptp.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/util_tptp.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/ast_ho.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/lex_ho.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/parse_ho.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/trace_tstp.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/parse_zf.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/lex_zf.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/util_zf.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/parsing_utils.cmx": for-pack(Libzipperposition_parsers)
"src/parsers/callProver.cmx": for-pack(Libzipperposition_parsers)
<src/parsers/*.ml{,i,y}>: package(bytes)
<src/parsers/*.ml{,i,y}>: package(containers)
<src/parsers/*.ml{,i,y}>: package(containers.data)
<src/parsers/*.ml{,i,y}>: package(oclock)
<src/parsers/*.ml{,i,y}>: package(sequence)
<src/parsers/*.ml{,i,y}>: package(unix)
<src/parsers/*.ml{,i,y}>: package(zarith)
<src/parsers/*.ml{,i,y}>: use_libzipperposition
# Library libzipperposition_meta
"src/meta/libzipperposition_meta.cmxs": use_libzipperposition_meta
"src/meta/encoding.cmx": for-pack(Libzipperposition_meta)
"src/meta/reasoner.cmx": for-pack(Libzipperposition_meta)
"src/meta/plugin.cmx": for-pack(Libzipperposition_meta)
"src/meta/prover.cmx": for-pack(Libzipperposition_meta)
<src/meta/*.ml{,i,y}>: package(bytes)
<src/meta/*.ml{,i,y}>: package(containers)
<src/meta/*.ml{,i,y}>: package(containers.data)
<src/meta/*.ml{,i,y}>: package(oclock)
<src/meta/*.ml{,i,y}>: package(sequence)
<src/meta/*.ml{,i,y}>: package(unix)
<src/meta/*.ml{,i,y}>: package(zarith)
<src/meta/*.ml{,i,y}>: use_libzipperposition
<src/meta/*.ml{,i,y}>: use_libzipperposition_parsers
# Library libzipperposition_solving
"src/solving/libzipperposition_solving.cmxs": use_libzipperposition_solving
"src/solving/lpo.cmx": for-pack(Libzipperposition_solving)
<src/solving/*.ml{,i,y}>: package(bytes)
<src/solving/*.ml{,i,y}>: package(containers)
<src/solving/*.ml{,i,y}>: package(containers.data)
<src/solving/*.ml{,i,y}>: package(msat)
<src/solving/*.ml{,i,y}>: package(oclock)
<src/solving/*.ml{,i,y}>: package(sequence)
<src/solving/*.ml{,i,y}>: package(unix)
<src/solving/*.ml{,i,y}>: package(zarith)
<src/solving/*.ml{,i,y}>: use_libzipperposition
# Library libzipperposition_arbitrary
"src/arbitrary/libzipperposition_arbitrary.cmxs": use_libzipperposition_arbitrary
"src/arbitrary/arTerm.cmx": for-pack(Libzipperposition_arbitrary)
"src/arbitrary/arForm.cmx": for-pack(Libzipperposition_arbitrary)
"src/arbitrary/arType.cmx": for-pack(Libzipperposition_arbitrary)
"src/arbitrary/arID.cmx": for-pack(Libzipperposition_arbitrary)
<src/arbitrary/*.ml{,i,y}>: package(bytes)
<src/arbitrary/*.ml{,i,y}>: package(containers)
<src/arbitrary/*.ml{,i,y}>: package(containers.data)
<src/arbitrary/*.ml{,i,y}>: package(oclock)
<src/arbitrary/*.ml{,i,y}>: package(qcheck)
<src/arbitrary/*.ml{,i,y}>: package(sequence)
<src/arbitrary/*.ml{,i,y}>: package(unix)
<src/arbitrary/*.ml{,i,y}>: package(zarith)
<src/arbitrary/*.ml{,i,y}>: use_libzipperposition
<src/arbitrary/*.ml{,i,y}>: use_libzipperposition_meta
<src/arbitrary/*.ml{,i,y}>: use_libzipperposition_parsers
# Library libzipperposition_prover
"src/prover/libzipperposition_prover.cmxs": use_libzipperposition_prover
"src/prover/clauseQueue.cmx": for-pack(Libzipperposition_prover)
"src/prover/clause.cmx": for-pack(Libzipperposition_prover)
"src/prover/SClause.cmx": for-pack(Libzipperposition_prover)
"src/prover/const.cmx": for-pack(Libzipperposition_prover)
"src/prover/extensions.cmx": for-pack(Libzipperposition_prover)
"src/prover/literal.cmx": for-pack(Libzipperposition_prover)
"src/prover/literals.cmx": for-pack(Libzipperposition_prover)
"src/prover/ctx.cmx": for-pack(Libzipperposition_prover)
"src/prover/proofStep.cmx": for-pack(Libzipperposition_prover)
"src/prover/proofPrint.cmx": for-pack(Libzipperposition_prover)
"src/prover/proofState.cmx": for-pack(Libzipperposition_prover)
"src/prover/saturate.cmx": for-pack(Libzipperposition_prover)
"src/prover/selection.cmx": for-pack(Libzipperposition_prover)
"src/prover/AC.cmx": for-pack(Libzipperposition_prover)
"src/prover/AC_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/simplM.cmx": for-pack(Libzipperposition_prover)
"src/prover/compute_prec.cmx": for-pack(Libzipperposition_prover)
"src/prover/params.cmx": for-pack(Libzipperposition_prover)
"src/prover/env.cmx": for-pack(Libzipperposition_prover)
"src/prover/monome.cmx": for-pack(Libzipperposition_prover)
"src/prover/arithLit.cmx": for-pack(Libzipperposition_prover)
"src/prover/signals.cmx": for-pack(Libzipperposition_prover)
"src/prover/multisets.cmx": for-pack(Libzipperposition_prover)
"src/prover/ctx_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/clause_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/env_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/proofState_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/bBox.cmx": for-pack(Libzipperposition_prover)
"src/prover/clauseContext.cmx": for-pack(Libzipperposition_prover)
"src/prover/clauseQueue_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/bool_lit.cmx": for-pack(Libzipperposition_prover)
"src/prover/bool_lit_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/sat_solver.cmx": for-pack(Libzipperposition_prover)
"src/prover/sat_solver_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/trail.cmx": for-pack(Libzipperposition_prover)
"src/prover/Ind_cst.cmx": for-pack(Libzipperposition_prover)
"src/prover/phases.cmx": for-pack(Libzipperposition_prover)
"src/prover/phases_impl.cmx": for-pack(Libzipperposition_prover)
"src/prover/Flex_state.cmx": for-pack(Libzipperposition_prover)
"src/prover/classify_cst.cmx": for-pack(Libzipperposition_prover)
"src/prover/Rewrite_rule.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/avatar.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/avatar_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/induction.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/induction_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/superposition.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/Rewriting.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/enumTypes.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/arithInt.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/heuristics.cmx": for-pack(Libzipperposition_prover)
"src/prover/calculi/ind_types.cmx": for-pack(Libzipperposition_prover)
"src/prover/meta/metaProverState.cmx": for-pack(Libzipperposition_prover)
"src/prover/meta/metaProverState_intf.cmx": for-pack(Libzipperposition_prover)
"src/prover/lib/unionFind.cmx": for-pack(Libzipperposition_prover)
"src/prover/lib/signal.cmx": for-pack(Libzipperposition_prover)
"src/prover/lib/simplex.cmx": for-pack(Libzipperposition_prover)
<src/prover/*.ml{,i,y}>: package(bytes)
<src/prover/*.ml{,i,y}>: package(containers)
<src/prover/*.ml{,i,y}>: package(containers.advanced)
<src/prover/*.ml{,i,y}>: package(containers.data)
<src/prover/*.ml{,i,y}>: package(msat)
<src/prover/*.ml{,i,y}>: package(oclock)
<src/prover/*.ml{,i,y}>: package(sequence)
<src/prover/*.ml{,i,y}>: package(unix)
<src/prover/*.ml{,i,y}>: package(zarith)
<src/prover/*.ml{,i,y}>: use_libzipperposition
<src/prover/*.ml{,i,y}>: use_libzipperposition_meta
<src/prover/*.ml{,i,y}>: use_libzipperposition_parsers
<src/prover/calculi/*.ml{,i,y}>: package(bytes)
<src/prover/calculi/*.ml{,i,y}>: package(containers)
<src/prover/calculi/*.ml{,i,y}>: package(containers.advanced)
<src/prover/calculi/*.ml{,i,y}>: package(containers.data)
<src/prover/calculi/*.ml{,i,y}>: package(msat)
<src/prover/calculi/*.ml{,i,y}>: package(oclock)
<src/prover/calculi/*.ml{,i,y}>: package(sequence)
<src/prover/calculi/*.ml{,i,y}>: package(unix)
<src/prover/calculi/*.ml{,i,y}>: package(zarith)
<src/prover/calculi/*.ml{,i,y}>: use_libzipperposition
<src/prover/calculi/*.ml{,i,y}>: use_libzipperposition_meta
<src/prover/calculi/*.ml{,i,y}>: use_libzipperposition_parsers
<src/prover/meta/*.ml{,i,y}>: package(bytes)
<src/prover/meta/*.ml{,i,y}>: package(containers)
<src/prover/meta/*.ml{,i,y}>: package(containers.advanced)
<src/prover/meta/*.ml{,i,y}>: package(containers.data)
<src/prover/meta/*.ml{,i,y}>: package(msat)
<src/prover/meta/*.ml{,i,y}>: package(oclock)
<src/prover/meta/*.ml{,i,y}>: package(sequence)
<src/prover/meta/*.ml{,i,y}>: package(unix)
<src/prover/meta/*.ml{,i,y}>: package(zarith)
<src/prover/meta/*.ml{,i,y}>: use_libzipperposition
<src/prover/meta/*.ml{,i,y}>: use_libzipperposition_meta
<src/prover/meta/*.ml{,i,y}>: use_libzipperposition_parsers
<src/prover/lib/*.ml{,i,y}>: package(bytes)
<src/prover/lib/*.ml{,i,y}>: package(containers)
<src/prover/lib/*.ml{,i,y}>: package(containers.advanced)
<src/prover/lib/*.ml{,i,y}>: package(containers.data)
<src/prover/lib/*.ml{,i,y}>: package(msat)
<src/prover/lib/*.ml{,i,y}>: package(oclock)
<src/prover/lib/*.ml{,i,y}>: package(sequence)
<src/prover/lib/*.ml{,i,y}>: package(unix)
<src/prover/lib/*.ml{,i,y}>: package(zarith)
<src/prover/lib/*.ml{,i,y}>: use_libzipperposition
<src/prover/lib/*.ml{,i,y}>: use_libzipperposition_meta
<src/prover/lib/*.ml{,i,y}>: use_libzipperposition_parsers
# Executable zipperposition
"src/main/zipperposition.native": package(bytes)
"src/main/zipperposition.native": package(containers)
"src/main/zipperposition.native": package(containers.advanced)
"src/main/zipperposition.native": package(containers.data)
"src/main/zipperposition.native": package(msat)
"src/main/zipperposition.native": package(oclock)
"src/main/zipperposition.native": package(sequence)
"src/main/zipperposition.native": package(unix)
"src/main/zipperposition.native": package(zarith)
"src/main/zipperposition.native": use_libzipperposition
"src/main/zipperposition.native": use_libzipperposition_meta
"src/main/zipperposition.native": use_libzipperposition_parsers
"src/main/zipperposition.native": use_libzipperposition_prover
<src/main/*.ml{,i,y}>: package(bytes)
<src/main/*.ml{,i,y}>: package(containers)
<src/main/*.ml{,i,y}>: package(containers.advanced)
<src/main/*.ml{,i,y}>: package(containers.data)
<src/main/*.ml{,i,y}>: package(msat)
<src/main/*.ml{,i,y}>: package(oclock)
<src/main/*.ml{,i,y}>: package(sequence)
<src/main/*.ml{,i,y}>: package(unix)
<src/main/*.ml{,i,y}>: package(zarith)
<src/main/*.ml{,i,y}>: use_libzipperposition
<src/main/*.ml{,i,y}>: use_libzipperposition_meta
<src/main/*.ml{,i,y}>: use_libzipperposition_parsers
<src/main/*.ml{,i,y}>: use_libzipperposition_prover
# Executable run_bench
"tests/run_bench.native": package(benchmark)
"tests/run_bench.native": package(bytes)
"tests/run_bench.native": package(containers)
"tests/run_bench.native": package(containers.data)
"tests/run_bench.native": package(oclock)
"tests/run_bench.native": package(qcheck)
"tests/run_bench.native": package(sequence)
"tests/run_bench.native": package(unix)
"tests/run_bench.native": package(zarith)
"tests/run_bench.native": use_libzipperposition
"tests/run_bench.native": use_libzipperposition_arbitrary
"tests/run_bench.native": use_libzipperposition_meta
"tests/run_bench.native": use_libzipperposition_parsers
<tests/*.ml{,i,y}>: package(benchmark)
# Executable run_tests
"tests/run_tests.native": package(bytes)
"tests/run_tests.native": package(containers)
"tests/run_tests.native": package(containers.data)
"tests/run_tests.native": package(oUnit)
"tests/run_tests.native": package(oclock)
"tests/run_tests.native": package(qcheck)
"tests/run_tests.native": package(sequence)
"tests/run_tests.native": package(unix)
"tests/run_tests.native": package(zarith)
"tests/run_tests.native": use_libzipperposition
"tests/run_tests.native": use_libzipperposition_arbitrary
"tests/run_tests.native": use_libzipperposition_meta
"tests/run_tests.native": use_libzipperposition_parsers
<tests/*.ml{,i,y}>: package(bytes)
<tests/*.ml{,i,y}>: package(containers)
<tests/*.ml{,i,y}>: package(containers.data)
<tests/*.ml{,i,y}>: package(oUnit)
<tests/*.ml{,i,y}>: package(oclock)
<tests/*.ml{,i,y}>: package(qcheck)
<tests/*.ml{,i,y}>: package(sequence)
<tests/*.ml{,i,y}>: package(unix)
<tests/*.ml{,i,y}>: package(zarith)
<tests/*.ml{,i,y}>: use_libzipperposition
<tests/*.ml{,i,y}>: use_libzipperposition_arbitrary
<tests/*.ml{,i,y}>: use_libzipperposition_meta
<tests/*.ml{,i,y}>: use_libzipperposition_parsers
# Executable type_check
"src/tools/type_check.native": package(bytes)
"src/tools/type_check.native": package(containers)
"src/tools/type_check.native": package(containers.data)
"src/tools/type_check.native": package(oclock)
"src/tools/type_check.native": package(sequence)
"src/tools/type_check.native": package(unix)
"src/tools/type_check.native": package(zarith)
"src/tools/type_check.native": use_libzipperposition
"src/tools/type_check.native": use_libzipperposition_parsers
# Executable cnf_of
"src/tools/cnf_of.native": package(bytes)
"src/tools/cnf_of.native": package(containers)
"src/tools/cnf_of.native": package(containers.data)
"src/tools/cnf_of.native": package(oclock)
"src/tools/cnf_of.native": package(sequence)
"src/tools/cnf_of.native": package(unix)
"src/tools/cnf_of.native": package(zarith)
"src/tools/cnf_of.native": use_libzipperposition
"src/tools/cnf_of.native": use_libzipperposition_parsers
# Executable tptp_to_zf
"src/tools/tptp_to_zf.native": package(bytes)
"src/tools/tptp_to_zf.native": package(containers)
"src/tools/tptp_to_zf.native": package(containers.data)
"src/tools/tptp_to_zf.native": package(oclock)
"src/tools/tptp_to_zf.native": package(sequence)
"src/tools/tptp_to_zf.native": package(unix)
"src/tools/tptp_to_zf.native": package(zarith)
"src/tools/tptp_to_zf.native": use_libzipperposition
"src/tools/tptp_to_zf.native": use_libzipperposition_parsers
# Executable orient
"src/tools/orient/orient.native": package(bytes)
"src/tools/orient/orient.native": package(containers)
"src/tools/orient/orient.native": package(containers.data)
"src/tools/orient/orient.native": package(msat)
"src/tools/orient/orient.native": package(oclock)
"src/tools/orient/orient.native": package(sequence)
"src/tools/orient/orient.native": package(unix)
"src/tools/orient/orient.native": package(zarith)
"src/tools/orient/orient.native": use_libzipperposition
"src/tools/orient/orient.native": use_libzipperposition_parsers
"src/tools/orient/orient.native": use_libzipperposition_solving
<src/tools/orient/*.ml{,i,y}>: package(bytes)
<src/tools/orient/*.ml{,i,y}>: package(containers)
<src/tools/orient/*.ml{,i,y}>: package(containers.data)
<src/tools/orient/*.ml{,i,y}>: package(msat)
<src/tools/orient/*.ml{,i,y}>: package(oclock)
<src/tools/orient/*.ml{,i,y}>: package(sequence)
<src/tools/orient/*.ml{,i,y}>: package(unix)
<src/tools/orient/*.ml{,i,y}>: package(zarith)
<src/tools/orient/*.ml{,i,y}>: use_libzipperposition
<src/tools/orient/*.ml{,i,y}>: use_libzipperposition_parsers
<src/tools/orient/*.ml{,i,y}>: use_libzipperposition_solving
# Executable proof_check_tstp
"src/tools/proof_check_tstp.native": package(bytes)
"src/tools/proof_check_tstp.native": package(containers)
"src/tools/proof_check_tstp.native": package(containers.data)
"src/tools/proof_check_tstp.native": package(oclock)
"src/tools/proof_check_tstp.native": package(sequence)
"src/tools/proof_check_tstp.native": package(unix)
"src/tools/proof_check_tstp.native": package(zarith)
"src/tools/proof_check_tstp.native": use_libzipperposition
"src/tools/proof_check_tstp.native": use_libzipperposition_parsers
# Executable detect_theories
"src/tools/detect_theories.native": package(bytes)
"src/tools/detect_theories.native": package(containers)
"src/tools/detect_theories.native": package(containers.data)
"src/tools/detect_theories.native": package(oclock)
"src/tools/detect_theories.native": package(sequence)
"src/tools/detect_theories.native": package(unix)
"src/tools/detect_theories.native": package(zarith)
"src/tools/detect_theories.native": use_libzipperposition
"src/tools/detect_theories.native": use_libzipperposition_meta
"src/tools/detect_theories.native": use_libzipperposition_parsers
<src/tools/*.ml{,i,y}>: package(bytes)
<src/tools/*.ml{,i,y}>: package(containers)
<src/tools/*.ml{,i,y}>: package(containers.data)
<src/tools/*.ml{,i,y}>: package(oclock)
<src/tools/*.ml{,i,y}>: package(sequence)
<src/tools/*.ml{,i,y}>: package(unix)
<src/tools/*.ml{,i,y}>: package(zarith)
<src/tools/*.ml{,i,y}>: use_libzipperposition
<src/tools/*.ml{,i,y}>: use_libzipperposition_meta
<src/tools/*.ml{,i,y}>: use_libzipperposition_parsers
# Executable resolution1
"src/demo/resolution/resolution1.native": package(bytes)
"src/demo/resolution/resolution1.native": package(containers)
"src/demo/resolution/resolution1.native": package(containers.data)
"src/demo/resolution/resolution1.native": package(oclock)
"src/demo/resolution/resolution1.native": package(sequence)
"src/demo/resolution/resolution1.native": package(unix)
"src/demo/resolution/resolution1.native": package(zarith)
"src/demo/resolution/resolution1.native": use_libzipperposition
"src/demo/resolution/resolution1.native": use_libzipperposition_parsers
<src/demo/resolution/*.ml{,i,y}>: package(bytes)
<src/demo/resolution/*.ml{,i,y}>: package(containers)
<src/demo/resolution/*.ml{,i,y}>: package(containers.data)
<src/demo/resolution/*.ml{,i,y}>: package(oclock)
<src/demo/resolution/*.ml{,i,y}>: package(sequence)
<src/demo/resolution/*.ml{,i,y}>: package(unix)
<src/demo/resolution/*.ml{,i,y}>: package(zarith)
<src/demo/resolution/*.ml{,i,y}>: use_libzipperposition
<src/demo/resolution/*.ml{,i,y}>: use_libzipperposition_parsers
# OASIS_STOP
<**/*.cmx>: inline(15)

true: bin_annot, no_alias_deps, use_menhir, color(always), optimize(3)

"tests/quick/": -traverse
"tests/quick/": not_hygienic
"Problems": -traverse

<src/**/*.ml>: warn(+a-4-42-44-48-50)

<src/prover/const.cmx>: for-pack(Libzipperposition)

<src/**/*.cmx>: inline(20)
