% Builtin theories and lemmas (new syntax)
% vim:softtabstop=2:

axiom (associative F) <-
  holds [F ?x (F ?y ?z) = F (F ?x ?y) ?z].

axiom (commutative F) <-
  holds [F ?x ?y = F ?y ?x].

theory (ac F) <-
  axiom (associative F),
  axiom (commutative F).

axiom (associative F) <-
  theory (ac F).
axiom (commutative F) <-
  theory (ac F).

% a few general definitions (mostly form "rewriting, solving, proving")

axiom (involutive F) <-
  holds [F (F ?x) = ?x].

axiom (idempotent F) <-
  holds [F ?x ?x = ?x].

axiom (endomorphism {fun=H, op=Mult}) <-
  holds [H (Mult ?x ?y) = Mult (H ?x) (H ?y)].

axiom (unit_endomorphism {fun=H, elem=E}) <-
  holds [H E = E].

axiom (anti_endomorphism {fun=H, op=Mult}) <-
  holds [H (Mult ?x ?y) = Mult (H ?y) (H ?x)].

axiom (homomorphism {fun=H, op1=Mult, op2=Add}) <-
  holds [H (Mult ?x ?y) = Add (H ?x) (H ?y)].

axiom (left_identity {op=Mult, elem=E}) <-
  holds [Mult E ?x = ?x].

axiom (right_identity {op=Mult, elem=E}) <-
  holds [Mult ?x E = ?x].

axiom (left_inverse {op=Mult, inverse=I, elem=E}) <-
  holds [Mult (I ?x) ?x = E].

axiom (right_inverse {op=Mult, inverse=I, elem=E}) <-
  holds [Mult ?x (I ?x) = E].

axiom (left_absorb {op=Mult, elem=E}) <-
  holds [Mult E ?x = E].

axiom (right_absorb {op=Mult, elem=E}) <-
  holds [Mult ?x E = E].

% functional relations

axiom (functional1 P) <-
  holds [~ (P ?x ?y), ~ (P ?x ?z), ?y = ?z].

axiom (total1 {pred=P, fun=F}) <-
  holds [P ?x (F ?x)].

axiom (functional2 P) <-
  holds [~ (P ?x ?y ?z), ~ (P ?x ?y ?z2), ?z = ?z2].

axiom (total2 {pred=P, fun=F}) <-
  holds [P ?x ?y (F ?x ?y)].

pre_rewrite [P ?x ?y --> (?y = F ?x)] <-
  axiom (functional1 P),
  axiom (total1 {pred=P, fun=F}).

pre_rewrite [P ?x ?y ?z --> (?z = F ?x ?y)] <-
  axiom (functional2 P),
  axiom (total2 {pred=P, fun=F}).

% monoid

theory (monoid {op=Mult, neutral=E}) <-
  axiom (left_identity {op=Mult, elem=E}),
  axiom (right_identity {op=Mult, elem=E}),
  axiom (associative Mult).

axiom (associative F) <-
  theory (monoid {op=F | _}).

% group

theory (group {op=Mult, neutral=E, inverse=I}) <-
  theory (monoid {op=Mult, neutral=E}),
  axiom (left_inverse {op=Mult, inverse=I, elem=E}),
  axiom (right_inverse {op=Mult, inverse=I, elem=E}).

theory (group {op=Mult, neutral=E, inverse=I}) <-
  axiom (associative Mult),
  axiom (left_inverse {op=Mult, inverse=I, elem=E}),
  axiom (left_identity {op=Mult, elem=E}).

theory (abelian_group {op=Mult, neutral=E, inverse=I}) <-
  theory (group {op=Mult, neutral=E, inverse=I}),
  axiom (commutative Mult).

theory (group {op=Mult, neutral=E, inverse=I}) <-
  theory (abelian_group {op=Mult, neutral=E, inverse=I}).

rewrite
  [ Mult ?x E --> ?x
  , Mult E ?x --> ?x
  , Mult ?x (I ?x) --> E
  , Mult (I ?x) ?x --> E
  , I E --> E
  , I (I ?x) --> ?x
  , I (Mult ?x ?y) --> Mult (I ?y) (I ?x)
  , Mult (Mult ?x ?y) ?z --> Mult ?x (Mult ?y ?z)
  , Mult ?x (Mult (I ?x) ?y) --> ?y
  , Mult (I ?x) (Mult ?x ?y) --> ?y
  ] <- theory (group {op=Mult, neutral=E, inverse=I}).

rewrite
  [ Mult ?x E --> ?x
  , Mult ?x (I ?x) --> E
  , I E --> E
  , I (I ?x) --> ?x
  , I (Mult ?x ?y) --> Mult (I ?x) (I ?y)
  ] <- theory (abelian_group {op=Mult, neutral=E, inverse=I}).

% subgroup

theory (subgroup {op=Mult, neutral=E, inverse=I, mem=P}) <-
  theory (group {op=Mult, neutral=E, inverse=I}),
  holds [ P Some_element ],       % non-empty
  holds [ ~ (P ?x), P (I ?x) ],   % closed by inverse
  holds [ ~ (P ?x), ~ (P ?y), P (Mult ?x ?y) ].  % closed by op

lemma [ P E ] <-
  theory (subgroup {mem=P, neutral=E | _}).

% ring theory

axiom (left_distributive {sum=Sum, prod=Prod}) <-
  holds [ Prod ?x (Sum ?y ?z) = Sum (Prod ?x ?y) (Prod ?x ?z) ].

axiom (right_distributive {sum=Sum, prod=Prod}) <-
  holds [ Prod (Sum ?y ?z) ?x = Sum (Prod ?y ?x) (Prod ?z ?x) ].


theory (ring {sum=Sum, prod=Prod, zero=Zero, one=One, minus=Minus}) <-
  theory (abelian_group {op=Sum, neutral=Zero, inverse=Minus}),
  theory (monoid {op=Prod, neutral=One}),
  axiom (left_distributive {sum=Sum, prod=Prod}),
  axiom (right_distributive {sum=Sum, prod=Prod}).

theory (commutative_ring {sum=Sum, prod=Prod, zero=Zero, one=One, minus=Minus}) <-
  theory (ring {sum=Sum, prod=Prod, zero=Zero, one=One, minus=Minus}),
  axiom (commutative Prod).

rewrite
  [ Sum ?x Zero --> ?x
  , Sum ?x (Minus ?x) --> Zero
  , Minus Zero --> Zero
  , Minus (Minus ?x) --> ?x
  , Minus (Sum ?x ?y) --> Sum (Minus ?x) (Minus ?y) % abelian group
  , Prod ?x (Sum ?y ?z) --> Sum (Prod ?x ?y) (Prod ?x ?z)
  , Prod (Sum ?x ?y) ?z --> Sum (Prod ?x ?z) (Prod ?y ?z)
  , Prod ?x Zero --> Zero
  , Prod ?x (Minus ?y) --> Minus (Prod ?x ?y)
  , Prod Zero ?x --> Zero
  , Prod (Minus ?x) ?y --> Minus (Prod ?x ?y)
  ] <- theory (ring {sum=Sum, prod=Prod, zero=Zero, one=One, minus=Minus}).

% XXX omitted: boolean algebras

% basic relations

axiom (reflexive R) <-
  holds [ R ?x ?x ].

axiom (irreflexive R) <-
  holds [ ~ (R ?x ?x) ].

axiom (transitive R) <-
  holds [ ~ (R ?x ?y), ~ (R ?y ?z), R ?x ?z ].

axiom (antisymmetric R) <-
  holds [ ~ (R ?x ?y), ~ (R ?y ?x), ?x = ?y ].

axiom (symmetric R) <-
  holds [ ~ (R ?x ?y), R ?y ?x ].

% partial orders

theory (partial_order R) <-
  axiom (reflexive R),
  axiom (transitive R),
  axiom (antisymmetric R).

theory (strict_partial_order R) <-
  axiom (irreflexive R),
  axiom (transitive R).

% total orders

theory (non_strict_total_order R) <-
  theory (partial_order R),
  holds [ R ?x ?y, R ?y ?x ].

theory (strict_total_order R) <-
  theory (partial_order R),
  holds [ R ?x ?y, ?x = ?y, R ?y ?x ].

theory (total_order {less=Less, lesseq=Lesseq}) <-
  theory (strict_total_order Less),
  holds [ ?x != ?y, Lesseq ?x ?y ],
  holds [ ~ (Less ?x ?y), Lesseq ?x ?y ],
  holds [ ~ (Lesseq ?x ?y), ?x = ?y, Less ?x ?y ].

theory (total_order {less=Less, lesseq=Lesseq}) <-
  theory (non_strict_total_order Lesseq),
  axiom (irreflexive Less),
  holds [ ~ (Less ?x ?y), Lesseq ?x ?y ],
  holds [ ~ (Lesseq ?x ?y), ?x = ?y, Less ?x ?y ].

theory (strict_total_order Less) <-
  theory (total_order {less=Less | _}).

theory (non_strict_total_order Lesseq) <-
  theory (total_order {lesseq=Lesseq | _}).

% dense orders, orders without endpoints

axiom (no_higher_bound R) <-
  holds [ R ?x (Some_successor ?x) ].

axiom (higher_bound {lesseq=Lesseq, high=High}) <-
  holds [ Lesseq ?x High ].

axiom (lower_bound {lesseq=Lesseq, low=Low}) <-
  holds [ Lesseq Low ?x ].

axiom (no_lower_bound R) <-
  holds [ R (Some_predecessor ?x) ?x ].

theory (total_order_without_endpoints R) <-
  theory (strict_total_order R),
  axiom (no_lower_bound R),
  axiom (no_higher_bound R).

theory (dense_total_order R) <-
  theory (strict_total_order R),
  holds [ ~ (R ?x ?y), R ?x (Middle ?x ?y) ],
  holds [ ~ (R ?x ?y), R (Middle ?x ?y) ?y ].

theory (dense_total_order_without_endpoints R) <-
  theory (total_order_without_endpoints R),
  theory (dense_total_order R).

% lattices

theory (semi_lattice Meet) <-
  theory (ac Meet),
  axiom (idempotent Meet).

theory (meet_semi_lattice {meet=Meet, order=Lesseq}) <-
  theory (semi_lattice Meet),
  theory (partial_order Lesseq),
  holds [ Lesseq (Meet ?x ?y) ?x ],
  holds [ Lesseq (Meet ?x ?y) ?y ].

theory (join_semi_lattice {join=Join, order=Lesseq}) <-
  theory (semi_lattice Join),
  theory (partial_order Lesseq),
  holds [ Lesseq ?x (Join ?x ?y) ],
  holds [ Lesseq ?y (Join ?x ?y) ].

axiom (absorption F1 F2) <-
  holds [ F1 ?x (F2 ?x ?y) = ?x ].

theory (lattice {meet=Meet, join=Join}) <-
  theory (semi_lattice Meet),
  theory (semi_lattice Join),
  axiom (absorption Meet Join),
  axiom (absorption Join Meet).

theory (ordered_lattice {order=Lesseq, meet=Meet, join=Join}) <-
  theory (lattice {meet=Meet, join=Join}),
  theory (meet_semi_lattice {meet=Meet, order=Lesseq}),
  theory (join_semi_lattice {join=Join, order=Lesseq}).

theory (complete_lattice {meet=Meet, join=Join, order=Lesseq, top=Top, bottom=Bottom}) <-
  theory (ordered_lattice {meet=Meet, join=Join, order=Lesseq}),
  axiom (lower_bound {lesseq=Lesseq, low=Bottom}),
  axiom (higher_bound {lesseq=Lesseq, high=Top}).
