<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (libzipperposition.calculi.Libzipperposition_calculi__Simplex.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">libzipperposition.calculi</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Libzipperposition_calculi__Simplex.Make</span></h1></header><div class="doc"><p>Functor building an implementation of the simplex solver given a totally ordered
type for the variables</p></div><h3 class="heading">Parameters</h3><div><div class="spec argument" id="argument-1-Var"><a href="#argument-1-Var" class="anchor"></a><div class="def argument"><code><a href="argument-1-Var/index.html">Var</a> : <a href="../index.html#module-type-OrderedType">OrderedType</a></code></div><div class="doc"></div></div></div><h3 class="heading">Signature</h3><div class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>var</code><code><span class="keyword"> = </span><a href="argument-1-Var/index.html#type-t">Var.t</a></code><code></code></div><div class="doc"><p>The given type of the variables</p></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>The type of a (possibly not solved) linear system</p></div></div><div class="spec type" id="type-res"><a href="#type-res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'cert res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-res.Solution" class="anchored"><td class="def constructor"><a href="#type-res.Solution" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Solution</span><span class="keyword"> of </span>(<a href="index.html#type-var">var</a><span class="keyword"> * </span>Q.t) list</code></td></tr><tr id="type-res.Unsatisfiable" class="anchored"><td class="def constructor"><a href="#type-res.Unsatisfiable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsatisfiable</span><span class="keyword"> of </span><span class="type-var">'cert</span></code></td></tr></table><code></code></div><div class="doc"><p>Generic type returned when solving the simplex. A solution is a list of bindings
that satisfies all the constraints inside the system. If the system is unsatisfiable,
an explanation of type <code class="code">'cert</code> is returned.</p></div></div><div class="spec type" id="type-k_cert"><a href="#type-k_cert" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>k_cert</code><code><span class="keyword"> = </span><a href="index.html#type-var">var</a><span class="keyword"> * </span>(Q.t<span class="keyword"> * </span><a href="index.html#type-var">var</a>) list</code><code></code></div><div class="doc"><p>An unsatisfiability explanation is a couple <code class="code">(x, expr)</code>. If <code class="code">expr</code> is the empty list, then there is a contradiction
between two given bounds of <code class="code">x</code>. Else, the explanation is an equality <code class="code">x = expr</code> that is valid (it can be derived
from the original equations of the system) from which a bound can be deduced which contradicts an already given bound of the system.</p></div></div><div class="spec type" id="type-n_cert"><a href="#type-n_cert" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>n_cert</code><code><span class="keyword"> = </span><a href="index.html#type-cert_tree">cert_tree</a> option Pervasives.ref</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-cert_tree"><a href="#type-cert_tree" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>cert_tree</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-cert_tree.Branch" class="anchored"><td class="def constructor"><a href="#type-cert_tree.Branch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Branch</span><span class="keyword"> of </span><a href="index.html#type-var">var</a><span class="keyword"> * </span>Z.t<span class="keyword"> * </span><a href="index.html#type-n_cert">n_cert</a><span class="keyword"> * </span><a href="index.html#type-n_cert">n_cert</a></code></td></tr><tr id="type-cert_tree.Explanation" class="anchored"><td class="def constructor"><a href="#type-cert_tree.Explanation" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Explanation</span><span class="keyword"> of </span><a href="index.html#type-k_cert">k_cert</a></code></td><td class="doc"><p>(** The type of explanation for integer systems. In one case, the system is unsatisfiable when seen as a rational system.
In the other case, two cases are considered : for a given variable <code class="code">x</code> and a bound <code class="code">b</code>, either <code class="code">x</code> is lower than <code class="code">b</code>,
or it is greater then <code class="code">b + 1</code>. *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-k_res"><a href="#type-k_res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>k_res</code><code><span class="keyword"> = </span><a href="index.html#type-k_cert">k_cert</a> <a href="index.html#type-res">res</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-n_res"><a href="#type-n_res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>n_res</code><code><span class="keyword"> = </span><a href="index.html#type-n_cert">n_cert</a> <a href="index.html#type-res">res</a></code><code></code></div><div class="doc"><p>Types returned when solving a system.</p></div></div><div class="spec type" id="type-optim"><a href="#type-optim" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>optim</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-optim.Tight" class="anchored"><td class="def constructor"><a href="#type-optim.Tight" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Tight</span><span class="keyword"> of </span><a href="index.html#type-var">var</a></code></td></tr><tr id="type-optim.Multiply" class="anchored"><td class="def constructor"><a href="#type-optim.Multiply" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Multiply</span><span class="keyword"> of </span><a href="index.html#type-var">var</a><span class="keyword"> * </span>Q.t</code></td></tr></table><code></code></div><div class="doc"><p>The type of traces of the optimizations performed on a simplex.</p></div></div><div class="spec type" id="type-debug_printer"><a href="#type-debug_printer" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>debug_printer</code><code><span class="keyword"> = </span>Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code><code></code></div><div class="doc"><p>TODO</p></div></div><h4>Simplex construction</h4><div class="spec val" id="val-empty"><a href="#val-empty" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>empty : <a href="index.html#type-t">t</a></code></div><div class="doc"><p>The empty system</p></div></div><div class="spec val" id="val-add_eq"><a href="#val-add_eq" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add_eq : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a><span class="keyword"> * </span>(Q.t<span class="keyword"> * </span><a href="index.html#type-var">var</a>) list) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">add_eq s (x, eq)</code> returns a system containing the same constraints as <code class="code">s</code>, plus the equation (x = eq).</p></div></div><div class="spec val" id="val-add_bounds"><a href="#val-add_bounds" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add_bounds : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a><span class="keyword"> * </span>Q.t<span class="keyword"> * </span>Q.t) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">add_bounds (x, lower, upper)</code> returns a system containing the same contraints as <code class="code">s</code>, plus
the bounds <code class="code">lower</code> and <code class="code">upper</code> for the given variable <code class="code">x</code>. If the bound is loose on one side (no upper bounds for instance),
the values <code class="code">Zarith.Q.inf</code> and <code class="code">Zarith.Q.minus_inf</code> can be used. By default, in a system, all variables have no bounds,
i.e have lower bound <code class="code">Zarith.Q.minus_inf</code> and upper bound <code class="code">Zarith.Q.inf</code>.</p></div></div><h4>Simplex solving</h4><div class="spec val" id="val-ksolve"><a href="#val-ksolve" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>ksolve : ?&#8288;debug:<a href="index.html#type-debug_printer">debug_printer</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-k_res">k_res</a></code></div><div class="doc"><p><code class="code">ksolve s</code> solves the system <code class="code">s</code> and returns a solution, if one exists. This function may chnge
the internal representation of the system to that of an equivalent one (permutation of basic and
non basic variables and pivot operation on the tableaux).</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">debug</span>: An optional debug option can be given, and will be applied to all systems encountered
while solving the system, including the initial and final states of the system. Can be used for
printing intermediate states of the system.</li></ul></div></div><div class="spec val" id="val-nsolve"><a href="#val-nsolve" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>nsolve : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-n_res">n_res</a></code></div><div class="doc"><p><code class="code">nsolve s int_vars</code> solve the system <code class="code">s</code> considering the variables in <code class="code">int_vars</code> as integers instead
of rationals. There is no guarantee that this function will terminate (for instance, on the system
(<code class="code">1 &lt;= 3 * x + 3 * y &lt;= 2</code>, <code class="code">nsolve</code> will NOT terminate), it hence recommended to apply a global
bounds to the variables of a system before trying to solve it with this function.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">debug</span>: An optional debug option can be given, and will be applied to all systems encountered
at the end of a branch while solving the system. Can be used for printing intermediate states of the system.</li></ul></div></div><div class="spec val" id="val-safe_nsolve"><a href="#val-safe_nsolve" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>safe_nsolve : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> list <span class="keyword">&#8209;&gt;</span> Q.t<span class="keyword"> * </span><a href="index.html#type-n_res">n_res</a></code></div><div class="doc"><p><code class="code">safe_nsolve s int_vars</code> solves the system <code class="code">s</code> considering the variables in <code class="code">int_vars</code> as integers.
This function always terminate, thanks to a global bound that is applied to all variables of int_vars.
The global bound is also returned to allow for verification.
Due to the bounds being very high, <code class="code">safe_nsolve</code> may take a lot of time and memory. It is recommended to apply
some optimizations before trying to solve system using this function.</p></div></div><h4>Simplex optimizations</h4><div class="spec val" id="val-tighten"><a href="#val-tighten" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tighten : <a href="index.html#type-var">var</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-optim">optim</a> list</code></div><div class="doc"><p><code class="code">tighten int_vars s</code> tightens all the bounds of the variables in <code class="code">int_vars</code> and returns the list of optimizations
performed on the system.</p></div></div><div class="spec val" id="val-normalize"><a href="#val-normalize" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>normalize : <a href="index.html#type-var">var</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-optim">optim</a> list</code></div><div class="doc"><p><code class="code">normalize int_vars s</code>, normalizes the system <code class="code">s</code> (in place), and returns the list of optimizations performed on it.
<code class="code">int_vars</code> is the list of variable that should be assigned an integer.
A normalized system has only integer coeficients in his tableaux. Furthermore, in any line (i.e in the expression of a basic variable <code class="code">x</code>),
the gcd of all coeficients is <code class="code">1</code>. This includes the bounds of <code class="code">x</code>, except in the following case.
If all pertinent variables (have a non-zero coeficient) in the expression of <code class="code">x</code> are in <code class="code">int_vars</code>, then the bounds are divided by the gcd
of the coeficients in the expression, and then rounded (since we can deduce that <code class="code">x</code> must be an integer as well).</p></div></div><div class="spec val" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>preprocess : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-optim">optim</a> list</code></div><div class="doc"><p>Apply all optimizations to a simplex.</p></div></div><div class="spec val" id="val-apply_optims"><a href="#val-apply_optims" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>apply_optims : (<a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-optim">optim</a> list) list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-optim">optim</a> list</code></div><div class="doc"><p>Apply the given optimizations to the simplex.</p></div></div><h4>Access functions</h4><div class="spec val" id="val-get_tab"><a href="#val-get_tab" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_tab : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> list<span class="keyword"> * </span><a href="index.html#type-var">var</a> list<span class="keyword"> * </span>Q.t list list</code></div><div class="doc"><p><code class="code">get_tab s</code> returns the current tableaux of <code class="code">s</code> as a triple <code class="code">(l, l', tab)</code> where <code class="code">l</code> is the list of the
non-basic variables, <code class="code">l'</code> the list of basic variables and <code class="code">tab</code> the list of the rows of the tableaux in
the same order as <code class="code">l</code> and <code class="code">l'</code>.</p></div></div><div class="spec val" id="val-get_assign"><a href="#val-get_assign" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_assign : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a><span class="keyword"> * </span>Q.t) list</code></div><div class="doc"><p><code class="code">get_assign s</code> returns the current (partial) assignment of the variables in <code class="code">s</code> as a list of bindings.
Only non-basic variables (as given by <code class="code">get_tab</code>) should appear in this assignent. As such, and according to
simplex invariants, all variables in the assignment returned should satisfy their bounds.</p></div></div><div class="spec val" id="val-get_full_assign"><a href="#val-get_full_assign" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_full_assign : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a><span class="keyword"> * </span>Q.t) list</code></div><div class="doc"></div></div><div class="spec val" id="val-get_bounds"><a href="#val-get_bounds" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_bounds : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> <span class="keyword">&#8209;&gt;</span> Q.t<span class="keyword"> * </span>Q.t</code></div><div class="doc"><p><code class="code">get_bounds s x</code> returns the pair <code class="code">(low, upp)</code> of the current bounds for the variable <code class="code">x</code>.
Notice that it is possible that <code class="code">low</code> is strictly greater than <code class="code">upp</code>.</p></div></div><div class="spec val" id="val-get_all_bounds"><a href="#val-get_all_bounds" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_all_bounds : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a><span class="keyword"> * </span>(Q.t<span class="keyword"> * </span>Q.t)) list</code></div><div class="doc"><p><code class="code">get_all_bounds s</code> returns the list of all the explicit bounds of <code class="code">s</code>. Any variable not present
in the return value is assumed to have no bounds (i.e lower bound <code class="code">Zarith.Q.minus_inf</code> and
upper bound <code class="code">Zarith.Q.inf</code>).</p></div></div><h4>Printing functions</h4><div class="spec val" id="val-print_debug"><a href="#val-print_debug" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print_debug : (Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">print_debug print_var</code> returns a suitable function for printing debug info on the current state of a system.
It can for instance be used as the debug function of <code class="code">solve</code> to see the evolution of the simplex.</p></div></div></body></html>