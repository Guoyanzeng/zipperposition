<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="InnerTerm.html">
<link rel="next" href="Type.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="InnerTerm" rel="Chapter" href="InnerTerm.html">
<link title="FOTerm" rel="Chapter" href="FOTerm.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="Util" rel="Chapter" href="Util.html">
<link title="STerm" rel="Chapter" href="STerm.html">
<link title="Interfaces" rel="Chapter" href="Interfaces.html">
<link title="DBEnv" rel="Chapter" href="DBEnv.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="HVar" rel="Chapter" href="HVar.html">
<link title="Subst" rel="Chapter" href="Subst.html">
<link title="Unif" rel="Chapter" href="Unif.html">
<link title="Signature" rel="Chapter" href="Signature.html">
<link title="Scoped" rel="Chapter" href="Scoped.html">
<link title="Unif_intf" rel="Chapter" href="Unif_intf.html">
<link title="TypeInference" rel="Chapter" href="TypeInference.html">
<link title="Options" rel="Chapter" href="Options.html">
<link title="Comparison" rel="Chapter" href="Comparison.html">
<link title="Precedence" rel="Chapter" href="Precedence.html">
<link title="Builtin" rel="Chapter" href="Builtin.html">
<link title="Ordering" rel="Chapter" href="Ordering.html">
<link title="Skolem" rel="Chapter" href="Skolem.html">
<link title="Cnf" rel="Chapter" href="Cnf.html">
<link title="ID" rel="Chapter" href="ID.html">
<link title="IDOrBuiltin" rel="Chapter" href="IDOrBuiltin.html">
<link title="SLiteral" rel="Chapter" href="SLiteral.html">
<link title="Index" rel="Chapter" href="Index.html">
<link title="Index_intf" rel="Chapter" href="Index_intf.html">
<link title="Dtree" rel="Chapter" href="Dtree.html">
<link title="Fingerprint" rel="Chapter" href="Fingerprint.html">
<link title="NPDtree" rel="Chapter" href="NPDtree.html">
<link title="Binder" rel="Chapter" href="Binder.html">
<link title="Congruence" rel="Chapter" href="Congruence.html">
<link title="FeatureVector" rel="Chapter" href="FeatureVector.html">
<link title="FV_tree" rel="Chapter" href="FV_tree.html">
<link title="UntypedAST" rel="Chapter" href="UntypedAST.html">
<link title="Ind_ty" rel="Chapter" href="Ind_ty.html">
<link title="TypedSTerm" rel="Chapter" href="TypedSTerm.html">
<link title="Statement" rel="Chapter" href="Statement.html">
<link title="Flex_state" rel="Chapter" href="Flex_state.html">
<link title="Compute_prec" rel="Chapter" href="Compute_prec.html">
<link title="Ordinal" rel="Chapter" href="Ordinal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="ParseLocation" rel="Chapter" href="ParseLocation.html">
<link title="Multiset" rel="Chapter" href="Multiset.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="Hash" rel="Chapter" href="Hash.html">
<link title="IArray" rel="Chapter" href="IArray.html">
<link title="AllocCache" rel="Chapter" href="AllocCache.html">
<link title="Multiset_intf" rel="Chapter" href="Multiset_intf.html">
<link title="Signal" rel="Chapter" href="Signal.html">
<link title="UnionFind" rel="Chapter" href="UnionFind.html"><link title="Term" rel="Section" href="#2_Term">
<link title="Constructors" rel="Section" href="#2_Constructors">
<link title="Sequences" rel="Section" href="#2_Sequences">
<link title="Subterms and Positions" rel="Section" href="#2_SubtermsandPositions">
<link title="High-level operations" rel="Section" href="#2_Highleveloperations">
<link title="Fold" rel="Section" href="#2_Fold">
<link title="Some AC-utils" rel="Section" href="#2_SomeACutils">
<link title="Printing/parsing" rel="Section" href="#2_Printingparsing">
<link title="Arith" rel="Section" href="#2_Arith">
<link title="TPTP" rel="Section" href="#2_TPTP">
<title>FOTerm</title>
</head>
<body>
<div class="navbar"><a class="pre" href="InnerTerm.html" title="InnerTerm">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Type.html" title="Type">Next</a>
</div>
<h1>Module <a href="type_FOTerm.html">FOTerm</a></h1>

<pre><span class="keyword">module</span> FOTerm: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<h1 id="1_Firstorderterms">First-order terms</h1>
<p>

    Those terms provide a first-order presentation of higher-order terms (without
    functions), in the sense that they make currying possible (as well as applying
    functions to other terms).
<p>

    This is as if terms had an `apply` symbol everywhere, but more lightweight.
<p>

    Types and terms are mixed because it makes application much easier.<br>
</div>
<hr width="100%">
<br>
<h2 id="2_Term">Term</h2><br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = private <code class="type"><a href="InnerTerm.html#TYPEt">InnerTerm.t</a></code> </pre>


<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type"></code>term</span> = <code class="type"><a href="FOTerm.html#TYPEt">t</a></code> </pre>


<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> = <code class="type"><a href="Type.html#TYPEt">Type.t</a> <a href="HVar.html#TYPEt">HVar.t</a></code> </pre>
<div class="info ">
Variables are typed with <a href="Type.html#TYPEt"><code class="code"><span class="constructor">Type</span>.t</code></a><br>
</div>


<pre><code><span id="TYPEview"><span class="keyword">type</span> <code class="type"></code>view</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.AppBuiltin"><span class="constructor">AppBuiltin</span></span> <span class="keyword">of</span> <code class="type"><a href="Builtin.html#TYPEt">Builtin.t</a> * <a href="FOTerm.html#TYPEt">t</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.DB"><span class="constructor">DB</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Bound variable (De Bruijn index)<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.Var"><span class="constructor">Var</span></span> <span class="keyword">of</span> <code class="type"><a href="FOTerm.html#TYPEvar">var</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Term variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.Const"><span class="constructor">Const</span></span> <span class="keyword">of</span> <code class="type"><a href="ID.html#TYPEt">ID.t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Typed constant<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTview.App"><span class="constructor">App</span></span> <span class="keyword">of</span> <code class="type"><a href="FOTerm.html#TYPEt">t</a> * <a href="FOTerm.html#TYPEt">t</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Application to a list of terms (cannot be left-nested)<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="VALview"><span class="keyword">val</span> view</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEview">view</a></code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.Classic.html">Classic</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.Classic.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Classic view
</div>

<pre><span id="VALsubterm"><span class="keyword">val</span> subterm</span> : <code class="type">sub:<a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
checks whether <code class="code">sub</code> is a (non-strict) subterm of <code class="code">t</code><br>
</div>

<pre><span class="keyword">include</span> <a href="Interfaces.HASH.html">Interfaces.HASH</a></pre>

<pre><span class="keyword">include</span> <a href="Interfaces.ORD.html">Interfaces.ORD</a></pre>

<pre><span id="VALty"><span class="keyword">val</span> ty</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a></code></pre><div class="info ">
Obtain the type of a term..<br>
</div>

<pre><span class="keyword">module</span> <a href="FOTerm.Set.html">Set</a>: <code class="type">CCSet.S</code><code class="type">  with type elt = t</code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.Map.html">Map</a>: <code class="type">CCMap.S</code><code class="type">  with type key = t</code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.Tbl.html">Tbl</a>: <code class="type">CCHashtbl.S</code><code class="type">  with type key = t</code></pre>
<pre><span id="VALhash_mod_alpha"><span class="keyword">val</span> hash_mod_alpha</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Hash invariant w.r.t variable renaming<br>
</div>

<pre><span id="VALsame_l"><span class="keyword">val</span> same_l</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> list -> <a href="FOTerm.html#TYPEt">t</a> list -> bool</code></pre><div class="info ">
<code class="code">same_l&nbsp;l1&nbsp;l2</code> returns <code class="code"><span class="keyword">true</span></code> if terms of <code class="code">l1</code> and <code class="code">l2</code> are pairwise
    equal, <code class="code"><span class="keyword">false</span></code> otherwise.
    Precondition: both lists have the same length<br>
<b>Raises</b> <code>Assert_failure</code> if lists have not the same length<br>
</div>
<br>
<h2 id="2_Constructors">Constructors</h2><br>

<pre><span id="VALvar"><span class="keyword">val</span> var</span> : <code class="type"><a href="FOTerm.html#TYPEvar">var</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALvar_of_int"><span class="keyword">val</span> var_of_int</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> int -> <a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALbvar"><span class="keyword">val</span> bvar</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> int -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Create a bound variable. Providing a type is mandatory.
    <b>Warning</b>: be careful and try not to use this function directly.<br>
<b>Raises</b> <code>InnerTerm.IllFormedTerm</code> if the index is &lt; 0<br>
</div>

<pre><span id="VALbuiltin"><span class="keyword">val</span> builtin</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="Builtin.html#TYPEt">Builtin.t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALapp_builtin"><span class="keyword">val</span> app_builtin</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="Builtin.html#TYPEt">Builtin.t</a> -> <a href="FOTerm.html#TYPEt">t</a> list -> <a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type">ty:<a href="Type.html#TYPEt">Type.t</a> -> <a href="ID.html#TYPEt">ID.t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Create a typed constant<br>
</div>

<pre><span id="VALtyapp"><span class="keyword">val</span> tyapp</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Apply a term to types<br>
<b>Raises</b> <code>Type.Error</code> if types do not match.<br>
</div>

<pre><span id="VALapp"><span class="keyword">val</span> app</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEt">t</a> list -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Apply a term to a list of terms<br>
<b>Raises</b> <code>Type.ApplyError</code> if types do not match.<br>
</div>

<pre><span id="VALapp_full"><span class="keyword">val</span> app_full</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a> list -> <a href="FOTerm.html#TYPEt">t</a> list -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Apply the term to types, then to terms<br>
</div>

<pre><span id="VALtrue_"><span class="keyword">val</span> true_</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALfalse_"><span class="keyword">val</span> false_</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a></code></pre>
<pre><span id="VALgrounding"><span class="keyword">val</span> grounding</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">grounding&nbsp;ty</code> is a unique constant of type <code class="code">ty</code><br>
</div>

<pre><span id="VALis_var"><span class="keyword">val</span> is_var</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_bvar"><span class="keyword">val</span> is_bvar</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_app"><span class="keyword">val</span> is_app</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALis_const"><span class="keyword">val</span> is_const</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre>
<pre><span id="VALas_const"><span class="keyword">val</span> as_const</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a> option</code></pre>
<pre><span id="VALas_const_exn"><span class="keyword">val</span> as_const_exn</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a></code></pre>
<pre><span id="VALof_term_unsafe"><span class="keyword">val</span> of_term_unsafe</span> : <code class="type"><a href="InnerTerm.html#TYPEt">InnerTerm.t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
<b>NOTE</b>: this can break the invariants and make <a href="FOTerm.html#VALview"><code class="code"><span class="constructor">FOTerm</span>.view</code></a> fail. Only
    apply with caution.<br>
</div>

<pre><span id="VALof_ty"><span class="keyword">val</span> of_ty</span> : <code class="type"><a href="Type.html#TYPEt">Type.t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
Upcast from type<br>
</div>

<pre><span class="keyword">module</span> <a href="FOTerm.VarSet.html">VarSet</a>: <code class="type">CCSet.S</code><code class="type">  with type elt = var</code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.VarMap.html">VarMap</a>: <code class="type">CCMap.S</code><code class="type">  with type key = var</code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.VarTbl.html">VarTbl</a>: <code class="type">CCHashtbl.S</code><code class="type">  with type key = var</code></pre><br>
<h2 id="2_Sequences">Sequences</h2><br>

<pre><span class="keyword">module</span> <a href="FOTerm.Seq.html">Seq</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.Seq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALvar_occurs"><span class="keyword">val</span> var_occurs</span> : <code class="type">var:<a href="FOTerm.html#TYPEvar">var</a> -> <a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">var_occurs&nbsp;~var&nbsp;t</code> true iff <code class="code">var</code> in t<br>
</div>

<pre><span id="VALis_ground"><span class="keyword">val</span> is_ground</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
is the term ground? (no free vars)<br>
</div>

<pre><span id="VALmonomorphic"><span class="keyword">val</span> monomorphic</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
true if the term contains no type var<br>
</div>

<pre><span id="VALmax_var"><span class="keyword">val</span> max_var</span> : <code class="type">VarSet.t -> int</code></pre><div class="info ">
find the maximum variable<br>
</div>

<pre><span id="VALmin_var"><span class="keyword">val</span> min_var</span> : <code class="type">VarSet.t -> int</code></pre><div class="info ">
minimum variable<br>
</div>

<pre><span id="VALadd_vars"><span class="keyword">val</span> add_vars</span> : <code class="type">unit VarTbl.t -> <a href="FOTerm.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
add variables of the term to the set<br>
</div>

<pre><span id="VALvars"><span class="keyword">val</span> vars</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> VarSet.t</code></pre><div class="info ">
compute variables of the terms<br>
</div>

<pre><span id="VALvars_prefix_order"><span class="keyword">val</span> vars_prefix_order</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEvar">var</a> list</code></pre><div class="info ">
variables in prefix traversal order<br>
</div>

<pre><span id="VALdepth"><span class="keyword">val</span> depth</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> int</code></pre><div class="info ">
depth of the term<br>
</div>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a> option</code></pre><div class="info ">
head ID.t<br>
</div>

<pre><span id="VALhead_exn"><span class="keyword">val</span> head_exn</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="ID.html#TYPEt">ID.t</a></code></pre><div class="info ">
head ID.t (or Invalid_argument)<br>
</div>

<pre><span id="VALsize"><span class="keyword">val</span> size</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Size (number of nodes)<br>
</div>

<pre><span id="VALweight"><span class="keyword">val</span> weight</span> : <code class="type">?var:int -> ?sym:(<a href="ID.html#TYPEt">ID.t</a> -> int) -> <a href="FOTerm.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Compute the weight of a term, given a weight for variables
    and one for ID.ts.<br>
<b>Since</b> 0.5.3<br>
</div>
<div class="param_info"><code class="code">var</code> : unique weight for every variable (default 1)</div>
<div class="param_info"><code class="code">sym</code> : function from ID.ts to their weight (default <code class="code">const&nbsp;1</code>)</div>

<pre><span id="VALty_vars"><span class="keyword">val</span> ty_vars</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> Type.VarSet.t</code></pre><div class="info ">
Set of free type variables<br>
</div>
<br>
<h2 id="2_SubtermsandPositions">Subterms and Positions</h2><br>

<pre><span class="keyword">module</span> <a href="FOTerm.Pos.html">Pos</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.Pos.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALreplace"><span class="keyword">val</span> replace</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> old:<a href="FOTerm.html#TYPEt">t</a> -> by:<a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">replace&nbsp;t&nbsp;~old&nbsp;~by</code> syntactically replaces all occurrences of <code class="code">old</code>
    in <code class="code">t</code> by the term <code class="code">by</code>.<br>
</div>

<pre><span id="VALreplace_m"><span class="keyword">val</span> replace_m</span> : <code class="type"><a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEt">t</a> Map.t -> <a href="FOTerm.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">replace&nbsp;t&nbsp;m</code> syntactically replaces all occurrences of bindings of
    the map in <code class="code">t</code>, starting from the root<br>
</div>
<br>
<h2 id="2_Highleveloperations">High-level operations</h2><br>

<pre><span id="VALsymbols"><span class="keyword">val</span> symbols</span> : <code class="type">?init:ID.Set.t -> <a href="FOTerm.html#TYPEt">t</a> -> ID.Set.t</code></pre><div class="info ">
Symbols of the term (keys of signature)<br>
</div>

<pre><span id="VALcontains_symbol"><span class="keyword">val</span> contains_symbol</span> : <code class="type"><a href="ID.html#TYPEt">ID.t</a> -> <a href="FOTerm.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Does the term contain this given ID.t?<br>
</div>
<br>
<h2 id="2_Fold">Fold</h2><br>
<br>
High level fold-like combinators<br>

<pre><span id="VALall_positions"><span class="keyword">val</span> all_positions</span> : <code class="type">?vars:bool -><br>       ?ty_args:bool -><br>       ?pos:<a href="Position.html#TYPEt">Position.t</a> -> <a href="FOTerm.html#TYPEt">t</a> -> <a href="FOTerm.html#TYPEt">t</a> <a href="Position.With.html#TYPEt">Position.With.t</a> Sequence.t</code></pre><div class="info ">
Iterate on all sub-terms with their position.<br>
</div>
<div class="param_info"><code class="code">vars</code> : specifies whether variables are folded on (default false).</div>
<div class="param_info"><code class="code">ty_args</code> : specifies whether type arguments are folded on (default true).</div>
<div class="param_info"><code class="code">pos</code> : the initial position (default empty)</div>
<br>
<h2 id="2_SomeACutils">Some AC-utils</h2><br>

<pre><span class="keyword">module type</span> <a href="FOTerm.AC_SPEC.html">AC_SPEC</a> = <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.AC_SPEC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.AC.html">AC</a> <code class="code">(</code><code class="code"><span class="constructor">A</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="FOTerm.AC_SPEC.html">AC_SPEC</a></code><code class="code">)&nbsp;</code>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.AC.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Printingparsing">Printing/parsing</h2><br>

<pre><span id="VALprint_all_types"><span class="keyword">val</span> print_all_types</span> : <code class="type">bool Pervasives.ref</code></pre><div class="info ">
If true, <code class="code">pp</code> will print the types of all annotated terms<br>
</div>

<pre><span class="keyword">include</span> <a href="Interfaces.PRINT.html">Interfaces.PRINT</a></pre>

<pre><span class="keyword">include</span> <a href="Interfaces.PRINT_DE_BRUIJN.html">Interfaces.PRINT_DE_BRUIJN</a></pre>

<pre><span id="VALadd_hook"><span class="keyword">val</span> add_hook</span> : <code class="type">print_hook -> unit</code></pre><div class="info ">
Hook used by default for printing<br>
</div>

<pre><span id="VALdefault_hooks"><span class="keyword">val</span> default_hooks</span> : <code class="type">unit -> print_hook list</code></pre><div class="info ">
List of default hooks<br>
</div>

<pre><span id="VALdebugf"><span class="keyword">val</span> debugf</span> : <code class="type">Format.formatter -> <a href="FOTerm.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
debugf printing, with sorts<br>
</div>
<br>
<h2 id="2_Arith">Arith</h2><br>

<pre><span class="keyword">module</span> <a href="FOTerm.Arith.html">Arith</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.Arith.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_TPTP">TPTP</h2><br>

<pre><span class="keyword">module</span> <a href="FOTerm.TPTP.html">TPTP</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.TPTP.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="FOTerm.Conv.html">Conv</a>: <code class="code"><span class="keyword">sig</span></code> <a href="FOTerm.Conv.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>