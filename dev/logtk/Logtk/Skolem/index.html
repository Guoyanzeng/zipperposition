<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Skolem (logtk.Logtk.Skolem)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">logtk</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Logtk.Skolem</span></h1></header><h2>Skolem symbols</h2><p>A Skolem symbol is a witness for an existential property, used
in CNF.</p><p>Typically, we transform <code class="code">∃x. p(x)</code> into <code class="code">p(sk_x)</code> where <code class="code">sk_x</code>
is a fresh Skolem constant, &quot;witnessing&quot; the existential property.</p><div class="spec type" id="type-type_"><a href="#type-type_" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>type_</code><code><span class="keyword"> = </span><a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>term</code><code><span class="keyword"> = </span><a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-form"><a href="#type-form" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>form</code><code><span class="keyword"> = </span><a href="../TypedSTerm/index.html#type-t">TypedSTerm.t</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-ctx"><a href="#type-ctx" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>ctx</code><code></code><code></code></div><div class="doc"><p>Context needed to create new symbols</p></div></div><div class="spec val" id="val-create"><a href="#val-create" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create : ?&#8288;prefix:string <span class="keyword">&#8209;&gt;</span> ?&#8288;prop_prefix:string <span class="keyword">&#8209;&gt;</span> ?&#8288;on_new:(<a href="../ID/index.html#type-t">ID.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-type_">type_</a> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-ctx">ctx</a></code></div><div class="doc"><p>New skolem contex. A prefix can be provided, which will be
added to all newly created skolem symbols.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">prefix</span>: used to name skolem functions/constants</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">prop_prefix</span>: used to name sub-formulas during CNF</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">on_id</span>: function called whenever a Skolem symbol is created</li></ul></div></div><div class="spec val" id="val-fresh_skolem"><a href="#val-fresh_skolem" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fresh_skolem : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> ty:<a href="index.html#type-type_">type_</a> <span class="keyword">&#8209;&gt;</span> vars_count:int <span class="keyword">&#8209;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></div><div class="doc"><p>Just obtain a fresh skolem symbol. It is also declared
in the inner signature.</p></div></div><div class="spec val" id="val-fresh_skolem_prefix"><a href="#val-fresh_skolem_prefix" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fresh_skolem_prefix : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> ty:<a href="index.html#type-type_">type_</a> <span class="keyword">&#8209;&gt;</span> vars_count:int <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="../ID/index.html#type-t">ID.t</a></code></div><div class="doc"><p>Fresh symbol with a different name</p></div></div><div class="spec val" id="val-pop_new_skolem_symbols"><a href="#val-pop_new_skolem_symbols" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pop_new_skolem_symbols : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> (<a href="../ID/index.html#type-t">ID.t</a><span class="keyword"> * </span><a href="index.html#type-type_">type_</a>) list</code></div><div class="doc"><p>Remove and return the list of newly created Skolem symbols</p></div></div><div class="spec val" id="val-counter"><a href="#val-counter" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>counter : <a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p>Monotonic counter, increased at every definition</p></div></div><h3>Skolemization</h3><div class="spec val" id="val-skolem_form"><a href="#val-skolem_form" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>skolem_form : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-type_">type_</a>, <a href="index.html#type-term">term</a>) <a href="../Var/Subst/index.html#type-t">Var.Subst.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-type_">type_</a> <a href="../Var/index.html#type-t">Var.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-form">form</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term">term</a></code></div><div class="doc"><p><code class="code">skolem_form ~ctx subst var f</code> returns a term <code class="code">t</code> made of a new symbol
applied to the free variables of <code class="code">f</code> that do not occur in <code class="code">subst</code>.
This term should replace the variable <code class="code">var</code>, occurring free in <code class="code">f</code>.</p><p>For instance, <code class="code">skolem_form ~ctx ø Y p(a, b, Y, X)</code> will yield
something like <code class="code">sk42(X)</code>.</p></div></div><h3>Definitions of Formulas</h3><div class="spec type" id="type-polarity"><a href="#type-polarity" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>polarity</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-polarity.Pos" class="anchored"><td class="def constructor"><a href="#type-polarity.Pos" class="anchor"></a><code><span class="keyword">| </span></code><code>`Pos</code></td></tr><tr id="type-polarity.Neg" class="anchored"><td class="def constructor"><a href="#type-polarity.Neg" class="anchor"></a><code><span class="keyword">| </span></code><code>`Neg</code></td></tr><tr id="type-polarity.Both" class="anchored"><td class="def constructor"><a href="#type-polarity.Both" class="anchor"></a><code><span class="keyword">| </span></code><code>`Both</code></td></tr></table><code> ]</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-pp_polarity"><a href="#val-pp_polarity" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_polarity : <a href="index.html#type-polarity">polarity</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec type" id="type-form_definition"><a href="#type-form_definition" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>form_definition</code><code></code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-form_definition.form" class="anchored"><td class="def field"><a href="#type-form_definition.form" class="anchor"></a><code>form : <a href="index.html#type-form">form</a>;</code></td></tr><tr id="type-form_definition.proxy_id" class="anchored"><td class="def field"><a href="#type-form_definition.proxy_id" class="anchor"></a><code>proxy_id : <a href="../ID/index.html#type-t">ID.t</a>;</code></td></tr><tr id="type-form_definition.proxy" class="anchored"><td class="def field"><a href="#type-form_definition.proxy" class="anchor"></a><code>proxy : <a href="index.html#type-term">term</a>;</code></td></tr><tr id="type-form_definition.proxy_ty" class="anchored"><td class="def field"><a href="#type-form_definition.proxy_ty" class="anchor"></a><code>proxy_ty : <a href="index.html#type-type_">type_</a>;</code></td></tr><tr id="type-form_definition.rw_rules" class="anchored"><td class="def field"><a href="#type-form_definition.rw_rules" class="anchor"></a><code>rw_rules : bool;</code></td></tr><tr id="type-form_definition.polarity" class="anchored"><td class="def field"><a href="#type-form_definition.polarity" class="anchor"></a><code>polarity : <a href="index.html#type-polarity">polarity</a>;</code></td></tr><tr id="type-form_definition.proof" class="anchored"><td class="def field"><a href="#type-form_definition.proof" class="anchor"></a><code>proof : <a href="../Proof/index.html#type-step">Proof.step</a>;</code></td></tr><tr id="type-form_definition.as_stmt" class="anchored"><td class="def field"><a href="#type-form_definition.as_stmt" class="anchor"></a><code>as_stmt : <a href="../Statement/index.html#type-input_t">Statement.input_t</a> list lazy_t;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-pp_form_definition"><a href="#val-pp_form_definition" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_form_definition : <a href="index.html#type-form_definition">form_definition</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-define_form"><a href="#val-define_form" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>define_form : ?&#8288;pattern:string <span class="keyword">&#8209;&gt;</span> ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> rw_rules:bool <span class="keyword">&#8209;&gt;</span> polarity:<a href="index.html#type-polarity">polarity</a> <span class="keyword">&#8209;&gt;</span> parents:<a href="../Proof/Parent/index.html#type-t">Proof.Parent.t</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-form">form</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-form_definition">form_definition</a></code></div><div class="doc"><p><code class="code">define ~ctx f</code> returns a new predicate for <code class="code">f</code>,
with the free variables of <code class="code">f</code> as arguments.</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the atomic formula that stands for <code class="code">f</code>.</li></ul></div></div><div class="spec type" id="type-term_definition"><a href="#type-term_definition" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>term_definition</code><code></code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-term_definition.td_id" class="anchored"><td class="def field"><a href="#type-term_definition.td_id" class="anchor"></a><code>td_id : <a href="../ID/index.html#type-t">ID.t</a>;</code></td></tr><tr id="type-term_definition.td_ty" class="anchored"><td class="def field"><a href="#type-term_definition.td_ty" class="anchor"></a><code>td_ty : <a href="index.html#type-type_">type_</a>;</code></td></tr><tr id="type-term_definition.td_rules" class="anchored"><td class="def field"><a href="#type-term_definition.td_rules" class="anchor"></a><code>td_rules : (<a href="index.html#type-form">form</a>, <a href="index.html#type-term">term</a>, <a href="index.html#type-type_">type_</a>) <a href="../Statement/index.html#type-def_rule">Statement.def_rule</a> list;</code></td></tr><tr id="type-term_definition.td_as_def" class="anchored"><td class="def field"><a href="#type-term_definition.td_as_def" class="anchor"></a><code>td_as_def : (<a href="index.html#type-form">form</a>, <a href="index.html#type-term">term</a>, <a href="index.html#type-type_">type_</a>) <a href="../Statement/index.html#type-def">Statement.def</a>;</code></td></tr><tr id="type-term_definition.td_proof" class="anchored"><td class="def field"><a href="#type-term_definition.td_proof" class="anchor"></a><code>td_proof : <a href="../Proof/index.html#type-step">Proof.step</a>;</code></td></tr><tr id="type-term_definition.td_stmt" class="anchored"><td class="def field"><a href="#type-term_definition.td_stmt" class="anchor"></a><code>td_stmt : <a href="../Statement/index.html#type-input_t">Statement.input_t</a> list lazy_t;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-define_term"><a href="#val-define_term" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>define_term : ?&#8288;pattern:string <span class="keyword">&#8209;&gt;</span> ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> parents:<a href="../Proof/Parent/index.html#type-t">Proof.Parent.t</a> list <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-term">term</a> list<span class="keyword"> * </span><a href="index.html#type-term">term</a>) list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-term_definition">term_definition</a></code></div><div class="doc"><p><code class="code">define_term l</code> introduces a new function symbol <code class="code">f</code> that is
defined by:
</p><ul><li>for each <code class="code">args, rhs</code> in <code class="code">l</code>, <code class="code">f args = rhs</code></li></ul><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pattern</span>: used to name the new function in an informative way</li></ul></div></div><div class="spec type" id="type-definition"><a href="#type-definition" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>definition</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-definition.Def_form" class="anchored"><td class="def constructor"><a href="#type-definition.Def_form" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Def_form</span><span class="keyword"> of </span><a href="index.html#type-form_definition">form_definition</a></code></td></tr><tr id="type-definition.Def_term" class="anchored"><td class="def constructor"><a href="#type-definition.Def_term" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Def_term</span><span class="keyword"> of </span><a href="index.html#type-term_definition">term_definition</a></code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec val" id="val-pp_definition"><a href="#val-pp_definition" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_definition : <a href="index.html#type-definition">definition</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-new_definitions"><a href="#val-new_definitions" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>new_definitions : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-definition">definition</a> list</code></div><div class="doc"><p>Return the new definitions, without side effects</p></div></div><div class="spec val" id="val-pop_new_definitions"><a href="#val-pop_new_definitions" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pop_new_definitions : ctx:<a href="index.html#type-ctx">ctx</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-definition">definition</a> list</code></div><div class="doc"><p>List of new definitions, that were introduced since the last
call to <a href="index.html#val-new_definitions">new_definitions</a>. The list can be obtained only once,
after which those definitions are not &quot;new&quot; anymore.</p><p>Will call remove_def so there is no risk of re-using a definition
with a new polarity.</p></div></div><div class="spec val" id="val-def_as_stmt"><a href="#val-def_as_stmt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>def_as_stmt : <a href="index.html#type-definition">definition</a> <span class="keyword">&#8209;&gt;</span> <a href="../Statement/index.html#type-input_t">Statement.input_t</a> list</code></div><div class="doc"><p>Project the definition into a list of statements</p></div></div><h3>Attribute</h3></body></html>