<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BBox (libzipperposition.Libzipperposition.BBox)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">libzipperposition</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Libzipperposition.BBox</span></h1></header><h2>BBox (Boolean Box)</h2><p>This module defines a way to encapsulate clauses and some meta-level
properties into boolean literals, and maintains a bijection between
encapsulated values and boolean literals</p><div class="spec val" id="val-section"><a href="#val-section" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>section : <a href="../../../logtk/Logtk/Util/Section/index.html#type-t">Logtk.Util.Section.t</a></code></div><div class="doc"></div></div><div class="spec type" id="type-inductive_case"><a href="#type-inductive_case" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>inductive_case</code><code><span class="keyword"> = </span><a href="../Cover_set/index.html#type-case">Cover_set.case</a></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-payload"><a href="#type-payload" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>payload</code><code></code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-payload.Fresh" class="anchored"><td class="def constructor"><a href="#type-payload.Fresh" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fresh</span></code></td></tr><tr id="type-payload.Clause_component" class="anchored"><td class="def constructor"><a href="#type-payload.Clause_component" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Clause_component</span><span class="keyword"> of </span><a href="../../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a></code></td></tr><tr id="type-payload.Lemma" class="anchored"><td class="def constructor"><a href="#type-payload.Lemma" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma</span><span class="keyword"> of </span><a href="../Cut_form/index.html#type-t">Cut_form.t</a></code></td></tr><tr id="type-payload.Case" class="anchored"><td class="def constructor"><a href="#type-payload.Case" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Case</span><span class="keyword"> of </span><a href="index.html#type-inductive_case">inductive_case</a> list</code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec module" id="module-Lit"><a href="#module-Lit" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Lit/index.html">Lit</a> : <a href="../Bool_lit_intf/index.html#module-type-S">Bool_lit_intf.S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="../Bool_lit_intf/module-type-S/index.html#type-payload">payload</a><span class="keyword"> = </span><a href="index.html#type-payload">payload</a></code></div><div class="doc"></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="Lit/index.html#type-t">Lit.t</a></code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-dummy"><a href="#val-dummy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy : <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-pp_payload"><a href="#val-pp_payload" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_payload : <a href="index.html#type-payload">payload</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-inject_lits"><a href="#val-inject_lits" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>inject_lits : <a href="../../../logtk/Logtk/Literals/index.html#type-t">Logtk.Literals.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Inject a clause into a boolean literal. No other clause will map
to the same literal unless it is alpha-equivalent to this one.
The boolean literal can be negative is the argument is a
unary negative clause</p></div></div><div class="spec val" id="val-inject_lemma"><a href="#val-inject_lemma" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>inject_lemma : <a href="../Cut_form/index.html#type-t">Cut_form.t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Make a new literal from this formula that we are going to cut
on. This is generative, meaning that calling it twice with the
same arguments will produce distinct literals.</p></div></div><div class="spec val" id="val-inject_case"><a href="#val-inject_case" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>inject_case : <a href="index.html#type-inductive_case">inductive_case</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Inject <code class="code">cst = case</code></p></div></div><div class="spec val" id="val-payload"><a href="#val-payload" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>payload : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-payload">payload</a></code></div><div class="doc"><p>Obtain the payload of this boolean literal, that is, what the literal
represents</p></div></div><div class="spec val" id="val-is_case"><a href="#val-is_case" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_case : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"></div></div><div class="spec val" id="val-as_case"><a href="#val-as_case" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>as_case : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-inductive_case">inductive_case</a> list option</code></div><div class="doc"><p>If <code class="code">payload t = Case p</code>, then return <code class="code">Some p</code>, else return <code class="code">None</code></p></div></div><div class="spec val" id="val-as_lemma"><a href="#val-as_lemma" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>as_lemma : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../Cut_form/index.html#type-t">Cut_form.t</a> option</code></div><div class="doc"></div></div><div class="spec val" id="val-must_be_kept"><a href="#val-must_be_kept" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>must_be_kept : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">must_be_kept lit</code> means that <code class="code">lit</code> should survive in boolean splitting,
that is, that if <code class="code">C &lt;- lit, Gamma</code> then any clause derived from <code class="code">C</code>
recursively will have <code class="code">lit</code> in its trail.</p></div></div><div class="spec val" id="val-is_lemma"><a href="#val-is_lemma" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_lemma : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p>returns <code class="code">true</code> if the bool literal represents a lemma</p></div></div><div class="spec val" id="val-to_s_form"><a href="#val-to_s_form" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_s_form : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../../../logtk/Logtk/TypedSTerm/Form/index.html#type-t">Logtk.TypedSTerm.Form.t</a></code></div><div class="doc"></div></div><h3>Printers</h3><p>
Those printers print the content (injection) of a boolean literal, if any</p><div class="spec val" id="val-pp"><a href="#val-pp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_tstp"><a href="#val-pp_tstp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_tstp : <a href="index.html#type-t">t</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_zf"><a href="#val-pp_zf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_zf : <a href="index.html#type-t">t</a> CCFormat.printer</code></div><div class="doc"></div></div><div class="spec val" id="val-pp_bclause"><a href="#val-pp_bclause" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_bclause : <a href="index.html#type-t">t</a> list CCFormat.printer</code></div><div class="doc"></div></div></body></html>